{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar extendStatics = Object.setPrototypeOf || {\n  __proto__: []\n} instanceof Array && function (e, t) {\n  e.__proto__ = t;\n} || function (e, t) {\n  for (var r in t) {\n    t.hasOwnProperty(r) && (e[r] = t[r]);\n  }\n};\n\nfunction __extends(e, t) {\n  function r() {\n    this.constructor = e;\n  }\n\n  extendStatics(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r());\n}\n\nvar __assign = Object.assign || function (e) {\n  for (var t, r = 1, n = arguments.length; r < n; r++) {\n    for (var o in t = arguments[r]) {\n      Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);\n    }\n  }\n\n  return e;\n};\n\nfunction __awaiter(e, t, r, n) {\n  return new (r || (r = Promise))(function (o, a) {\n    function i(e) {\n      try {\n        u(n.next(e));\n      } catch (e) {\n        a(e);\n      }\n    }\n\n    function s(e) {\n      try {\n        u(n.throw(e));\n      } catch (e) {\n        a(e);\n      }\n    }\n\n    function u(e) {\n      e.done ? o(e.value) : new r(function (t) {\n        t(e.value);\n      }).then(i, s);\n    }\n\n    u((n = n.apply(e, t || [])).next());\n  });\n}\n\nfunction __generator(e, t) {\n  var r,\n      n,\n      o,\n      a,\n      i = {\n    label: 0,\n    sent: function sent() {\n      if (1 & o[0]) throw o[1];\n      return o[1];\n    },\n    trys: [],\n    ops: []\n  };\n  return a = {\n    next: s(0),\n    throw: s(1),\n    return: s(2)\n  }, \"function\" == typeof Symbol && (a[Symbol.iterator] = function () {\n    return this;\n  }), a;\n\n  function s(a) {\n    return function (s) {\n      return function (a) {\n        if (r) throw new TypeError(\"Generator is already executing.\");\n\n        for (; i;) {\n          try {\n            if (r = 1, n && (o = 2 & a[0] ? n.return : a[0] ? n.throw || ((o = n.return) && o.call(n), 0) : n.next) && !(o = o.call(n, a[1])).done) return o;\n\n            switch (n = 0, o && (a = [2 & a[0], o.value]), a[0]) {\n              case 0:\n              case 1:\n                o = a;\n                break;\n\n              case 4:\n                return i.label++, {\n                  value: a[1],\n                  done: !1\n                };\n\n              case 5:\n                i.label++, n = a[1], a = [0];\n                continue;\n\n              case 7:\n                a = i.ops.pop(), i.trys.pop();\n                continue;\n\n              default:\n                if (!(o = (o = i.trys).length > 0 && o[o.length - 1]) && (6 === a[0] || 2 === a[0])) {\n                  i = 0;\n                  continue;\n                }\n\n                if (3 === a[0] && (!o || a[1] > o[0] && a[1] < o[3])) {\n                  i.label = a[1];\n                  break;\n                }\n\n                if (6 === a[0] && i.label < o[1]) {\n                  i.label = o[1], o = a;\n                  break;\n                }\n\n                if (o && i.label < o[2]) {\n                  i.label = o[2], i.ops.push(a);\n                  break;\n                }\n\n                o[2] && i.ops.pop(), i.trys.pop();\n                continue;\n            }\n\n            a = t.call(e, i);\n          } catch (e) {\n            a = [6, e], n = 0;\n          } finally {\n            r = o = 0;\n          }\n        }\n\n        if (5 & a[0]) throw a[1];\n        return {\n          value: a[0] ? a[1] : void 0,\n          done: !0\n        };\n      }([a, s]);\n    };\n  }\n}\n\nvar contexts = {},\n    WEBGL_ATTRIBUTES = {\n  alpha: !1,\n  antialias: !1,\n  premultipliedAlpha: !1,\n  preserveDrawingBuffer: !1,\n  depth: !1,\n  stencil: !1,\n  failIfMajorPerformanceCaveat: !0\n};\n\nfunction getWebGLContext(e) {\n  e in contexts || (document.createElement(\"canvas\").addEventListener(\"webglcontextlost\", function (t) {\n    t.preventDefault(), delete contexts[e];\n  }, !1), contexts[e] = getWebGLRenderingContext(e));\n  var t = contexts[e];\n  return t.isContextLost() ? (delete contexts[e], getWebGLContext(e)) : (t.disable(t.DEPTH_TEST), t.disable(t.STENCIL_TEST), t.disable(t.BLEND), t.disable(t.DITHER), t.disable(t.POLYGON_OFFSET_FILL), t.disable(t.SAMPLE_COVERAGE), t.enable(t.SCISSOR_TEST), t.enable(t.CULL_FACE), t.cullFace(t.BACK), contexts[e]);\n}\n\nfunction getWebGLRenderingContext(e) {\n  if (1 !== e && 2 !== e) throw new Error(\"Cannot get WebGL rendering context, WebGL is disabled.\");\n  var t = document.createElement(\"canvas\");\n  return 1 === e ? t.getContext(\"webgl\", WEBGL_ATTRIBUTES) || t.getContext(\"experimental-webgl\", WEBGL_ATTRIBUTES) : t.getContext(\"webgl2\", WEBGL_ATTRIBUTES);\n}\n\nfunction isMobile() {\n  var e = navigator.userAgent || navigator.vendor || window.opera;\n  return /(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(e.substr(0, 4));\n}\n\nfunction shuffle(e) {\n  for (var t = e.length, r = 0, n = 0; t > 0;) {\n    n = Math.random() * t | 0, r = e[--t], e[t] = e[n], e[n] = r;\n  }\n}\n\nfunction clamp(e, t, r) {\n  return Math.max(e, Math.min(t, r));\n}\n\nfunction nearestLargerEven(e) {\n  return e % 2 == 0 ? e : e + 1;\n}\n\nfunction sum(e) {\n  for (var t = 0, r = 0; r < e.length; r++) {\n    t += e[r];\n  }\n\n  return t;\n}\n\nfunction randUniform(e, t) {\n  var r = Math.random();\n  return t * r + (1 - r) * e;\n}\n\nfunction distSquared(e, t) {\n  for (var r = 0, n = 0; n < e.length; n++) {\n    var o = Number(e[n]) - Number(t[n]);\n    r += o * o;\n  }\n\n  return r;\n}\n\nfunction assert(e, t) {\n  if (!e) throw new Error(\"string\" == typeof t ? t : t());\n}\n\nfunction assertShapesMatch(e, t, r) {\n  void 0 === r && (r = \"\"), assert(arraysEqual(e, t), r + \" Shapes \" + e + \" and \" + t + \" must match\");\n}\n\nfunction assertNonNull(e) {\n  assert(null != e, \"The input to the tensor constructor must be a non-null value.\");\n}\n\nfunction flatten(e, t) {\n  if (void 0 === t && (t = []), Array.isArray(e)) for (var r = 0; r < e.length; ++r) {\n    flatten(e[r], t);\n  } else t.push(e);\n  return t;\n}\n\nfunction sizeFromShape(e) {\n  if (0 === e.length) return 1;\n\n  for (var t = e[0], r = 1; r < e.length; r++) {\n    t *= e[r];\n  }\n\n  return t;\n}\n\nfunction isScalarShape(e) {\n  return 0 === e.length;\n}\n\nfunction arraysEqual(e, t) {\n  if (e === t) return !0;\n  if (null == e || null == t) return !1;\n  if (e.length !== t.length) return !1;\n\n  for (var r = 0; r < e.length; r++) {\n    if (e[r] !== t[r]) return !1;\n  }\n\n  return !0;\n}\n\nfunction isInt(e) {\n  return e % 1 == 0;\n}\n\nfunction tanh(e) {\n  if (null != Math.tanh) return Math.tanh(e);\n  if (e === 1 / 0) return 1;\n  if (e === -1 / 0) return -1;\n  var t = Math.exp(2 * e);\n  return (t - 1) / (t + 1);\n}\n\nfunction sizeToSquarishShape(e) {\n  for (var t = Math.floor(Math.sqrt(e)); t > 1; --t) {\n    if (e % t == 0) return [t, e / t];\n  }\n\n  return [1, e];\n}\n\nfunction createShuffledIndices(e) {\n  for (var t = new Uint32Array(e), r = 0; r < e; ++r) {\n    t[r] = r;\n  }\n\n  return shuffle(t), t;\n}\n\nfunction rightPad(e, t) {\n  return t <= e.length ? e : e + \" \".repeat(t - e.length);\n}\n\nfunction repeatedTry(e, t, r) {\n  return void 0 === t && (t = function t(e) {\n    return 0;\n  }), new Promise(function (n, o) {\n    var a = 0,\n        i = function i() {\n      if (e()) n();else {\n        var s = t(++a);\n        null != r && a >= r ? o() : setTimeout(i, s);\n      }\n    };\n\n    i();\n  });\n}\n\nfunction inferFromImplicitShape(e, t) {\n  for (var r = 1, n = -1, o = 0; o < e.length; ++o) {\n    if (e[o] >= 0) r *= e[o];else if (-1 === e[o]) {\n      if (-1 !== n) throw Error(\"Shapes can only have 1 implicit size. Found -1 at dim \" + n + \" and dim \" + o);\n      n = o;\n    } else if (e[o] < 0) throw Error(\"Shapes can not be < 0. Found \" + e[o] + \" at dim \" + o);\n  }\n\n  if (-1 === n) {\n    if (t > 0 && t !== r) throw Error(\"Size(\" + t + \") must match the product of shape \" + e);\n    return e;\n  }\n\n  if (0 === r) throw Error(\"Cannot infer the missing size in [\" + e + \"] when there are 0 elements\");\n  if (t % r != 0) throw Error(\"The implicit shape can't be a fractional number. Got \" + t + \" / \" + r);\n  var a = e.slice();\n  return a[n] = t / r, a;\n}\n\nfunction squeezeShape(e, t) {\n  for (var r = [], n = [], o = 0, a = 0; a < e.length; ++a) {\n    if (null != t) {\n      if (t[o] === a && 1 !== e[a]) throw new Error(\"Can't squeeze axis \" + a + \" since its dim '\" + e[a] + \"' is not 1\");\n      (null == t[o] || t[o] > a) && 1 === e[a] && (r.push(e[a]), n.push(a)), t[o] <= a && o++;\n    }\n\n    1 !== e[a] && (r.push(e[a]), n.push(a));\n  }\n\n  return {\n    newShape: r,\n    keptDims: n\n  };\n}\n\nfunction getTypedArrayFromDType(e, t) {\n  var r = null;\n  if (null == e || \"float32\" === e) r = new Float32Array(t);else if (\"int32\" === e) r = new Int32Array(t);else {\n    if (\"bool\" !== e) throw new Error(\"Unknown data type \" + e);\n    r = new Uint8Array(t);\n  }\n  return r;\n}\n\nfunction getArrayFromDType(e, t) {\n  var r = null;\n  if (null == e || \"float32\" === e) r = new Float32Array(t);else if (\"int32\" === e) r = new Int32Array(t);else if (\"bool\" === e) r = new Uint8Array(t);else {\n    if (\"string\" !== e) throw new Error(\"Unknown data type \" + e);\n    r = new Array(t);\n  }\n  return r;\n}\n\nfunction checkComputationForNaN(e, t, r) {\n  if (\"float32\" === t) for (var n = 0; n < e.length; n++) {\n    if (isNaN(e[n])) throw Error(\"The result of the '\" + r + \"' has NaNs.\");\n  }\n}\n\nfunction checkConversionForNaN(e, t) {\n  if (\"float32\" !== t) for (var r = 0; r < e.length; r++) {\n    if (isNaN(e[r])) throw Error(\"NaN is not a valid value for dtype: '\" + t + \"'.\");\n  }\n}\n\nfunction hasEncodingLoss(e, t) {\n  return \"complex64\" !== t && (\"float32\" !== t || \"complex64\" === e) && (\"int32\" !== t || \"float32\" === e || \"complex64\" === e) && (\"bool\" !== t || \"bool\" !== e);\n}\n\nfunction isTypedArray(e) {\n  return e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array;\n}\n\nfunction bytesPerElement(e) {\n  if (\"float32\" === e || \"int32\" === e) return 4;\n  if (\"complex64\" === e) return 8;\n  if (\"bool\" === e) return 1;\n  throw new Error(\"Unknown dtype \" + e);\n}\n\nfunction bytesFromStringArray(e) {\n  if (null == e) return 0;\n  var t = 0;\n  return e.forEach(function (e) {\n    return t += 2 * e.length;\n  }), t;\n}\n\nfunction isString(e) {\n  return \"string\" == typeof e || e instanceof String;\n}\n\nfunction isBoolean(e) {\n  return \"boolean\" == typeof e;\n}\n\nfunction isNumber(e) {\n  return \"number\" == typeof e;\n}\n\nfunction inferDtype(e) {\n  return e instanceof Float32Array ? \"float32\" : e instanceof Int32Array || e instanceof Uint8Array ? \"int32\" : isNumber(e) || e instanceof Array && isNumber(getFirstElemFromNestedArray(e)) ? \"float32\" : isString(e) || e instanceof Array && isString(getFirstElemFromNestedArray(e)) ? \"string\" : isBoolean(e) || e instanceof Array && isBoolean(getFirstElemFromNestedArray(e)) ? \"bool\" : \"float32\";\n}\n\nfunction isFunction(e) {\n  return !!(e && e.constructor && e.call && e.apply);\n}\n\nfunction nearestDivisor(e, t) {\n  for (var r = t; r < e; ++r) {\n    if (e % r == 0) return r;\n  }\n\n  return e;\n}\n\nfunction computeStrides(e) {\n  var t = e.length;\n  if (t < 2) return [];\n  var r = new Array(t - 1);\n  r[t - 2] = e[t - 1];\n\n  for (var n = t - 3; n >= 0; --n) {\n    r[n] = r[n + 1] * e[n + 1];\n  }\n\n  return r;\n}\n\nfunction toTypedArray(e, t, r) {\n  if (\"string\" === t) throw new Error(\"Cannot convert a string[] to a TypedArray\");\n  if (noConversionNeeded(e, t)) return e;\n  if (Array.isArray(e) && (e = flatten(e)), null == t || \"float32\" === t || \"complex64\" === t) return new Float32Array(e);\n  if (\"int32\" === t) return r && checkConversionForNaN(e, t), new Int32Array(e);\n\n  if (\"bool\" === t) {\n    for (var n = new Uint8Array(e.length), o = 0; o < n.length; ++o) {\n      0 !== Math.round(e[o]) && (n[o] = 1);\n    }\n\n    return n;\n  }\n\n  throw new Error(\"Unknown data type \" + t);\n}\n\nfunction noConversionNeeded(e, t) {\n  return e instanceof Float32Array && \"float32\" === t || e instanceof Int32Array && \"int32\" === t || e instanceof Uint8Array && \"bool\" === t;\n}\n\nfunction makeOnesTypedArray(e, t) {\n  for (var r = makeZerosTypedArray(e, t), n = 0; n < r.length; n++) {\n    r[n] = 1;\n  }\n\n  return r;\n}\n\nfunction makeZerosTypedArray(e, t) {\n  if (null == t || \"float32\" === t || \"complex64\" === t) return new Float32Array(e);\n  if (\"int32\" === t) return new Int32Array(e);\n  if (\"bool\" === t) return new Uint8Array(e);\n  throw new Error(\"Unknown data type \" + t);\n}\n\nfunction now() {\n  if (\"undefined\" != typeof performance) return performance.now();\n\n  if (\"undefined\" != typeof process) {\n    var e = process.hrtime();\n    return 1e3 * e[0] + e[1] / 1e6;\n  }\n\n  throw new Error(\"Cannot measure time in this environment. You should run tf.js in the browser or in Node.js\");\n}\n\nfunction getFirstElemFromNestedArray(e) {\n  for (; e instanceof Array;) {\n    e = e[0];\n  }\n\n  return e;\n}\n\nvar util = Object.freeze({\n  shuffle: shuffle,\n  clamp: clamp,\n  nearestLargerEven: nearestLargerEven,\n  sum: sum,\n  randUniform: randUniform,\n  distSquared: distSquared,\n  assert: assert,\n  assertShapesMatch: assertShapesMatch,\n  assertNonNull: assertNonNull,\n  flatten: flatten,\n  sizeFromShape: sizeFromShape,\n  isScalarShape: isScalarShape,\n  arraysEqual: arraysEqual,\n  isInt: isInt,\n  tanh: tanh,\n  sizeToSquarishShape: sizeToSquarishShape,\n  createShuffledIndices: createShuffledIndices,\n  rightPad: rightPad,\n  repeatedTry: repeatedTry,\n  inferFromImplicitShape: inferFromImplicitShape,\n  squeezeShape: squeezeShape,\n  getTypedArrayFromDType: getTypedArrayFromDType,\n  getArrayFromDType: getArrayFromDType,\n  checkComputationForNaN: checkComputationForNaN,\n  checkConversionForNaN: checkConversionForNaN,\n  hasEncodingLoss: hasEncodingLoss,\n  isTypedArray: isTypedArray,\n  bytesPerElement: bytesPerElement,\n  bytesFromStringArray: bytesFromStringArray,\n  isString: isString,\n  isBoolean: isBoolean,\n  isNumber: isNumber,\n  inferDtype: inferDtype,\n  isFunction: isFunction,\n  nearestDivisor: nearestDivisor,\n  computeStrides: computeStrides,\n  toTypedArray: toTypedArray,\n  makeOnesTypedArray: makeOnesTypedArray,\n  makeZerosTypedArray: makeZerosTypedArray,\n  now: now\n}),\n    Profiler = function () {\n  function e(e, t) {\n    this.backendTimer = e, this.logger = t, null == t && (this.logger = new Logger());\n  }\n\n  return e.prototype.profileKernel = function (e, t) {\n    var r,\n        n = this,\n        o = this.backendTimer.time(function () {\n      r = t();\n    });\n    return (Array.isArray(r) ? r : [r]).forEach(function (t) {\n      var r = t.dataSync();\n      checkComputationForNaN(r, t.dtype, e), o.then(function (o) {\n        var a = \"\";\n        null != o.getExtraProfileInfo && (a = o.getExtraProfileInfo()), n.logger.logKernelProfile(e, t, r, o.kernelMs, a);\n      });\n    }), r;\n  }, e;\n}(),\n    Logger = function () {\n  function e() {}\n\n  return e.prototype.logKernelProfile = function (e, t, r, n, o) {\n    var a = rightPad(n + \"ms\", 9),\n        i = rightPad(e, 25),\n        s = t.rank,\n        u = t.size,\n        l = rightPad(t.shape.toString(), 14);\n    console.log(\"%c\" + i + \"\\t%c\" + a + \"\\t%c\" + s + \"D \" + l + \"\\t%c\" + u + \"\\t%c\" + o, \"font-weight:bold\", \"color:red\", \"color:blue\", \"color: orange\", \"color: green\");\n  }, e;\n}(),\n    FORMAT_LIMIT_NUM_VALS = 20,\n    FORMAT_NUM_FIRST_LAST_VALS = 3,\n    FORMAT_NUM_SIG_DIGITS = 7;\n\nfunction tensorToString(e, t, r, n) {\n  var o = computeStrides(t),\n      a = computeMaxSizePerColumn(e, t, r, o),\n      i = t.length,\n      s = subTensorToString(e, t, r, o, a),\n      u = [\"Tensor\"];\n  return n && (u.push(\"  dtype: \" + r), u.push(\"  rank: \" + i), u.push(\"  shape: [\" + t + \"]\"), u.push(\"  values:\")), u.push(s.map(function (e) {\n    return \"    \" + e;\n  }).join(\"\\n\")), u.join(\"\\n\");\n}\n\nfunction computeMaxSizePerColumn(e, t, r, n) {\n  var o = sizeFromShape(t),\n      a = n[n.length - 1],\n      i = new Array(a).fill(0),\n      s = t.length,\n      u = \"complex64\" === r ? createComplexTuples(e) : e;\n  if (s > 1) for (var l = 0; l < o / a; l++) {\n    for (var c = l * a, p = 0; p < a; p++) {\n      i[p] = Math.max(i[p], valToString(u[c + p], 0).length);\n    }\n  }\n  return i;\n}\n\nfunction valToString(e, t) {\n  return rightPad(Array.isArray(e) ? parseFloat(e[0].toFixed(FORMAT_NUM_SIG_DIGITS)) + \" + \" + parseFloat(e[1].toFixed(FORMAT_NUM_SIG_DIGITS)) + \"j\" : isString(e) ? \"'\" + e + \"'\" : parseFloat(e.toFixed(FORMAT_NUM_SIG_DIGITS)).toString(), t);\n}\n\nfunction subTensorToString(e, t, r, n, o, a) {\n  void 0 === a && (a = !0);\n  var i = \"complex64\" === r ? 2 : 1,\n      s = t[0],\n      u = t.length;\n  if (0 === u) return \"complex64\" === r ? [valToString(createComplexTuples(e)[0], 0)] : [e[0].toString()];\n\n  if (1 === u) {\n    if (s > FORMAT_LIMIT_NUM_VALS) {\n      var l = FORMAT_NUM_FIRST_LAST_VALS * i,\n          c = Array.from(e.slice(0, l)),\n          p = Array.from(e.slice(s - FORMAT_NUM_FIRST_LAST_VALS * i, s));\n      return \"complex64\" === r && (c = createComplexTuples(c), p = createComplexTuples(p)), [\"[\" + c.map(function (e, t) {\n        return valToString(e, o[t]);\n      }).join(\", \") + \", ..., \" + p.map(function (e, t) {\n        return valToString(e, o[s - FORMAT_NUM_FIRST_LAST_VALS + t]);\n      }).join(\", \") + \"]\"];\n    }\n\n    return [\"[\" + (\"complex64\" === r ? createComplexTuples(e) : Array.from(e)).map(function (e, t) {\n      return valToString(e, o[t]);\n    }).join(\", \") + \"]\"];\n  }\n\n  var d = t.slice(1),\n      h = n.slice(1),\n      f = n[0] * i,\n      m = [];\n\n  if (s > FORMAT_LIMIT_NUM_VALS) {\n    for (var g = 0; g < FORMAT_NUM_FIRST_LAST_VALS; g++) {\n      var v = (y = g * f) + f;\n      m.push.apply(m, subTensorToString(e.slice(y, v), d, r, h, o, !1));\n    }\n\n    m.push(\"...\");\n\n    for (g = s - FORMAT_NUM_FIRST_LAST_VALS; g < s; g++) {\n      v = (y = g * f) + f;\n      m.push.apply(m, subTensorToString(e.slice(y, v), d, r, h, o, g === s - 1));\n    }\n  } else for (g = 0; g < s; g++) {\n    var y;\n    v = (y = g * f) + f;\n    m.push.apply(m, subTensorToString(e.slice(y, v), d, r, h, o, g === s - 1));\n  }\n\n  var x = 2 === u ? \",\" : \"\";\n  m[0] = \"[\" + m[0] + x;\n\n  for (g = 1; g < m.length - 1; g++) {\n    m[g] = \" \" + m[g] + x;\n  }\n\n  var T = \",\\n\";\n\n  for (g = 2; g < u; g++) {\n    T += \"\\n\";\n  }\n\n  return m[m.length - 1] = \" \" + m[m.length - 1] + \"]\" + (a ? \"\" : T), m;\n}\n\nfunction createComplexTuples(e) {\n  for (var t = [], r = 0; r < e.length; r += 2) {\n    t.push([e[r], e[r + 1]]);\n  }\n\n  return t;\n}\n\nvar TensorBuffer = function () {\n  function e(e, t, r) {\n    if (this.dtype = t, this.shape = e.slice(), this.size = sizeFromShape(e), null != r) {\n      var n = r.length;\n      assert(n === this.size, \"Length of values '\" + n + \"' does not match the size inferred by the shape '\" + this.size + \"'.\");\n    }\n\n    if (\"complex64\" === t) throw new Error(\"complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).\");\n    this.values = r || getArrayFromDType(t, sizeFromShape(this.shape)), this.strides = computeStrides(e);\n  }\n\n  return e.prototype.set = function (e) {\n    for (var t = [], r = 1; r < arguments.length; r++) {\n      t[r - 1] = arguments[r];\n    }\n\n    0 === t.length && (t = [0]), assert(t.length === this.rank, \"The number of provided coordinates (\" + t.length + \") must match the rank (\" + this.rank + \")\");\n    var n = this.locToIndex(t);\n    this.values[n] = e;\n  }, e.prototype.get = function () {\n    for (var e = [], t = 0; t < arguments.length; t++) {\n      e[t] = arguments[t];\n    }\n\n    0 === e.length && (e = [0]);\n\n    for (var r = e[e.length - 1], n = 0; n < e.length - 1; ++n) {\n      r += this.strides[n] * e[n];\n    }\n\n    return this.values[r];\n  }, e.prototype.locToIndex = function (e) {\n    if (0 === this.rank) return 0;\n    if (1 === this.rank) return e[0];\n\n    for (var t = e[e.length - 1], r = 0; r < e.length - 1; ++r) {\n      t += this.strides[r] * e[r];\n    }\n\n    return t;\n  }, e.prototype.indexToLoc = function (e) {\n    if (0 === this.rank) return [];\n    if (1 === this.rank) return [e];\n\n    for (var t = new Array(this.shape.length), r = 0; r < t.length - 1; ++r) {\n      t[r] = Math.floor(e / this.strides[r]), e -= t[r] * this.strides[r];\n    }\n\n    return t[t.length - 1] = e, t;\n  }, Object.defineProperty(e.prototype, \"rank\", {\n    get: function get() {\n      return this.shape.length;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), e.prototype.toTensor = function () {\n    return Tensor.make(this.shape, {\n      values: this.values\n    }, this.dtype);\n  }, e;\n}(),\n    trackerFn = null,\n    opHandler = null;\n\nfunction setTensorTracker(e) {\n  trackerFn = e;\n}\n\nfunction setOpHandler(e) {\n  opHandler = e;\n}\n\nvar Tensor = function () {\n  function e(e, t, r, n) {\n    this.isDisposedInternal = !1, this.shape = e.slice(), this.dtype = t || \"float32\", this.size = sizeFromShape(e), null != r && assert(this.size === r.length, \"Based on the provided shape, [\" + e + \"], and dtype \" + this.dtype + \", the tensor should have \" + this.size + \" values but has \" + r.length), this.strides = computeStrides(e), this.dataId = null != n ? n : {}, this.id = trackerFn().nextTensorId(), this.rankType = this.rank < 5 ? this.rank.toString() : \"higher\", trackerFn().registerTensor(this), null != r && trackerFn().write(this.dataId, r);\n  }\n\n  return e.make = function (t, r, n) {\n    return new e(t, n, r.values, r.dataId);\n  }, e.prototype.flatten = function () {\n    return this.throwIfDisposed(), this.as1D();\n  }, e.prototype.asScalar = function () {\n    return this.throwIfDisposed(), assert(1 === this.size, \"The array must have only 1 element.\"), this.reshape([]);\n  }, e.prototype.as1D = function () {\n    return this.throwIfDisposed(), this.reshape([this.size]);\n  }, e.prototype.as2D = function (e, t) {\n    return this.throwIfDisposed(), this.reshape([e, t]);\n  }, e.prototype.as3D = function (e, t, r) {\n    return this.throwIfDisposed(), this.reshape([e, t, r]);\n  }, e.prototype.as4D = function (e, t, r, n) {\n    return this.throwIfDisposed(), this.reshape([e, t, r, n]);\n  }, e.prototype.asType = function (e) {\n    return this.throwIfDisposed(), opHandler.cast(this, e);\n  }, Object.defineProperty(e.prototype, \"rank\", {\n    get: function get() {\n      return this.shape.length;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), e.prototype.get = function () {\n    for (var e = [], t = 0; t < arguments.length; t++) {\n      e[t] = arguments[t];\n    }\n\n    assert(e.length === this.rank, \"Number of coordinates in get() must match the rank of the tensor\"), assert(\"complex64\" !== this.dtype, \"Tensor.get() is not supported for complex64 tensors yet.\"), this.throwIfDisposed(), 0 === e.length && (e = [0]);\n\n    for (var r = e[e.length - 1], n = 0; n < e.length - 1; ++n) {\n      r += this.strides[n] * e[n];\n    }\n\n    return this.dataSync()[r];\n  }, e.prototype.buffer = function () {\n    return opHandler.buffer(this.shape, this.dtype, this.dataSync());\n  }, e.prototype.data = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (e) {\n        return this.throwIfDisposed(), [2, trackerFn().read(this.dataId)];\n      });\n    });\n  }, e.prototype.dataSync = function () {\n    return this.throwIfDisposed(), trackerFn().readSync(this.dataId);\n  }, e.prototype.dispose = function () {\n    this.isDisposed || (trackerFn().disposeTensor(this), this.isDisposedInternal = !0);\n  }, Object.defineProperty(e.prototype, \"isDisposed\", {\n    get: function get() {\n      return this.isDisposedInternal;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), e.prototype.throwIfDisposed = function () {\n    if (this.isDisposed) throw new Error(\"Tensor is disposed.\");\n  }, e.prototype.toFloat = function () {\n    return this.asType(\"float32\");\n  }, e.prototype.toInt = function () {\n    return this.asType(\"int32\");\n  }, e.prototype.toBool = function () {\n    return this.asType(\"bool\");\n  }, e.prototype.print = function (e) {\n    return void 0 === e && (e = !1), opHandler.print(this, e);\n  }, e.prototype.reshape = function (e) {\n    return this.throwIfDisposed(), opHandler.reshape(this, e);\n  }, e.prototype.reshapeAs = function (e) {\n    return this.throwIfDisposed(), this.reshape(e.shape);\n  }, e.prototype.expandDims = function (e) {\n    return void 0 === e && (e = 0), opHandler.expandDims(this, e);\n  }, e.prototype.cumsum = function (e, t, r) {\n    return void 0 === e && (e = 0), void 0 === t && (t = !1), void 0 === r && (r = !1), opHandler.cumsum(this, e, t, r);\n  }, e.prototype.squeeze = function (e) {\n    return this.throwIfDisposed(), opHandler.squeeze(this, e);\n  }, e.prototype.clone = function () {\n    return this.throwIfDisposed(), opHandler.clone(this);\n  }, e.prototype.toString = function (e) {\n    return void 0 === e && (e = !1), tensorToString(this.dataSync(), this.shape, this.dtype, e);\n  }, e.prototype.tile = function (e) {\n    return this.throwIfDisposed(), opHandler.tile(this, e);\n  }, e.prototype.gather = function (e, t) {\n    return void 0 === t && (t = 0), this.throwIfDisposed(), opHandler.gather(this, e, t);\n  }, e.prototype.matMul = function (e, t, r) {\n    return void 0 === t && (t = !1), void 0 === r && (r = !1), this.throwIfDisposed(), opHandler.matMul(this, e, t, r);\n  }, e.prototype.dot = function (e) {\n    return this.throwIfDisposed(), opHandler.dot(this, e);\n  }, e.prototype.norm = function (e, t, r) {\n    return void 0 === e && (e = \"euclidean\"), void 0 === t && (t = null), void 0 === r && (r = !1), this.throwIfDisposed(), opHandler.norm(this, e, t, r);\n  }, e.prototype.slice = function (e, t) {\n    return this.throwIfDisposed(), opHandler.slice(this, e, t);\n  }, e.prototype.reverse = function (e) {\n    return this.throwIfDisposed(), opHandler.reverse(this, e);\n  }, e.prototype.concat = function (t, r) {\n    return void 0 === r && (r = 0), this.throwIfDisposed(), t instanceof e && (t = [t]), opHandler.concat([this].concat(t), r);\n  }, e.prototype.split = function (e, t) {\n    return void 0 === t && (t = 0), this.throwIfDisposed(), opHandler.split(this, e, t);\n  }, e.prototype.stack = function (e, t) {\n    return void 0 === t && (t = 0), opHandler.stack([this, e], t);\n  }, e.prototype.unstack = function (e, t) {\n    return void 0 === t && (t = 0), opHandler.unstack(this, t);\n  }, e.prototype.pad = function (e, t) {\n    return void 0 === t && (t = 0), opHandler.pad(this, e, t);\n  }, e.prototype.batchNormalization = function (e, t, r, n, o) {\n    return void 0 === r && (r = .001), this.throwIfDisposed(), opHandler.batchNormalization(this, e, t, r, n, o);\n  }, e.prototype.all = function (e, t) {\n    return void 0 === e && (e = null), void 0 === t && (t = !1), this.throwIfDisposed(), opHandler.all(this, e, t);\n  }, e.prototype.any = function (e, t) {\n    return void 0 === e && (e = null), void 0 === t && (t = !1), this.throwIfDisposed(), opHandler.any(this, e, t);\n  }, e.prototype.logSumExp = function (e, t) {\n    return void 0 === e && (e = null), void 0 === t && (t = !1), this.throwIfDisposed(), opHandler.logSumExp(this, e, t);\n  }, e.prototype.sum = function (e, t) {\n    return void 0 === e && (e = null), void 0 === t && (t = !1), this.throwIfDisposed(), opHandler.sum(this, e, t);\n  }, e.prototype.prod = function (e, t) {\n    return void 0 === e && (e = null), void 0 === t && (t = !1), this.throwIfDisposed(), opHandler.prod(this, e, t);\n  }, e.prototype.mean = function (e, t) {\n    return void 0 === e && (e = null), void 0 === t && (t = !1), this.throwIfDisposed(), opHandler.mean(this, e, t);\n  }, e.prototype.min = function (e, t) {\n    return void 0 === e && (e = null), void 0 === t && (t = !1), this.throwIfDisposed(), opHandler.min(this, e, t);\n  }, e.prototype.max = function (e, t) {\n    return void 0 === e && (e = null), void 0 === t && (t = !1), this.throwIfDisposed(), opHandler.max(this, e, t);\n  }, e.prototype.argMin = function (e) {\n    return void 0 === e && (e = null), this.throwIfDisposed(), opHandler.argMin(this, e);\n  }, e.prototype.argMax = function (e) {\n    return void 0 === e && (e = null), this.throwIfDisposed(), opHandler.argMax(this, e);\n  }, e.prototype.cast = function (e) {\n    return this.throwIfDisposed(), opHandler.cast(this, e);\n  }, e.prototype.add = function (e) {\n    return this.throwIfDisposed(), opHandler.add(this, e);\n  }, e.prototype.addStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.addStrict(this, e);\n  }, e.prototype.atan2 = function (e) {\n    return this.throwIfDisposed(), opHandler.atan2(this, e);\n  }, e.prototype.sub = function (e) {\n    return this.throwIfDisposed(), opHandler.sub(this, e);\n  }, e.prototype.subStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.subStrict(this, e);\n  }, e.prototype.pow = function (e) {\n    return this.throwIfDisposed(), opHandler.pow(this, e);\n  }, e.prototype.powStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.powStrict(this, e);\n  }, e.prototype.mul = function (e) {\n    return this.throwIfDisposed(), opHandler.mul(this, e);\n  }, e.prototype.mulStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.mulStrict(this, e);\n  }, e.prototype.div = function (e) {\n    return this.throwIfDisposed(), opHandler.div(this, e);\n  }, e.prototype.floorDiv = function (e) {\n    return this.throwIfDisposed(), opHandler.floorDiv(this, e);\n  }, e.prototype.divStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.divStrict(this, e);\n  }, e.prototype.minimum = function (e) {\n    return this.throwIfDisposed(), opHandler.minimum(this, e);\n  }, e.prototype.minimumStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.minimumStrict(this, e);\n  }, e.prototype.maximum = function (e) {\n    return this.throwIfDisposed(), opHandler.maximum(this, e);\n  }, e.prototype.maximumStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.maximumStrict(this, e);\n  }, e.prototype.mod = function (e) {\n    return this.throwIfDisposed(), opHandler.mod(this, e);\n  }, e.prototype.modStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.modStrict(this, e);\n  }, e.prototype.squaredDifference = function (e) {\n    return this.throwIfDisposed(), opHandler.squaredDifference(this, e);\n  }, e.prototype.squaredDifferenceStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.squaredDifferenceStrict(this, e);\n  }, e.prototype.transpose = function (e) {\n    return this.throwIfDisposed(), opHandler.transpose(this, e);\n  }, e.prototype.notEqual = function (e) {\n    return this.throwIfDisposed(), opHandler.notEqual(this, e);\n  }, e.prototype.notEqualStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.notEqualStrict(this, e);\n  }, e.prototype.less = function (e) {\n    return this.throwIfDisposed(), opHandler.less(this, e);\n  }, e.prototype.lessStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.lessStrict(this, e);\n  }, e.prototype.equal = function (e) {\n    return this.throwIfDisposed(), opHandler.equal(this, e);\n  }, e.prototype.equalStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.equalStrict(this, e);\n  }, e.prototype.lessEqual = function (e) {\n    return this.throwIfDisposed(), opHandler.lessEqual(this, e);\n  }, e.prototype.lessEqualStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.lessEqualStrict(this, e);\n  }, e.prototype.greater = function (e) {\n    return this.throwIfDisposed(), opHandler.greater(this, e);\n  }, e.prototype.greaterStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.greaterStrict(this, e);\n  }, e.prototype.greaterEqual = function (e) {\n    return this.throwIfDisposed(), opHandler.greaterEqual(this, e);\n  }, e.prototype.greaterEqualStrict = function (e) {\n    return this.throwIfDisposed(), opHandler.greaterEqualStrict(this, e);\n  }, e.prototype.logicalAnd = function (e) {\n    return this.throwIfDisposed(), opHandler.logicalAnd(this, e);\n  }, e.prototype.logicalOr = function (e) {\n    return this.throwIfDisposed(), opHandler.logicalOr(this, e);\n  }, e.prototype.logicalNot = function () {\n    return this.throwIfDisposed(), opHandler.logicalNot(this);\n  }, e.prototype.logicalXor = function (e) {\n    return this.throwIfDisposed(), opHandler.logicalXor(this, e);\n  }, e.prototype.where = function (e, t) {\n    return this.throwIfDisposed(), opHandler.where(e, this, t);\n  }, e.prototype.neg = function () {\n    return this.throwIfDisposed(), opHandler.neg(this);\n  }, e.prototype.ceil = function () {\n    return this.throwIfDisposed(), opHandler.ceil(this);\n  }, e.prototype.floor = function () {\n    return this.throwIfDisposed(), opHandler.floor(this);\n  }, e.prototype.sign = function () {\n    return this.throwIfDisposed(), opHandler.sign(this);\n  }, e.prototype.exp = function () {\n    return this.throwIfDisposed(), opHandler.exp(this);\n  }, e.prototype.expm1 = function () {\n    return this.throwIfDisposed(), opHandler.expm1(this);\n  }, e.prototype.log = function () {\n    return this.throwIfDisposed(), opHandler.log(this);\n  }, e.prototype.log1p = function () {\n    return this.throwIfDisposed(), opHandler.log1p(this);\n  }, e.prototype.sqrt = function () {\n    return this.throwIfDisposed(), opHandler.sqrt(this);\n  }, e.prototype.rsqrt = function () {\n    return this.throwIfDisposed(), opHandler.rsqrt(this);\n  }, e.prototype.square = function () {\n    return this.throwIfDisposed(), opHandler.square(this);\n  }, e.prototype.reciprocal = function () {\n    return this.throwIfDisposed(), opHandler.reciprocal(this);\n  }, e.prototype.abs = function () {\n    return this.throwIfDisposed(), opHandler.abs(this);\n  }, e.prototype.clipByValue = function (e, t) {\n    return this.throwIfDisposed(), opHandler.clipByValue(this, e, t);\n  }, e.prototype.relu = function () {\n    return this.throwIfDisposed(), opHandler.relu(this);\n  }, e.prototype.elu = function () {\n    return this.throwIfDisposed(), opHandler.elu(this);\n  }, e.prototype.selu = function () {\n    return this.throwIfDisposed(), opHandler.selu(this);\n  }, e.prototype.leakyRelu = function (e) {\n    return void 0 === e && (e = .2), this.throwIfDisposed(), opHandler.leakyRelu(this, e);\n  }, e.prototype.prelu = function (e) {\n    return this.throwIfDisposed(), opHandler.prelu(this, e);\n  }, e.prototype.sigmoid = function () {\n    return this.throwIfDisposed(), opHandler.sigmoid(this);\n  }, e.prototype.logSigmoid = function () {\n    return this.throwIfDisposed(), opHandler.logSigmoid(this);\n  }, e.prototype.softplus = function () {\n    return this.throwIfDisposed(), opHandler.softplus(this);\n  }, e.prototype.zerosLike = function () {\n    return this.throwIfDisposed(), opHandler.zerosLike(this);\n  }, e.prototype.onesLike = function () {\n    return this.throwIfDisposed(), opHandler.onesLike(this);\n  }, e.prototype.sin = function () {\n    return this.throwIfDisposed(), opHandler.sin(this);\n  }, e.prototype.cos = function () {\n    return this.throwIfDisposed(), opHandler.cos(this);\n  }, e.prototype.tan = function () {\n    return this.throwIfDisposed(), opHandler.tan(this);\n  }, e.prototype.asin = function () {\n    return this.throwIfDisposed(), opHandler.asin(this);\n  }, e.prototype.acos = function () {\n    return this.throwIfDisposed(), opHandler.acos(this);\n  }, e.prototype.atan = function () {\n    return this.throwIfDisposed(), opHandler.atan(this);\n  }, e.prototype.sinh = function () {\n    return this.throwIfDisposed(), opHandler.sinh(this);\n  }, e.prototype.cosh = function () {\n    return this.throwIfDisposed(), opHandler.cosh(this);\n  }, e.prototype.tanh = function () {\n    return this.throwIfDisposed(), opHandler.tanh(this);\n  }, e.prototype.asinh = function () {\n    return this.throwIfDisposed(), opHandler.asinh(this);\n  }, e.prototype.acosh = function () {\n    return this.throwIfDisposed(), opHandler.acosh(this);\n  }, e.prototype.atanh = function () {\n    return this.throwIfDisposed(), opHandler.atanh(this);\n  }, e.prototype.erf = function () {\n    return this.throwIfDisposed(), opHandler.erf(this);\n  }, e.prototype.round = function () {\n    return this.throwIfDisposed(), opHandler.round(this);\n  }, e.prototype.step = function (e) {\n    return void 0 === e && (e = 0), this.throwIfDisposed(), opHandler.step(this, e);\n  }, e.prototype.softmax = function (e) {\n    return void 0 === e && (e = -1), this.throwIfDisposed(), opHandler.softmax(this, e);\n  }, e.prototype.logSoftmax = function (e) {\n    return void 0 === e && (e = -1), this.throwIfDisposed(), opHandler.logSoftmax(this, e);\n  }, e.prototype.resizeBilinear = function (e, t) {\n    return void 0 === t && (t = !1), this.throwIfDisposed(), opHandler.image.resizeBilinear(this, e, t);\n  }, e.prototype.resizeNearestNeighbor = function (e, t) {\n    return void 0 === t && (t = !1), this.throwIfDisposed(), opHandler.image.resizeNearestNeighbor(this, e, t);\n  }, e.prototype.conv1d = function (e, t, r, n, o, a) {\n    return void 0 === n && (n = \"NWC\"), void 0 === o && (o = 1), this.throwIfDisposed(), opHandler.conv1d(this, e, t, r, n, o, a);\n  }, e.prototype.conv2d = function (e, t, r, n, o, a) {\n    return void 0 === n && (n = \"NHWC\"), void 0 === o && (o = [1, 1]), this.throwIfDisposed(), opHandler.conv2d(this, e, t, r, n, o, a);\n  }, e.prototype.conv2dTranspose = function (e, t, r, n, o) {\n    return this.throwIfDisposed(), opHandler.conv2dTranspose(this, e, t, r, n, o);\n  }, e.prototype.depthwiseConv2D = function (e, t, r, n, o, a) {\n    return void 0 === n && (n = \"NHWC\"), void 0 === o && (o = [1, 1]), this.throwIfDisposed(), opHandler.depthwiseConv2d(this, e, t, r, n, o, a);\n  }, e.prototype.separableConv2d = function (e, t, r, n, o, a) {\n    return void 0 === o && (o = [1, 1]), void 0 === a && (a = \"NHWC\"), this.throwIfDisposed(), opHandler.separableConv2d(this, e, t, r, n, o, a);\n  }, e.prototype.avgPool = function (e, t, r, n) {\n    return this.throwIfDisposed(), opHandler.avgPool(this, e, t, r, n);\n  }, e.prototype.maxPool = function (e, t, r, n) {\n    return this.throwIfDisposed(), opHandler.maxPool(this, e, t, r, n);\n  }, e.prototype.localResponseNormalization = function (e, t, r, n) {\n    return void 0 === e && (e = 5), void 0 === t && (t = 1), void 0 === r && (r = 1), void 0 === n && (n = .5), opHandler.localResponseNormalization(this, e, t, r, n);\n  }, e.prototype.pool = function (e, t, r, n, o) {\n    return this.throwIfDisposed(), opHandler.pool(this, e, t, r, n, o);\n  }, e.prototype.variable = function (e, t, r) {\n    return void 0 === e && (e = !0), this.throwIfDisposed(), Variable.variable(this, e, t, r);\n  }, e.prototype.unsortedSegmentSum = function (e, t) {\n    return this.throwIfDisposed(), opHandler.unsortedSegmentSum(this, e, t);\n  }, e.prototype.batchToSpaceND = function (e, t) {\n    return this.throwIfDisposed(), opHandler.batchToSpaceND(this, e, t);\n  }, e.prototype.spaceToBatchND = function (e, t) {\n    return this.throwIfDisposed(), opHandler.spaceToBatchND(this, e, t);\n  }, e.prototype.topk = function (e, t) {\n    return void 0 === e && (e = 1), void 0 === t && (t = !0), this.throwIfDisposed(), opHandler.topk(this, e, t);\n  }, e.prototype.stridedSlice = function (e, t, r, n, o) {\n    return void 0 === n && (n = 0), void 0 === o && (o = 0), this.throwIfDisposed(), opHandler.stridedSlice(this, e, t, r, n, o);\n  }, e.prototype.depthToSpace = function (e, t) {\n    return this.throwIfDisposed(), opHandler.depthToSpace(this, e, t);\n  }, e.prototype.fft = function () {\n    return this.throwIfDisposed(), opHandler.spectral.fft(this);\n  }, e.prototype.ifft = function () {\n    return this.throwIfDisposed(), opHandler.spectral.ifft(this);\n  }, e;\n}();\n\nObject.defineProperty(Tensor, Symbol.hasInstance, {\n  value: function value(e) {\n    return !!e && null != e.shape && null != e.dtype;\n  }\n});\n\nvar Variable = function (e) {\n  function t(t, r, n) {\n    void 0 === r && (r = !0);\n    var o = e.call(this, t.shape, t.dtype, null, t.dataId) || this;\n    o.trainable = r, o.name = n, null == o.name && (o.name = trackerFn().nextVariableId().toString());\n\n    try {\n      trackerFn().registerVariable(o);\n    } catch (e) {\n      throw trackerFn().disposeTensor(o), e;\n    }\n\n    return o;\n  }\n\n  return __extends(t, e), t.variable = function (e, r, n, o) {\n    return void 0 === r && (r = !0), null != o && o !== e.dtype && (e = e.asType(o)), new t(e, r, n);\n  }, t.prototype.assign = function (e) {\n    if (e.dtype !== this.dtype) throw new Error(\"dtype of the new value (\" + e.dtype + \") and previous value (\" + this.dtype + \") must match\");\n    if (!arraysEqual(e.shape, this.shape)) throw new Error(\"shape of the new value (\" + e.shape + \") and previous value (\" + this.shape + \") must match\");\n    trackerFn().disposeTensor(this), this.dataId = e.dataId, trackerFn().registerTensor(this);\n  }, t;\n}(Tensor);\n\nObject.defineProperty(Variable, Symbol.hasInstance, {\n  value: function value(e) {\n    return e instanceof Tensor && null != e.assign && e.assign instanceof Function;\n  }\n});\nvar variable = Variable.variable;\n\nfunction getFilteredNodesXToY(e, t, r) {\n  for (var n = {}, o = {}, a = 0; a < t.length; a++) {\n    n[t[a].id] = !0;\n  }\n\n  for (a = 0; a < e.length; a++) {\n    var i = (f = e[a]).inputs;\n\n    for (var s in i) {\n      for (var u = i[s], l = !1, c = 0; c < t.length; c++) {\n        if (n[u.id]) {\n          f.outputs.forEach(function (e) {\n            return n[e.id] = !0;\n          }), l = !0, o[f.id] = !0;\n          break;\n        }\n      }\n\n      if (l) break;\n    }\n  }\n\n  var p = {};\n  p[r.id] = !0;\n  var d = {};\n\n  for (a = e.length - 1; a >= 0; a--) {\n    for (i = (f = e[a]).inputs, c = 0; c < f.outputs.length; c++) {\n      if (p[f.outputs[c].id]) {\n        for (var s in i) {\n          p[i[s].id] = !0, d[f.id] = !0;\n        }\n\n        break;\n      }\n    }\n  }\n\n  var h = [];\n\n  for (a = 0; a < e.length; a++) {\n    var f;\n\n    if (o[(f = e[a]).id] && d[f.id]) {\n      var m = {};\n\n      for (var s in f.inputs) {\n        var g = f.inputs[s];\n        n[g.id] && (m[s] = g);\n      }\n\n      var v = Object.assign({}, f);\n      v.inputs = m, v.outputs = f.outputs, h.push(v);\n    }\n  }\n\n  return h;\n}\n\nfunction backpropagateGradients(e, t) {\n  for (var r = function r(_r) {\n    var n = t[_r],\n        o = [];\n    if (n.outputs.forEach(function (t) {\n      var r = e[t.id];\n      if (null != r) o.push(r);else {\n        var n = Tensor.make(t.shape, {\n          values: makeZerosTypedArray(t.size, t.dtype)\n        }, t.dtype);\n        o.push(n);\n      }\n    }), null == n.gradient) throw new Error(\"Cannot compute gradient: gradient function not found for \" + n.name + \".\");\n    var a = n.gradient(1 === n.outputs.length ? o[0] : o);\n\n    for (var i in n.inputs) {\n      if (!(i in a)) throw new Error(\"Cannot backprop through input \" + i + \". Available gradients found: \" + Object.keys(a) + \".\");\n      var s = a[i]();\n      if (\"float32\" !== s.dtype) throw new Error(\"Error in gradient for op \" + n.name + \". The gradient of input \" + i + \" must have 'float32' dtype, but has '\" + s.dtype + \"'\");\n      var u = n.inputs[i];\n      if (!arraysEqual(s.shape, u.shape)) throw new Error(\"Error in gradient for op \" + n.name + \". The gradient of input '\" + i + \"' has shape '\" + s.shape + \"', which does not match the shape of the input '\" + u.shape + \"'\");\n      if (null == e[u.id]) e[u.id] = s;else {\n        var l = e[u.id];\n        e[u.id] = l.add(s), l.dispose();\n      }\n    }\n  }, n = t.length - 1; n >= 0; n--) {\n    r(n);\n  }\n}\n\nfunction assertTypesMatch(e, t) {\n  assert(e.dtype === t.dtype, \"The dtypes of the first(\" + e.dtype + \") and second(\" + t.dtype + \") input must match\");\n}\n\nfunction isTensorInList(e, t) {\n  for (var r = 0; r < t.length; r++) {\n    if (t[r].id === e.id) return !0;\n  }\n\n  return !1;\n}\n\nfunction getTensorsInContainer(e) {\n  var t = [];\n  return walkTensorContainer(e, t, new Set()), t;\n}\n\nfunction walkTensorContainer(e, t, r) {\n  if (null != e) if (e instanceof Tensor) t.push(e);else if (isIterable(e)) {\n    var n = e;\n\n    for (var o in n) {\n      var a = n[o];\n      r.has(a) || (r.add(a), walkTensorContainer(a, t, r));\n    }\n  }\n}\n\nfunction isIterable(e) {\n  return Array.isArray(e) || \"object\" == typeof e;\n}\n\nvar Type,\n    Engine = function () {\n  function e(e, t, r) {\n    this.backend = e, this.safeMode = t, this.debugMode = r, this.registeredVariables = {}, this.nextTapeNodeId = 0, this.numBytes = 0, this.numTensors = 0, this.numStringTensors = 0, this.numDataBuffers = 0, this.profiling = !1, this.gradientScopeCount = 0, this.customGradientDepth = 0, this.keepTensors = new Set(), this.tensorInfo = new WeakMap(), this.activeScope = {\n      track: [],\n      name: \"default scope\"\n    }, this.scopeStack = [this.activeScope], this.profiler = new Profiler(e), this.activeProfile = {\n      newBytes: 0,\n      newTensors: 0,\n      peakBytes: 0,\n      kernels: [],\n      result: null\n    };\n  }\n\n  return e.prototype.moveData = function (e) {\n    this.write(e, this.readSync(e));\n  }, e.prototype.tidy = function (e, t, r) {\n    var n = this;\n    void 0 === r && (r = !1);\n    var o,\n        a = null;\n\n    if (null == t) {\n      if (\"function\" != typeof e) throw new Error(\"Please provide a function to tidy()\");\n      t = e;\n    } else {\n      if (\"string\" != typeof e && !(e instanceof String)) throw new Error(\"When calling with two arguments, the first argument to tidy() must be a string\");\n      if (\"function\" != typeof t) throw new Error(\"When calling with two arguments, the 2nd argument to tidy() must be a function\");\n      a = e;\n    }\n\n    return this.scopedRun(function () {\n      return n.startScope(a, r);\n    }, function () {\n      return n.endScope(o, r);\n    }, function () {\n      return (o = t()) instanceof Promise && console.error(\"Cannot return a Promise inside of tidy.\"), o;\n    });\n  }, e.prototype.scopedRun = function (e, t, r) {\n    e();\n\n    try {\n      var n = r();\n      return t(), n;\n    } catch (e) {\n      throw t(), e;\n    }\n  }, e.prototype.nextTensorId = function () {\n    return e.nextTensorId++;\n  }, e.prototype.nextVariableId = function () {\n    return e.nextVariableId++;\n  }, e.prototype.runKernel = function (e, t, r) {\n    var n,\n        o = this,\n        a = [],\n        i = function i(e) {\n      return a.push(e), e;\n    },\n        s = this.activeScope.name,\n        u = this.numBytes,\n        l = this.numTensors;\n\n    if (this.scopedRun(function () {\n      return o.customGradientDepth++;\n    }, function () {\n      return o.customGradientDepth--;\n    }, function () {\n      n = o.debugMode() ? o.profiler.profileKernel(s, function () {\n        return e(o.backend, i);\n      }) : e(o.backend, i);\n    }), this.shouldRecord()) {\n      var c = {\n        id: this.nextTapeNodeId++,\n        name: s,\n        inputs: t,\n        outputs: Array.isArray(n) ? n : [n]\n      };\n      null != r && (c.gradient = function (e) {\n        return r(e, a);\n      }), this.activeTape.push(c);\n    }\n\n    return this.profiling && this.activeProfile.kernels.push({\n      name: s,\n      bytesAdded: this.numBytes - u,\n      totalBytesSnapshot: this.numBytes,\n      tensorsAdded: this.numTensors - l,\n      totalTensorsSnapshot: this.numTensors,\n      inputShapes: Object.keys(t).map(function (e) {\n        return t[e].shape;\n      }),\n      outputShape: Array.isArray(n) ? n.map(function (e) {\n        return e.shape;\n      }) : n.shape\n    }), n;\n  }, e.prototype.registerTensor = function (e) {\n    var t = this.tensorInfo.has(e.dataId) ? this.tensorInfo.get(e.dataId).refCount : 0;\n\n    if (this.numTensors++, \"string\" === e.dtype && this.numStringTensors++, 0 === t) {\n      this.numDataBuffers++;\n      var r = 0;\n      \"complex64\" !== e.dtype && \"string\" !== e.dtype && (r = sizeFromShape(e.shape) * bytesPerElement(e.dtype)), this.tensorInfo.set(e.dataId, {\n        backend: this.backend,\n        dtype: e.dtype,\n        shape: e.shape,\n        bytes: r,\n        refCount: 0\n      }), this.numBytes += r, this.backend.register(e.dataId, e.shape, e.dtype);\n    }\n\n    this.tensorInfo.get(e.dataId).refCount++, e instanceof Variable || this.track(e);\n  }, e.prototype.registerVariable = function (e) {\n    if (null != this.registeredVariables[e.name]) throw new Error(\"Variable with name \" + e.name + \" was already registered\");\n    this.registeredVariables[e.name] = e;\n  }, e.prototype.disposeTensor = function (e) {\n    if (this.tensorInfo.has(e.dataId)) {\n      this.keepTensors.has(e.id) && this.keepTensors.delete(e.id), this.numTensors--, \"string\" === e.dtype && this.numStringTensors--;\n      var t = this.tensorInfo.get(e.dataId);\n      t.refCount <= 1 ? (\"complex64\" !== e.dtype && (this.numBytes -= t.bytes), this.numDataBuffers--, t.backend.disposeData(e.dataId), this.tensorInfo.delete(e.dataId)) : this.tensorInfo.get(e.dataId).refCount--;\n    }\n  }, e.prototype.disposeVariables = function () {\n    for (var e in this.registeredVariables) {\n      var t = this.registeredVariables[e];\n      this.disposeTensor(t), delete this.registeredVariables[e];\n    }\n  }, e.prototype.memory = function () {\n    var e = this.backend.memory();\n    return e.numTensors = this.numTensors, e.numDataBuffers = this.numDataBuffers, e.numBytes = this.numBytes, this.numStringTensors > 0 && (e.unreliable = !0, null == e.reasons && (e.reasons = []), e.reasons.push(\"Memory usage by string tensors is approximate (2 bytes per character)\")), e;\n  }, e.prototype.profile = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t, r;\n      return __generator(this, function (n) {\n        return this.profiling = !0, t = this.numBytes, r = this.numTensors, this.activeProfile.kernels = [], this.activeProfile.result = e(), this.profiling = !1, this.activeProfile.peakBytes = Math.max.apply(Math, this.activeProfile.kernels.map(function (e) {\n          return e.totalBytesSnapshot;\n        })), this.activeProfile.newBytes = this.numBytes - t, this.activeProfile.newTensors = this.numTensors - r, [2, this.activeProfile];\n      });\n    });\n  }, e.prototype.shouldRecord = function () {\n    return null != this.activeTape && 0 === this.customGradientDepth;\n  }, e.prototype.addTapeNode = function (e, t, r) {\n    var n = {};\n    e.forEach(function (e, t) {\n      n[t] = e;\n    });\n    var o = {\n      id: this.nextTapeNodeId++,\n      name: this.activeScope.name,\n      inputs: n,\n      outputs: [t],\n      gradient: function gradient(e) {\n        var t = {};\n        return r(e).forEach(function (e, r) {\n          t[r] = function () {\n            return e;\n          };\n        }), t;\n      }\n    };\n    this.activeTape.push(o);\n  }, e.prototype.keep = function (e) {\n    if (1 === this.scopeStack.length && this.safeMode) throw new Error(\"Safe mode is ON. Enclose all tensor operations inside tf.tidy(): tf.tidy(() => {...}) to avoid memory leaks.\");\n    return this.keepTensors.add(e.id), e;\n  }, e.prototype.startScope = function (e, t) {\n    void 0 === t && (t = !1), t && 0 === this.gradientScopeCount && (this.activeTape = []), t && this.gradientScopeCount++;\n    var r = {\n      track: [],\n      name: \"unnamed scope\"\n    };\n    e && (r.name = e), this.scopeStack.push(r), this.activeScope = r;\n  }, e.prototype.endScope = function (e, t) {\n    var r = this;\n    void 0 === t && (t = !1), t && (this.gradientScopeCount--, 0 === this.gradientScopeCount && (this.activeTape = null));\n    var n = new Set(this.keepTensors),\n        o = getTensorsInContainer(e);\n    o.forEach(function (e) {\n      return n.add(e.id);\n    });\n\n    for (var a = 0; a < this.activeScope.track.length; a++) {\n      var i = this.activeScope.track[a];\n      n.has(i.id) || (null != this.activeTape ? o.push(i) : i.dispose());\n    }\n\n    var s = this.scopeStack.pop();\n    this.activeScope = 0 === this.scopeStack.length ? {\n      track: [],\n      name: \"default scope\"\n    } : this.scopeStack[this.scopeStack.length - 1], o.forEach(function (e) {\n      !r.keepTensors.has(e.id) && isTensorInList(e, s.track) && r.track(e);\n    });\n  }, e.prototype.gradients = function (e, t, r, n) {\n    var o = this;\n    if (void 0 === n && (n = !1), assert(t.length > 0, \"gradients() received an empty list of xs.\"), null != r && \"float32\" !== r.dtype) throw new Error(\"dy must have 'float32' dtype, but has '\" + r.dtype + \"'\");\n    return this.tidy(\"gradients\", function () {\n      var a = e();\n      assert(a instanceof Tensor, \"The result y returned by f() must be a tensor.\");\n      var i = getFilteredNodesXToY(o.activeTape, t, a);\n      if (!n && 0 === i.length && t.length > 0) throw new Error(\"Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.\");\n      var s = {};\n      return s[a.id] = null == r ? ones(a.shape) : r, backpropagateGradients(s, i), {\n        value: a,\n        grads: t.map(function (e) {\n          return s[e.id];\n        })\n      };\n    }, !0);\n  }, e.prototype.customGrad = function (e) {\n    var t = this;\n    return assert(isFunction(e), \"The f passed in customGrad(f) must be a function.\"), function () {\n      for (var r, n, o = [], a = 0; a < arguments.length; a++) {\n        o[a] = arguments[a];\n      }\n\n      if (assert(o.every(function (e) {\n        return e instanceof Tensor;\n      }), \"The args passed in customGrad(f)(x1, x2,...) must all be tensors\"), t.scopedRun(function () {\n        return t.customGradientDepth++;\n      }, function () {\n        return t.customGradientDepth--;\n      }, function () {\n        n = t.tidy(e.name, function () {\n          var t = e.apply(void 0, o),\n              n = t.value,\n              a = t.gradFunc;\n          return assert(n instanceof Tensor, \"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor\"), assert(isFunction(a), \"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.\"), r = a, n;\n        }, !0);\n      }), t.shouldRecord()) {\n        t.addTapeNode(o, n, function (e) {\n          var t = r(e),\n              n = Array.isArray(t) ? t : [t];\n          return assert(n.length === o.length, \"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).\"), assert(n.every(function (e) {\n            return e instanceof Tensor;\n          }), \"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.\"), n;\n        });\n      }\n\n      return n;\n    };\n  }, e.prototype.write = function (e, t) {\n    var r = this.tensorInfo.get(e);\n\n    if (\"string\" === r.dtype) {\n      var n = bytesFromStringArray(t);\n      this.numBytes += n - r.bytes, r.bytes = n;\n    }\n\n    this.backend !== r.backend && (r.backend.disposeData(e), r.backend = this.backend, this.backend.register(e, r.shape, r.dtype)), this.backend.write(e, t);\n  }, e.prototype.readSync = function (e) {\n    return this.tensorInfo.get(e).backend.readSync(e);\n  }, e.prototype.read = function (e) {\n    return this.tensorInfo.get(e).backend.read(e);\n  }, e.prototype.fromPixels = function (e, t) {\n    return this.backend.fromPixels(e, t);\n  }, e.prototype.time = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t, r;\n      return __generator(this, function (n) {\n        switch (n.label) {\n          case 0:\n            return t = now(), [4, this.backend.time(e)];\n\n          case 1:\n            return (r = n.sent()).wallMs = now() - t, [2, r];\n        }\n      });\n    });\n  }, e.prototype.track = function (e) {\n    if (1 === this.scopeStack.length && this.safeMode) throw new Error(\"Safe mode is ON. Enclose all tensor operations inside tf.tidy(): tf.tidy(() => {op();...}); to avoid memory leaks.\");\n    return this.activeScope.track.push(e), e;\n  }, e.nextTensorId = 0, e.nextVariableId = 0, e;\n}();\n\nfunction ones(e) {\n  var t = makeOnesTypedArray(sizeFromShape(e), \"float32\");\n  return Tensor.make(e, {\n    values: t\n  });\n}\n\n!function (e) {\n  e[e.NUMBER = 0] = \"NUMBER\", e[e.BOOLEAN = 1] = \"BOOLEAN\", e[e.STRING = 2] = \"STRING\";\n}(Type || (Type = {}));\nvar MAX_TEXTURE_SIZE,\n    URL_PROPERTIES = [{\n  name: \"DEBUG\",\n  type: Type.BOOLEAN\n}, {\n  name: \"IS_BROWSER\",\n  type: Type.BOOLEAN\n}, {\n  name: \"WEBGL_LAZILY_UNPACK\",\n  type: Type.BOOLEAN\n}, {\n  name: \"WEBGL_CPU_FORWARD\",\n  type: Type.BOOLEAN\n}, {\n  name: \"WEBGL_PACK_BATCHNORMALIZATION\",\n  type: Type.BOOLEAN\n}, {\n  name: \"WEBGL_CONV_IM2COL\",\n  type: Type.BOOLEAN\n}, {\n  name: \"WEBGL_MAX_TEXTURE_SIZE\",\n  type: Type.NUMBER\n}, {\n  name: \"WEBGL_PAGING_ENABLED\",\n  type: Type.BOOLEAN\n}, {\n  name: \"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\",\n  type: Type.NUMBER\n}, {\n  name: \"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\",\n  type: Type.BOOLEAN\n}, {\n  name: \"WEBGL_VERSION\",\n  type: Type.NUMBER\n}, {\n  name: \"WEBGL_RENDER_FLOAT32_ENABLED\",\n  type: Type.BOOLEAN\n}, {\n  name: \"WEBGL_DOWNLOAD_FLOAT_ENABLED\",\n  type: Type.BOOLEAN\n}, {\n  name: \"WEBGL_FENCE_API_ENABLED\",\n  type: Type.BOOLEAN\n}, {\n  name: \"WEBGL_SIZE_UPLOAD_UNIFORM\",\n  type: Type.NUMBER\n}, {\n  name: \"BACKEND\",\n  type: Type.STRING\n}, {\n  name: \"EPSILON\",\n  type: Type.NUMBER\n}, {\n  name: \"PROD\",\n  type: Type.BOOLEAN\n}, {\n  name: \"TENSORLIKE_CHECK_SHAPE_CONSISTENCY\",\n  type: Type.BOOLEAN\n}];\n\nfunction isWebGLVersionEnabled(e) {\n  try {\n    if (null != getWebGLContext(e)) return !0;\n  } catch (e) {\n    return !1;\n  }\n\n  return !1;\n}\n\nfunction getWebGLMaxTextureSize(e) {\n  if (null == MAX_TEXTURE_SIZE) {\n    var t = getWebGLContext(e);\n    MAX_TEXTURE_SIZE = t.getParameter(t.MAX_TEXTURE_SIZE);\n  }\n\n  return MAX_TEXTURE_SIZE;\n}\n\nfunction getWebGLDisjointQueryTimerVersion(e) {\n  if (0 === e) return 0;\n  var t = getWebGLContext(e);\n  return hasExtension(t, \"EXT_disjoint_timer_query_webgl2\") && 2 === e ? 2 : hasExtension(t, \"EXT_disjoint_timer_query\") ? 1 : 0;\n}\n\nfunction isRenderToFloatTextureEnabled(e) {\n  if (0 === e) return !1;\n  var t = getWebGLContext(e);\n\n  if (1 === e) {\n    if (!hasExtension(t, \"OES_texture_float\")) return !1;\n  } else if (!hasExtension(t, \"EXT_color_buffer_float\")) return !1;\n\n  return createFloatTextureAndBindToFramebuffer(t, e);\n}\n\nfunction isDownloadFloatTextureEnabled(e) {\n  if (0 === e) return !1;\n  var t = getWebGLContext(e);\n\n  if (1 === e) {\n    if (!hasExtension(t, \"OES_texture_float\")) return !1;\n    if (!hasExtension(t, \"WEBGL_color_buffer_float\")) return !1;\n  } else if (!hasExtension(t, \"EXT_color_buffer_float\")) return !1;\n\n  return createFloatTextureAndBindToFramebuffer(t, e);\n}\n\nfunction isWebGLFenceEnabled(e) {\n  return 2 === e && null != getWebGLContext(e).fenceSync;\n}\n\nfunction isChrome() {\n  return \"undefined\" != typeof navigator && null != navigator && null != navigator.userAgent && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);\n}\n\nvar TENSORFLOWJS_FLAGS_PREFIX = \"tfjsflags\";\n\nfunction getFeaturesFromURL() {\n  var e = {};\n  if (\"undefined\" == typeof window || void 0 === window.location || void 0 === window.location.search) return e;\n  var t = getQueryParams(window.location.search);\n\n  if (TENSORFLOWJS_FLAGS_PREFIX in t) {\n    var r = {};\n    t[TENSORFLOWJS_FLAGS_PREFIX].split(\",\").forEach(function (e) {\n      var t = e.split(\":\"),\n          n = t[0],\n          o = t[1];\n      r[n] = o;\n    }), URL_PROPERTIES.forEach(function (t) {\n      t.name in r && (console.log(\"Setting feature override from URL \" + t.name + \": \" + r[t.name]), t.type === Type.NUMBER ? e[t.name] = +r[t.name] : t.type === Type.BOOLEAN ? e[t.name] = \"true\" === r[t.name] : t.type === Type.STRING ? e[t.name] = r[t.name] : console.warn(\"Unknown URL param: \" + t.name + \".\"));\n    });\n  }\n\n  return e;\n}\n\nfunction hasExtension(e, t) {\n  return null != e.getExtension(t);\n}\n\nfunction createFloatTextureAndBindToFramebuffer(e, t) {\n  var r = e.createFramebuffer(),\n      n = e.createTexture();\n  e.bindTexture(e.TEXTURE_2D, n);\n  var o = 2 === t ? e.RGBA32F : e.RGBA;\n  e.texImage2D(e.TEXTURE_2D, 0, o, 1, 1, 0, e.RGBA, e.FLOAT, null), e.bindFramebuffer(e.FRAMEBUFFER, r), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, n, 0);\n  var a = e.checkFramebufferStatus(e.FRAMEBUFFER) === e.FRAMEBUFFER_COMPLETE;\n  return e.bindTexture(e.TEXTURE_2D, null), e.bindFramebuffer(e.FRAMEBUFFER, null), e.deleteTexture(n), e.deleteFramebuffer(r), a;\n}\n\nfunction getQueryParams(e) {\n  var t = {};\n  return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (e) {\n    for (var r = [], n = 1; n < arguments.length; n++) {\n      r[n - 1] = arguments[n];\n    }\n\n    return decodeParam(t, r[0], r[1]), r.join(\"=\");\n  }), t;\n}\n\nfunction decodeParam(e, t, r) {\n  e[decodeURIComponent(t)] = decodeURIComponent(r || \"\");\n}\n\nvar EPSILON_FLOAT16 = 1e-4,\n    TEST_EPSILON_FLOAT16 = .1,\n    EPSILON_FLOAT32 = 1e-7,\n    TEST_EPSILON_FLOAT32 = .001,\n    Environment = function () {\n  function e(e) {\n    this.features = {}, this.registry = {}, null != e && (this.features = e), this.get(\"DEBUG\") && console.warn(\"Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.\");\n  }\n\n  return e.setBackend = function (e, t) {\n    if (void 0 === t && (t = !1), !(e in ENV.registry)) throw new Error(\"Backend name '\" + e + \"' not found in registry\");\n    ENV.engine.backend = ENV.findBackend(e), ENV.backendName = e;\n  }, e.getBackend = function () {\n    return ENV.initEngine(), ENV.backendName;\n  }, e.disposeVariables = function () {\n    ENV.engine.disposeVariables();\n  }, e.memory = function () {\n    return ENV.engine.memory();\n  }, e.profile = function (e) {\n    return ENV.engine.profile(e);\n  }, e.tidy = function (e, t) {\n    return ENV.engine.tidy(e, t);\n  }, e.dispose = function (e) {\n    getTensorsInContainer(e).forEach(function (e) {\n      return e.dispose();\n    });\n  }, e.keep = function (e) {\n    return ENV.engine.keep(e);\n  }, e.time = function (e) {\n    return ENV.engine.time(e);\n  }, e.prototype.get = function (e) {\n    return e in this.features ? this.features[e] : (this.features[e] = this.evaluateFeature(e), this.features[e]);\n  }, e.prototype.getFeatures = function () {\n    return this.features;\n  }, e.prototype.set = function (e, t) {\n    this.features[e] = t;\n  }, e.prototype.getBestBackendName = function () {\n    var e = this;\n    if (0 === Object.keys(this.registry).length) throw new Error(\"No backend found in registry.\");\n    return Object.keys(this.registry).map(function (t) {\n      return {\n        name: t,\n        entry: e.registry[t]\n      };\n    }).sort(function (e, t) {\n      return t.entry.priority - e.entry.priority;\n    })[0].name;\n  }, e.prototype.evaluateFeature = function (e) {\n    if (\"DEBUG\" === e) return !1;\n    if (\"IS_BROWSER\" === e) return \"undefined\" != typeof window;\n    if (\"IS_NODE\" === e) return \"undefined\" != typeof process && void 0 !== process.versions && void 0 !== process.versions.node;\n    if (\"IS_CHROME\" === e) return isChrome();\n    if (\"WEBGL_CPU_FORWARD\" === e) return !0;\n    if (\"WEBGL_PACK_BATCHNORMALIZATION\" === e) return !1;\n    if (\"WEBGL_LAZILY_UNPACK\" === e) return !1;\n    if (\"WEBGL_CONV_IM2COL\" === e) return !1;\n    if (\"WEBGL_PAGING_ENABLED\" === e) return this.get(\"IS_BROWSER\") && !this.get(\"PROD\");\n    if (\"WEBGL_MAX_TEXTURE_SIZE\" === e) return getWebGLMaxTextureSize(this.get(\"WEBGL_VERSION\"));\n    if (\"IS_TEST\" === e) return !1;\n    if (\"BACKEND\" === e) return this.getBestBackendName();\n\n    if (\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\" === e) {\n      var t = this.get(\"WEBGL_VERSION\");\n      return 0 === t ? 0 : getWebGLDisjointQueryTimerVersion(t);\n    }\n\n    if (\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE\" === e) return this.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") > 0 && !isMobile();\n    if (\"HAS_WEBGL\" === e) return this.get(\"WEBGL_VERSION\") > 0;\n    if (\"WEBGL_VERSION\" === e) return isWebGLVersionEnabled(2) ? 2 : isWebGLVersionEnabled(1) ? 1 : 0;\n    if (\"WEBGL_RENDER_FLOAT32_ENABLED\" === e) return isRenderToFloatTextureEnabled(this.get(\"WEBGL_VERSION\"));\n    if (\"WEBGL_DOWNLOAD_FLOAT_ENABLED\" === e) return isDownloadFloatTextureEnabled(this.get(\"WEBGL_VERSION\"));\n    if (\"WEBGL_FENCE_API_ENABLED\" === e) return isWebGLFenceEnabled(this.get(\"WEBGL_VERSION\"));\n    if (\"WEBGL_SIZE_UPLOAD_UNIFORM\" === e) return this.get(\"WEBGL_RENDER_FLOAT32_ENABLED\") ? 4 : 0;\n    if (\"TEST_EPSILON\" === e) return 32 === this.backend.floatPrecision() ? TEST_EPSILON_FLOAT32 : TEST_EPSILON_FLOAT16;\n    if (\"EPSILON\" === e) return 32 === this.backend.floatPrecision() ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n    if (\"PROD\" === e) return !1;\n    if (\"TENSORLIKE_CHECK_SHAPE_CONSISTENCY\" === e) return !this.get(\"PROD\");\n    throw new Error(\"Unknown feature \" + e + \".\");\n  }, e.prototype.setFeatures = function (e) {\n    this.features = Object.assign({}, e);\n  }, e.prototype.reset = function () {\n    this.features = getFeaturesFromURL(), null != this.globalEngine && (this.globalEngine = null);\n  }, Object.defineProperty(e.prototype, \"backend\", {\n    get: function get() {\n      return this.engine.backend;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), e.prototype.findBackend = function (e) {\n    return e in this.registry ? this.registry[e].backend : null;\n  }, e.prototype.registerBackend = function (e, t, r, n) {\n    var o = this;\n    if (void 0 === r && (r = 1), e in this.registry) return console.warn(e + \" backend was already registered. Reusing existing backend\"), null != n && n(function () {\n      return o.engine;\n    }), !1;\n\n    try {\n      var a = t();\n      return a.setDataMover({\n        moveData: function moveData(e) {\n          return o.engine.moveData(e);\n        }\n      }), this.registry[e] = {\n        backend: a,\n        priority: r\n      }, !0;\n    } catch (t) {\n      return console.warn(\"Registration of backend \" + e + \" failed\"), console.warn(t.stack || t.message), !1;\n    }\n  }, e.prototype.removeBackend = function (e) {\n    if (!(e in this.registry)) throw new Error(e + \" backend not found in registry\");\n    this.registry[e].backend.dispose(), delete this.registry[e];\n  }, Object.defineProperty(e.prototype, \"engine\", {\n    get: function get() {\n      return this.initEngine(), this.globalEngine;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), e.prototype.initEngine = function () {\n    var e = this;\n\n    if (null == this.globalEngine) {\n      this.backendName = this.get(\"BACKEND\");\n      var t = this.findBackend(this.backendName);\n      this.globalEngine = new Engine(t, !1, function () {\n        return e.get(\"DEBUG\");\n      });\n    }\n  }, e;\n}();\n\nfunction getGlobalNamespace() {\n  var e;\n  if (\"undefined\" != typeof window) e = window;else {\n    if (\"undefined\" == typeof process) throw new Error(\"Could not find a global object\");\n    e = process;\n  }\n  return e;\n}\n\nfunction getOrMakeEnvironment() {\n  var e = getGlobalNamespace();\n  return null == e.ENV && (e.ENV = new Environment(getFeaturesFromURL()), setTensorTracker(function () {\n    return e.ENV.engine;\n  })), e.ENV;\n}\n\nvar ENV = getOrMakeEnvironment(),\n    environment = Object.freeze({\n  EPSILON_FLOAT16: EPSILON_FLOAT16,\n  EPSILON_FLOAT32: EPSILON_FLOAT32,\n  Environment: Environment,\n  ENV: ENV\n});\n\nfunction grad(e) {\n  return assert(isFunction(e), \"The f passed in grad(f) must be a function\"), function (t, r) {\n    return assert(t instanceof Tensor, \"The x passed in grad(f)(x) must be a tensor\"), assert(null == r || r instanceof Tensor, \"The dy passed in grad(f)(x, dy) must be a tensor\"), ENV.engine.tidy(function () {\n      var n = ENV.engine.gradients(function () {\n        return e(t);\n      }, [t], r),\n          o = n.value,\n          a = n.grads;\n      return null != r && assertShapesMatch(o.shape, r.shape, \"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)\"), checkGrads(a), a[0];\n    });\n  };\n}\n\nfunction grads(e) {\n  return assert(isFunction(e), \"The f passed in grads(f) must be a function\"), function (t, r) {\n    return assert(Array.isArray(t) && t.every(function (e) {\n      return e instanceof Tensor;\n    }), \"The args passed in grads(f)(args) must be an array of tensors\"), assert(null == r || r instanceof Tensor, \"The dy passed in grads(f)(args, dy) must be a tensor\"), ENV.engine.tidy(function () {\n      var n = ENV.engine.gradients(function () {\n        return e.apply(void 0, t);\n      }, t, r),\n          o = n.value,\n          a = n.grads;\n      return null != r && assertShapesMatch(o.shape, r.shape, \"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])\"), checkGrads(a), a;\n    });\n  };\n}\n\nfunction valueAndGrad(e) {\n  return assert(isFunction(e), \"The f passed in valueAndGrad(f) must be a function\"), function (t, r) {\n    assert(t instanceof Tensor, \"The x passed in valueAndGrad(f)(x) must be a tensor\"), assert(null == r || r instanceof Tensor, \"The dy passed in valueAndGrad(f)(x, dy) must be a tensor\");\n    var n = ENV.engine.gradients(function () {\n      return e(t);\n    }, [t], r),\n        o = n.grads,\n        a = n.value;\n    return checkGrads(o), {\n      grad: o[0],\n      value: a\n    };\n  };\n}\n\nfunction valueAndGrads(e) {\n  return assert(isFunction(e), \"The f passed in valueAndGrads(f) must be a function\"), function (t, r) {\n    assert(Array.isArray(t) && t.every(function (e) {\n      return e instanceof Tensor;\n    }), \"The args passed in valueAndGrads(f)(args) must be array of tensors\"), assert(null == r || r instanceof Tensor, \"The dy passed in valueAndGrads(f)(args, dy) must be a tensor\");\n    var n = ENV.engine.gradients(function () {\n      return e.apply(void 0, t);\n    }, t, r);\n    return null != r && assertShapesMatch(n.value.shape, r.shape, \"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])\"), checkGrads(n.grads), n;\n  };\n}\n\nfunction variableGrads(e, t) {\n  if (assert(isFunction(e), \"The f passed in variableGrads(f) must be a function\"), assert(null == t || Array.isArray(t) && t.every(function (e) {\n    return e instanceof Variable;\n  }), \"The varList passed in variableGrads(f, varList) must be an array of variables\"), null == t) for (var r in t = [], ENV.engine.registeredVariables) {\n    t.push(ENV.engine.registeredVariables[r]);\n  }\n  var n = t.length;\n  assert((t = t.filter(function (e) {\n    return e.trainable;\n  })).length > 0, \"variableGrads() expects at least one of the input variables to be trainable, but none of the \" + n + \" variables is trainable.\");\n  var o = ENV.engine.gradients(e, t, null, !0),\n      a = o.value,\n      i = o.grads;\n  assert(i.some(function (e) {\n    return null != e;\n  }), \"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().\"), assert(0 === a.rank, \"The f passed in variableGrads(f) must return a scalar, but it returned a rank-\" + a.rank + \" tensor\");\n  var s = {};\n  return t.forEach(function (e, t) {\n    null != i[t] && (s[e.name] = i[t]);\n  }), {\n    value: a,\n    grads: s\n  };\n}\n\nfunction customGrad(e) {\n  return ENV.engine.customGrad(e);\n}\n\nfunction checkGrads(e) {\n  if (e.filter(function (e) {\n    return null == e;\n  }).length > 0) throw new Error(\"Cannot compute gradient of y=f(x) with respect to x. Make sure that\\n    the f you passed encloses all operations that lead from x to y.\");\n}\n\nvar tidy = Environment.tidy,\n    keep = Environment.keep,\n    dispose = Environment.dispose,\n    time = Environment.time,\n    profile = Environment.profile;\n\nfunction warn() {\n  for (var e = [], t = 0; t < arguments.length; t++) {\n    e[t] = arguments[t];\n  }\n\n  ENV.get(\"IS_TEST\") || console.warn.apply(console, e);\n}\n\nfunction getReshaped(e, t, r, n) {\n  void 0 === n && (n = !0);\n  var o = [];\n  if (n) (o = o.concat(t.slice(0))).push(e[0] / r), o = o.concat(e.slice(1));else {\n    o = o.concat(e[0]);\n\n    for (var a = t.length, i = 0; i < a; ++i) {\n      o = o.concat([e[i + 1] / t[i], t[i]]);\n    }\n\n    o = o.concat(e.slice(a + 1));\n  }\n  return o;\n}\n\nfunction getPermuted(e, t, r) {\n  void 0 === r && (r = !0);\n  var n = [];\n\n  if (r) {\n    n.push(t);\n\n    for (var o = t + 1; o < e; ++o) {\n      o <= 2 * t ? (n.push(o), n.push(o - (t + 1))) : n.push(o);\n    }\n  } else {\n    var a = [],\n        i = [];\n\n    for (o = 1; o < e; ++o) {\n      o >= 2 * t + 1 || o % 2 == 1 ? i.push(o) : a.push(o);\n    }\n\n    n.push.apply(n, a), n.push(0), n.push.apply(n, i);\n  }\n\n  return n;\n}\n\nfunction getReshapedPermuted(e, t, r, n) {\n  void 0 === n && (n = !0);\n  var o = [];\n  n ? o.push(e[0] / r) : o.push(e[0] * r);\n\n  for (var a = 1; a < e.length; ++a) {\n    a <= t.length ? n ? o.push(t[a - 1] * e[a]) : o.push(e[a] / t[a - 1]) : o.push(e[a]);\n  }\n\n  return o;\n}\n\nfunction getSliceBeginCoords(e, t) {\n  for (var r = [0], n = 0; n < t; ++n) {\n    r.push(e[n][0]);\n  }\n\n  return r;\n}\n\nfunction getSliceSize(e, t, r) {\n  for (var n = e.slice(0, 1), o = 0; o < r; ++o) {\n    n.push(e[o + 1] - t[o][0] - t[o][1]);\n  }\n\n  return n;\n}\n\nfunction axesAreInnerMostDims(e, t) {\n  for (var r = 0; r < e.length; ++r) {\n    if (e[e.length - r - 1] !== t - 1 - r) return !1;\n  }\n\n  return !0;\n}\n\nfunction combineLocations(e, t, r) {\n  for (var n = e.length + t.length, o = [], a = 0, i = 0, s = 0; s < n; s++) {\n    -1 === r.indexOf(s) ? o.push(e[a++]) : o.push(t[i++]);\n  }\n\n  return o;\n}\n\nfunction computeOutAndReduceShapes(e, t) {\n  for (var r = [], n = e.length, o = 0; o < n; o++) {\n    -1 === t.indexOf(o) && r.push(e[o]);\n  }\n\n  return [r, t.map(function (t) {\n    return e[t];\n  })];\n}\n\nfunction expandShapeToKeepDim(e, t) {\n  return combineLocations(e, t.map(function (e) {\n    return 1;\n  }), t);\n}\n\nfunction parseAxisParam(e, t) {\n  var r = t.length;\n  return assert((e = null == e ? t.map(function (e, t) {\n    return t;\n  }) : [].concat(e)).every(function (e) {\n    return e >= -r && e < r;\n  }), \"All values in axis param must be in range [-\" + r + \", \" + r + \") but got axis \" + e), assert(e.every(function (e) {\n    return isInt(e);\n  }), \"All values in axis param must be integers but got axis \" + e), e.map(function (e) {\n    return e < 0 ? r + e : e;\n  });\n}\n\nfunction assertAxesAreInnerMostDims(e, t, r) {\n  assert(axesAreInnerMostDims(t, r), e + \" supports only inner-most axes for now. Got axes \" + t + \" and rank-\" + r + \" input.\");\n}\n\nfunction getAxesPermutation(e, t) {\n  if (axesAreInnerMostDims(e, t)) return null;\n\n  for (var r = [], n = 0; n < t; ++n) {\n    -1 === e.indexOf(n) && r.push(n);\n  }\n\n  return e.forEach(function (e) {\n    return r.push(e);\n  }), r;\n}\n\nfunction getUndoAxesPermutation(e) {\n  return e.map(function (e, t) {\n    return [t, e];\n  }).sort(function (e, t) {\n    return e[1] - t[1];\n  }).map(function (e) {\n    return e[0];\n  });\n}\n\nfunction getInnerMostAxes(e, t) {\n  for (var r = [], n = t - e; n < t; ++n) {\n    r.push(n);\n  }\n\n  return r;\n}\n\nfunction assertParamsConsistent(e, t) {\n  var r = e[0].length;\n  e.forEach(function (e, t) {\n    assert(e.length === r, \"Error in concat\" + r + \"D: rank of tensors[\" + t + \"] must be the same as the rank of the rest (\" + r + \")\");\n  }), assert(t >= 0 && t < r, \"Error in concat\" + r + \"D: axis must be between 0 and \" + (r - 1) + \".\");\n  var n = e[0];\n  e.forEach(function (e, o) {\n    for (var a = 0; a < r; a++) {\n      assert(a === t || e[a] === n[a], \"Error in concat\" + r + \"D: Shape of tensors[\" + o + \"] (\" + e + \") does not match the shape of the rest (\" + n + \") along the non-concatenated axis \" + o + \".\");\n    }\n  });\n}\n\nfunction computeOutShape(e, t) {\n  for (var r = e[0].slice(), n = 1; n < e.length; n++) {\n    r[t] += e[n][t];\n  }\n\n  return r;\n}\n\nfunction prepareAndValidate(e, t) {\n  if (e.rank < 1) throw new Error(\"tf.gatherND() expects the input to be rank 1 or higher, but the rank was \" + e.rank + \".\");\n  if (t.rank < 1) throw new Error(\"tf.gatherND() expects the indices to be rank 1 or higher, but the rank was \" + t.rank + \".\");\n  if (\"int32\" !== t.dtype) throw new Error(\"tf.gatherND() expects the indices to be int32 type, but the dtype was \" + t.dtype + \".\");\n  if (t.shape[t.rank - 1] > e.rank) throw new Error(\"index innermost dimension length must be <= tensor rank; saw: \" + t.shape[t.rank - 1] + \" vs. \" + e.rank);\n  if (0 === e.size) throw new Error(\"Requested more than 0 entries, but input is empty. Input shape: \" + e.shape + \".\");\n\n  for (var r = t.shape, n = r[r.length - 1], o = 1, a = 0; a < r.length - 1; ++a) {\n    o *= r[a];\n  }\n\n  var i = e.shape,\n      s = r.slice();\n  s.pop();\n  var u = 1;\n\n  for (a = n; a < e.rank; ++a) {\n    u *= i[a], s.push(i[a]);\n  }\n\n  var l = computeStrides(e.shape).map(function (e) {\n    return e / u;\n  }).concat([1]).slice(0, n);\n  return [s, o, u, l];\n}\n\nvar PARALLELIZE_THRESHOLD = 30;\n\nfunction computeOptimalWindowSize(e) {\n  return e <= PARALLELIZE_THRESHOLD ? e : nearestDivisor(e, Math.floor(Math.sqrt(e)));\n}\n\nfunction validateUpdateShape(e, t, r) {\n  var n = t.rank > 1 ? t.shape[t.rank - 1] : 1,\n      o = t.rank > 1 ? t.rank - 1 : 1,\n      a = \"Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: \" + r.shape + \", indices.shape: \" + t.shape + \", shape: \" + e + \", sliceDim: \" + n + \", and batchDim: \" + o + \".\";\n  if (r.rank < o) throw new Error(a + \" update.rank < \" + o + \". \");\n  if (e.length < n + (r.rank - o)) throw new Error(a + \" Output shape length < \" + (n + (r.rank - o)));\n  if (r.rank !== o + e.length - n) throw new Error(a + \" update.rank != \" + (o + e.length - n));\n\n  for (var i = 0; i < o; ++i) {\n    if (r.shape[i] !== t.shape[i]) throw new Error(a + \" updates.shape[\" + i + \"] (\" + r.shape[i] + \") != indices.shape[\" + i + \"] (\" + t.shape[i] + \").\");\n  }\n\n  for (i = 0; i < r.rank - o; ++i) {\n    if (r.shape[i + o] !== e[i + n]) throw new Error(a + \" updates.shape[\" + (i + o) + \"] (\" + r.shape[i + o] + \") != shape[\" + (i + o) + \"] (\" + e[i + o] + \")\");\n  }\n}\n\nfunction validateInput(e, t, r) {\n  if (t.rank < 1) throw new Error(\"tf.scatterND() expects the indices to be rank 1 or higher, but the rank was \" + t.rank + \".\");\n  if (e.rank < 1) throw new Error(\"tf.scatterND() expects the updates to be rank 1 or higher, but the rank was \" + e.rank + \".\");\n  if (\"int32\" !== t.dtype) throw new Error(\"The dtype of 'indices' should be int32, but got dtype: \" + t.dtype);\n  if (r.length < 1) throw new Error(\"Output rank must be greater or equal to 1, but got shape: \" + r);\n\n  if (0 === r.length) {\n    if (0 === t.size) throw new Error(\"Indices specified for empty output. indices shape: \" + t.shape);\n    if (0 === e.size) throw new Error(\"Updates specified for empty output. updates shape: \" + e.shape);\n  }\n\n  validateUpdateShape(r, t, e);\n}\n\nfunction calculateShapes(e, t, r) {\n  for (var n = t.rank > 1 ? t.shape[t.rank - 1] : 1, o = r.length, a = 1, i = n; i < o; ++i) {\n    a *= r[i];\n  }\n\n  var s = n < 1 ? 1 : n,\n      u = t.size / s,\n      l = computeStrides(r).concat([1]);\n  return {\n    sliceRank: n,\n    numUpdates: u,\n    sliceSize: a,\n    strides: l.slice(l.length - n, l.length),\n    outputSize: sizeFromShape(r)\n  };\n}\n\nfunction segOpComputeOptimalWindowSize(e, t) {\n  var r,\n      n = !1;\n\n  for (e <= PARALLELIZE_THRESHOLD ? (r = e, n = !0) : r = nearestDivisor(e, Math.floor(Math.sqrt(e))); !n;) {\n    if (r > t || r === e) {\n      n = !0;\n      break;\n    }\n\n    r = nearestDivisor(e, r + 1);\n  }\n\n  return r;\n}\n\nfunction computeOutShape$1(e, t, r) {\n  for (var n = [], o = e.length, a = 0; a < o; a++) {\n    a !== t ? n.push(e[a]) : n.push(r);\n  }\n\n  return n;\n}\n\nfunction assertParamsValid(e, t, r) {\n  assert(e.rank === t.length, \"Error in slice\" + e.rank + \"D: Length of begin \" + t + \" must match the rank of the array (\" + e.rank + \").\"), assert(e.rank === r.length, \"Error in slice\" + e.rank + \"D: Length of size \" + r + \" must match the rank of the array (\" + e.rank + \").\");\n\n  for (var n = 0; n < e.rank; ++n) {\n    assert(t[n] + r[n] <= e.shape[n], \"Error in slice\" + e.rank + \"D: begin[\" + n + \"] + size[\" + n + \"] (\" + (t[n] + r[n]) + \") would overflow input.shape[\" + n + \"] (\" + e.shape[n] + \")\");\n  }\n}\n\nfunction getStridedSlicedInfo(e, t, r, n, o, a, i, s, u) {\n  if (void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === u && (u = 0), 0 !== i) throw new Error(\"ellipsis mask is not yet supported\");\n  if (0 !== s) throw new Error(\"new axis mask is not yet supported\");\n\n  for (var l = [], c = [], p = [], d = 0; d < e.length; d++) {\n    l[d] = startForAxis(o, t, n, e, d), c[d] = stopForAxis(a, r, n, e, d), u & 1 << d && (c[d] = l[d] + 1, p.push(d));\n  }\n\n  var h = new Array(e.length).fill(0);\n  return h = h.map(function (e, t) {\n    for (var r = 0, o = l[t]; !(n[t] > 0 ? o >= c[t] : o <= c[t]); o += n[t]) {\n      r += 1;\n    }\n\n    return r;\n  }), [l, h, p];\n}\n\nfunction startForAxis(e, t, r, n, o) {\n  var a = t[o];\n  e & 1 << o && (a = r[o] > 0 ? Number.MIN_SAFE_INTEGER : Number.MAX_SAFE_INTEGER);\n  var i = n[o];\n  return a < 0 && (a += i), a = clamp(0, a, i - 1);\n}\n\nfunction stopForAxis(e, t, r, n, o) {\n  var a = t[o];\n  e & 1 << o && (a = r[o] > 0 ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER);\n  var i = n[o];\n  return a < 0 && (a += i), a = r[o] > 0 ? clamp(0, a, i) : clamp(-1, a, i - 1);\n}\n\nfunction inferShape(e) {\n  var t = e;\n  if (isTypedArray(e)) return [e.length];\n  if (!Array.isArray(e)) return [];\n\n  for (var r = []; t instanceof Array;) {\n    r.push(t.length), t = t[0];\n  }\n\n  return e instanceof Array && ENV.get(\"TENSORLIKE_CHECK_SHAPE_CONSISTENCY\") && deepAssertShapeConsistency(e, r, []), r;\n}\n\nfunction deepAssertShapeConsistency(e, t, r) {\n  if (r = r || [], e instanceof Array) {\n    assert(t.length > 0, function () {\n      return \"Element arr[\" + r.join(\"][\") + \"] should be a primitive, but is an array of \" + e.length + \" elements\";\n    }), assert(e.length === t[0], function () {\n      return \"Element arr[\" + r.join(\"][\") + \"] should have \" + t[0] + \" elements, but has \" + e.length + \" elements\";\n    });\n\n    for (var n = t.slice(1), o = 0; o < e.length; ++o) {\n      deepAssertShapeConsistency(e[o], n, r.concat(o));\n    }\n  } else assert(0 === t.length, function () {\n    return \"Element arr[\" + r.join(\"][\") + \"] is a primitive, but should be an array of \" + t[0] + \" elements\";\n  });\n}\n\nfunction assertDtype(e, t, r, n) {\n  if (null != e && (\"numeric\" !== e && e !== t || \"numeric\" === e && \"string\" === t)) throw new Error(\"Argument '\" + r + \"' passed to '\" + n + \"' must be \" + e + \" tensor, but got \" + t + \" tensor\");\n}\n\nfunction convertToTensor(e, t, r, n) {\n  if (void 0 === n && (n = \"numeric\"), e instanceof Tensor) return assertDtype(n, e.dtype, t, r), e;\n  var o = inferDtype(e);\n  if (\"string\" !== o && [\"bool\", \"int32\", \"float32\"].indexOf(n) >= 0 && (o = n), assertDtype(n, o, t, r), !isTypedArray(e) && !Array.isArray(e) && \"number\" != typeof e && \"boolean\" != typeof e && \"string\" != typeof e) throw new Error(\"Argument '\" + t + \"' passed to '\" + r + \"' must be a Tensor or TensorLike, but got '\" + e.constructor.name + \"'\");\n  var a = inferShape(e);\n  isTypedArray(e) || Array.isArray(e) || (e = [e]);\n  var i = \"string\" !== o ? toTypedArray(e, o, ENV.get(\"DEBUG\")) : flatten(e);\n  return Tensor.make(a, {\n    values: i\n  }, o);\n}\n\nfunction convertToTensorArray(e, t, r) {\n  if (!Array.isArray(e)) throw new Error(\"Argument \" + t + \" passed to \" + r + \" must be a `Tensor[]` or `TensorLike[]`\");\n  return e.map(function (e, n) {\n    return convertToTensor(e, t + \"[\" + n + \"]\", r);\n  });\n}\n\nfunction op(e) {\n  var t = Object.keys(e);\n  if (1 !== t.length) throw new Error(\"Please provide an object with a single key (operation name) mapping to a function. Got an object with \" + t.length + \" keys.\");\n  var r = t[0],\n      n = e[r];\n  r.endsWith(\"_\") && (r = r.substring(0, r.length - 1));\n\n  var o = function o() {\n    for (var e = [], t = 0; t < arguments.length; t++) {\n      e[t] = arguments[t];\n    }\n\n    ENV.engine.startScope(r);\n\n    try {\n      var o = n.apply(void 0, e);\n      return o instanceof Promise && console.error(\"Cannot return a Promise inside of tidy.\"), ENV.engine.endScope(o), o;\n    } catch (e) {\n      throw ENV.engine.endScope(null), e;\n    }\n  };\n\n  return Object.defineProperty(o, \"name\", {\n    value: r,\n    configurable: !0\n  }), o;\n}\n\nfunction softmax_(e, t) {\n  void 0 === t && (t = -1);\n  var r = convertToTensor(e, \"logits\", \"softmax\");\n  if (-1 === t && (t = r.rank - 1), t !== r.rank - 1) throw Error(\"Softmax along a non-last dimension is not yet supported. Logits was rank \" + r.rank + \" and dim was \" + t);\n  return customGrad(function (e) {\n    var r = e.logSumExp([t], !0),\n        n = e.toFloat().sub(r).exp();\n    return {\n      value: n,\n      gradFunc: function gradFunc(e) {\n        var r = e.mul(n);\n        return r.sub(r.sum([t], !0).mul(n));\n      }\n    };\n  })(r);\n}\n\nfunction logSoftmax_(e, t) {\n  void 0 === t && (t = -1);\n  var r = convertToTensor(e, \"logits\", \"logSoftmax\");\n  if (-1 === t && (t = r.rank - 1), t !== r.rank - 1) throw Error(\"Log Softmax along a non-last dimension is not yet supported. Logits was rank \" + r.rank + \" and axis was \" + t);\n  return customGrad(function (e) {\n    var r = e.max(t, !0),\n        n = e.sub(r),\n        o = n.toFloat().sub(n.exp().sum(t, !0).log());\n    return {\n      value: o,\n      gradFunc: function gradFunc(e) {\n        var r = o.exp();\n        return e.sub(e.sum(t, !0).mul(r));\n      }\n    };\n  })(r);\n}\n\nvar softmax = op({\n  softmax_: softmax_\n}),\n    logSoftmax = op({\n  logSoftmax_: logSoftmax_\n});\n\nfunction complex_(e, t) {\n  var r = convertToTensor(e, \"real\", \"complex\"),\n      n = convertToTensor(t, \"imag\", \"complex\");\n  return assertShapesMatch(r.shape, n.shape, \"real and imag shapes, \" + r.shape + \" and \" + n.shape + \", must match in call to tf.complex().\"), ENV.engine.runKernel(function (e) {\n    return e.complex(r, n);\n  }, {\n    $real: r,\n    $imag: n\n  });\n}\n\nfunction real_(e) {\n  var t = convertToTensor(e, \"input\", \"real\");\n  return ENV.engine.runKernel(function (e) {\n    return e.real(t);\n  }, {\n    $input: t\n  });\n}\n\nfunction imag_(e) {\n  var t = convertToTensor(e, \"input\", \"imag\");\n  return ENV.engine.runKernel(function (e) {\n    return e.imag(t);\n  }, {\n    $input: t\n  });\n}\n\nvar complex = op({\n  complex_: complex_\n}),\n    real = op({\n  real_: real_\n}),\n    imag = op({\n  imag_: imag_\n});\n\nfunction tensor(e, t, r) {\n  if (null == r && (r = inferDtype(e)), \"complex64\" === r) throw new Error(\"Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).\");\n  if (!isTypedArray(e) && !Array.isArray(e) && \"number\" != typeof e && \"boolean\" != typeof e && \"string\" != typeof e) throw new Error(\"values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray\");\n  var n = inferShape(e);\n  return null != t && 1 !== n.length && assertShapesMatch(t, n, \"Error creating a new Tensor. Inferred shape (\" + n + \") does not match the provided shape (\" + t + \"). \"), isTypedArray(e) || Array.isArray(e) || (e = [e]), t = t || n, e = \"string\" !== r ? toTypedArray(e, r, ENV.get(\"DEBUG\")) : flatten(e), Tensor.make(t, {\n    values: e\n  }, r);\n}\n\nfunction scalar(e, t) {\n  if ((isTypedArray(e) || Array.isArray(e)) && \"complex64\" !== t) throw new Error(\"Error creating a new Scalar: value must be a primitive (number|boolean|string)\");\n  return tensor(e, [], t);\n}\n\nfunction tensor1d(e, t) {\n  assertNonNull(e);\n  var r = inferShape(e);\n  if (1 !== r.length) throw new Error(\"tensor1d() requires values to be a flat/TypedArray\");\n  return tensor(e, r, t);\n}\n\nfunction tensor2d(e, t, r) {\n  if (assertNonNull(e), null != t && 2 !== t.length) throw new Error(\"tensor2d() requires shape to have two numbers\");\n  var n = inferShape(e);\n  if (2 !== n.length && 1 !== n.length) throw new Error(\"tensor2d() requires values to be number[][] or flat/TypedArray\");\n  if (1 === n.length && null == t) throw new Error(\"tensor2d() requires shape to be provided when `values` are a flat/TypedArray\");\n  return tensor(e, t = t || n, r);\n}\n\nfunction tensor3d(e, t, r) {\n  if (assertNonNull(e), null != t && 3 !== t.length) throw new Error(\"tensor3d() requires shape to have three numbers\");\n  var n = inferShape(e);\n  if (3 !== n.length && 1 !== n.length) throw new Error(\"tensor3d() requires values to be number[][][] or flat/TypedArray\");\n  if (1 === n.length && null == t) throw new Error(\"tensor3d() requires shape to be provided when `values` are a flat array\");\n  return tensor(e, t = t || n, r);\n}\n\nfunction tensor4d(e, t, r) {\n  if (assertNonNull(e), null != t && 4 !== t.length) throw new Error(\"tensor4d() requires shape to have four numbers\");\n  var n = inferShape(e);\n  if (4 !== n.length && 1 !== n.length) throw new Error(\"tensor4d() requires values to be number[][][][] or flat/TypedArray\");\n  if (1 === n.length && null == t) throw new Error(\"tensor4d() requires shape to be provided when `values` are a flat array\");\n  return tensor(e, t = t || n, r);\n}\n\nfunction tensor5d(e, t, r) {\n  if (assertNonNull(e), null != t && 5 !== t.length) throw new Error(\"tensor5d() requires shape to have five numbers\");\n  var n = inferShape(e);\n  if (5 !== n.length && 1 !== n.length) throw new Error(\"tensor5d() requires values to be number[][][][][] or flat/TypedArray\");\n  if (1 === n.length && null == t) throw new Error(\"tensor5d() requires shape to be provided when `values` are a flat array\");\n  return tensor(e, t = t || n, r);\n}\n\nfunction tensor6d(e, t, r) {\n  if (assertNonNull(e), null != t && 6 !== t.length) throw new Error(\"tensor6d() requires shape to have six numbers\");\n  var n = inferShape(e);\n  if (6 !== n.length && 1 !== n.length) throw new Error(\"tensor6d() requires values to be number[][][][] or flat/TypedArray\");\n  if (1 === n.length && null == t) throw new Error(\"tensor6d() requires shape to be provided when `values` are a flat array\");\n  return tensor(e, t = t || n, r);\n}\n\nfunction ones$1(e, t) {\n  if (void 0 === t && (t = \"float32\"), \"complex64\" === t) {\n    var r = ones$1(e, \"float32\"),\n        n = ones$1(e, \"float32\");\n    return complex(r, n);\n  }\n\n  var o = makeOnesTypedArray(sizeFromShape(e), t);\n  return Tensor.make(e, {\n    values: o\n  }, t);\n}\n\nfunction zeros(e, t) {\n  if (void 0 === t && (t = \"float32\"), \"complex64\" === t) {\n    var r = zeros(e, \"float32\"),\n        n = zeros(e, \"float32\");\n    return complex(r, n);\n  }\n\n  var o = makeZerosTypedArray(sizeFromShape(e), t);\n  return Tensor.make(e, {\n    values: o\n  }, t);\n}\n\nfunction fill(e, t, r) {\n  var n = getArrayFromDType(r = r || inferDtype(t), sizeFromShape(e));\n  return n.fill(t), Tensor.make(e, {\n    values: n\n  }, r);\n}\n\nfunction onesLike_(e) {\n  var t = convertToTensor(e, \"x\", \"onesLike\");\n  return ones$1(t.shape, t.dtype);\n}\n\nfunction zerosLike_(e) {\n  var t = convertToTensor(e, \"x\", \"zerosLike\");\n  return zeros(t.shape, t.dtype);\n}\n\nfunction linspace(e, t, r) {\n  if (0 === r) throw new Error(\"Cannot request zero samples\");\n  var n = (t - e) / (r - 1),\n      o = makeZerosTypedArray(r, \"float32\");\n  o[0] = e;\n\n  for (var a = 1; a < o.length; a++) {\n    o[a] = o[a - 1] + n;\n  }\n\n  return tensor1d(o, \"float32\");\n}\n\nfunction range(e, t, r, n) {\n  if (void 0 === r && (r = 1), void 0 === n && (n = \"float32\"), 0 === r) throw new Error(\"Cannot have a step of zero\");\n  if (e === t || e < t && r < 0 || t < e && r > 1) return zeros([0], n);\n  var o = makeZerosTypedArray(Math.abs(Math.ceil((t - e) / r)), n);\n  t < e && 1 === r && (r = -1), o[0] = e;\n\n  for (var a = 1; a < o.length; a++) {\n    o[a] = o[a - 1] + r;\n  }\n\n  return tensor1d(o, n);\n}\n\nvar Rank,\n    UpcastInt32AndMap,\n    UpcastBoolAndMap,\n    UpcastFloat32AndMap,\n    UpcastComplex64AndMap,\n    onesLike = op({\n  onesLike_: onesLike_\n}),\n    zerosLike = op({\n  zerosLike_: zerosLike_\n});\n!function (e) {\n  e.R0 = \"R0\", e.R1 = \"R1\", e.R2 = \"R2\", e.R3 = \"R3\", e.R4 = \"R4\", e.R5 = \"R5\", e.R6 = \"R6\";\n}(Rank || (Rank = {})), function (e) {\n  e.float32 = \"float32\", e.int32 = \"int32\", e.bool = \"int32\", e.complex64 = \"complex64\";\n}(UpcastInt32AndMap || (UpcastInt32AndMap = {})), function (e) {\n  e.float32 = \"float32\", e.int32 = \"int32\", e.bool = \"bool\", e.complex64 = \"complex64\";\n}(UpcastBoolAndMap || (UpcastBoolAndMap = {})), function (e) {\n  e.float32 = \"float32\", e.int32 = \"float32\", e.bool = \"float32\", e.complex64 = \"complex64\";\n}(UpcastFloat32AndMap || (UpcastFloat32AndMap = {})), function (e) {\n  e.float32 = \"complex64\", e.int32 = \"complex64\", e.bool = \"complex64\", e.complex64 = \"complex64\";\n}(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));\nvar upcastTypeMap = {\n  float32: UpcastFloat32AndMap,\n  int32: UpcastInt32AndMap,\n  bool: UpcastBoolAndMap,\n  complex64: UpcastComplex64AndMap\n};\n\nfunction upcastType(e, t) {\n  if (\"string\" === e || \"string\" === t) {\n    if (\"string\" === e && \"string\" === t) return \"string\";\n    throw new Error(\"Can not upcast \" + e + \" with \" + t);\n  }\n\n  return upcastTypeMap[e][t];\n}\n\nfunction sumOutType(e) {\n  return upcastType(e, \"int32\");\n}\n\nvar DataStorage = function () {\n  function e(e) {\n    this.dataMover = e, this.data = new WeakMap();\n  }\n\n  return e.prototype.get = function (e) {\n    return this.data.has(e) || this.dataMover.moveData(e), this.data.get(e);\n  }, e.prototype.set = function (e, t) {\n    this.data.set(e, t);\n  }, e.prototype.has = function (e) {\n    return this.data.has(e);\n  }, e.prototype.delete = function (e) {\n    return this.data.delete(e);\n  }, e;\n}(),\n    KernelBackend = function () {\n  function e() {}\n\n  return e.prototype.time = function (e) {\n    throw new Error(\"Not yet implemented.\");\n  }, e.prototype.read = function (e) {\n    throw new Error(\"Not yet implemented.\");\n  }, e.prototype.readSync = function (e) {\n    throw new Error(\"Not yet implemented.\");\n  }, e.prototype.disposeData = function (e) {\n    throw new Error(\"Not yet implemented.\");\n  }, e.prototype.write = function (e, t) {\n    throw new Error(\"Not yet implemented.\");\n  }, e.prototype.fromPixels = function (e, t) {\n    throw new Error(\"Not yet implemented.\");\n  }, e.prototype.register = function (e, t, r) {\n    throw new Error(\"Not yet implemented.\");\n  }, e.prototype.memory = function () {\n    throw new Error(\"Not yet implemented.\");\n  }, e.prototype.floatPrecision = function () {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.batchMatMul = function (e, t, r, n) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.slice = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.stridedSlice = function (e, t, r, n, o, a, i, s, u) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.reverse = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.concat = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.neg = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.add = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.addN = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.subtract = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.multiply = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.realDivide = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.floorDiv = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.sum = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.prod = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.unsortedSegmentSum = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.argMin = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.argMax = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.equal = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.notEqual = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.less = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.lessEqual = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.greater = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.greaterEqual = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.logicalNot = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.logicalAnd = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.logicalOr = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.where = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.select = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.topk = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.min = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.minimum = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.mod = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.max = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.maximum = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.all = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.any = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.squaredDifference = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.ceil = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.floor = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.round = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.sign = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.pow = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.exp = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.expm1 = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.log = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.log1p = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.sqrt = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.rsqrt = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.square = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.reciprocal = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.relu = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.elu = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.eluDer = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.selu = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.int = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.clip = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.abs = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.complexAbs = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.sigmoid = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.softplus = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.sin = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.cos = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.tan = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.asin = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.acos = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.atan = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.atan2 = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.sinh = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.cosh = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.tanh = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.asinh = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.acosh = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.atanh = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.erf = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.step = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.conv2d = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.conv2dDerInput = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.conv2dDerFilter = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.depthwiseConv2D = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.depthwiseConv2DDerInput = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.depthwiseConv2DDerFilter = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.maxPool = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.maxPoolBackprop = function (e, t, r, n) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.avgPool = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.avgPoolBackprop = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.reshape = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.cast = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.tile = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.pad = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.transpose = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.gather = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.gatherND = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.scatterND = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.batchToSpaceND = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.spaceToBatchND = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.resizeBilinear = function (e, t, r, n) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.resizeBilinearBackprop = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.resizeNearestNeighbor = function (e, t, r, n) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.resizeNearestNeighborBackprop = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.batchNormalization = function (e, t, r, n, o, a) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.localResponseNormalization4D = function (e, t, r, n, o) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.LRNGrad = function (e, t, r, n, o, a, i) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.multinomial = function (e, t, r, n) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.oneHot = function (e, t, r, n) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.cumsum = function (e, t, r, n) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.nonMaxSuppression = function (e, t, r, n, o) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.fft = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.ifft = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.complex = function (e, t) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.real = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.imag = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.cropAndResize = function (e, t, r, n, o, a) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.depthToSpace = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.split = function (e, t, r) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.sparseToDense = function (e, t, r, n) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.setDataMover = function (e) {\n    throw new Error(\"Not yet implemented\");\n  }, e.prototype.dispose = function () {\n    throw new Error(\"Not yet implemented\");\n  }, e;\n}();\n\nfunction castTensor(e, t, r) {\n  if (\"complex64\" === t) {\n    if (\"complex64\" === e.dtype) return e.clone();\n    var n = zeros(e.shape),\n        o = e.toFloat(),\n        a = r.complex(o, n);\n    return n.dispose(), o.dispose(), a;\n  }\n\n  if (!hasEncodingLoss(e.dtype, t)) return Tensor.make(e.shape, {\n    dataId: e.dataId\n  }, t);\n\n  if (\"complex64\" === e.dtype) {\n    var i = r.real(e);\n    a = i.cast(t);\n    return i.dispose(), a;\n  }\n\n  if (\"int32\" === t) return r.int(e);\n\n  if (\"bool\" === t) {\n    var s = scalar(0, e.dtype);\n    a = r.notEqual(e, s);\n    return s.dispose(), a;\n  }\n\n  throw new Error(\"Error in Cast: unknown dtype argument (\" + t + \")\");\n}\n\nfunction reshapeTensor(e, t) {\n  return Tensor.make(t, {\n    dataId: e.dataId\n  }, e.dtype);\n}\n\nfunction mergeRealAndImagArrays(e, t) {\n  if (e.length !== t.length) throw new Error(\"Cannot merge real and imag arrays of different lengths. real:\" + e.length + \", imag: \" + t.length + \".\");\n\n  for (var r = new Float32Array(2 * e.length), n = 0; n < r.length; n += 2) {\n    r[n] = e[n / 2], r[n + 1] = t[n / 2];\n  }\n\n  return r;\n}\n\nfunction splitRealAndImagArrays(e) {\n  for (var t = new Float32Array(e.length / 2), r = new Float32Array(e.length / 2), n = 0; n < e.length; n += 2) {\n    t[n / 2] = e[n], r[n / 2] = e[n + 1];\n  }\n\n  return {\n    real: t,\n    imag: r\n  };\n}\n\nfunction complexWithEvenIndex(e) {\n  for (var t = Math.ceil(e.length / 4), r = new Float32Array(t), n = new Float32Array(t), o = 0; o < e.length; o += 4) {\n    r[Math.floor(o / 4)] = e[o], n[Math.floor(o / 4)] = e[o + 1];\n  }\n\n  return {\n    real: r,\n    imag: n\n  };\n}\n\nfunction complexWithOddIndex(e) {\n  for (var t = Math.floor(e.length / 4), r = new Float32Array(t), n = new Float32Array(t), o = 2; o < e.length; o += 4) {\n    r[Math.floor(o / 4)] = e[o], n[Math.floor(o / 4)] = e[o + 1];\n  }\n\n  return {\n    real: r,\n    imag: n\n  };\n}\n\nfunction getComplexWithIndex(e, t) {\n  return {\n    real: e[2 * t],\n    imag: e[2 * t + 1]\n  };\n}\n\nfunction assignToTypedArray(e, t, r, n) {\n  e[2 * n] = t, e[2 * n + 1] = r;\n}\n\nfunction exponents(e, t) {\n  for (var r = new Float32Array(e / 2), n = new Float32Array(e / 2), o = 0; o < Math.ceil(e / 2); o++) {\n    var a = (t ? 2 : -2) * Math.PI * (o / e);\n    r[o] = Math.cos(a), n[o] = Math.sin(a);\n  }\n\n  return {\n    real: r,\n    imag: n\n  };\n}\n\nfunction exponent(e, t, r) {\n  var n = (r ? 2 : -2) * Math.PI * (e / t);\n  return {\n    real: Math.cos(n),\n    imag: Math.sin(n)\n  };\n}\n\nfunction nonMaxSuppressionImpl(e, t, r, n, o) {\n  for (var a = Array.from(t).map(function (e, t) {\n    return {\n      score: e,\n      boxIndex: t\n    };\n  }).filter(function (e) {\n    return e.score > o;\n  }).sort(function (e, t) {\n    return t.score - e.score;\n  }), i = [], s = 0; s < a.length; s++) {\n    var u = a[s],\n        l = u.score,\n        c = u.boxIndex;\n    if (l < o) break;\n\n    for (var p = !1, d = i.length - 1; d >= 0; --d) {\n      if (intersectionOverUnion(e, c, i[d]) >= n) {\n        p = !0;\n        break;\n      }\n    }\n\n    if (!p && (i.push(c), i.length >= r)) break;\n  }\n\n  return tensor1d(i, \"int32\");\n}\n\nfunction intersectionOverUnion(e, t, r) {\n  var n = e.subarray(4 * t, 4 * t + 4),\n      o = e.subarray(4 * r, 4 * r + 4),\n      a = Math.min(n[0], n[2]),\n      i = Math.min(n[1], n[3]),\n      s = Math.max(n[0], n[2]),\n      u = Math.max(n[1], n[3]),\n      l = Math.min(o[0], o[2]),\n      c = Math.min(o[1], o[3]),\n      p = Math.max(o[0], o[2]),\n      d = Math.max(o[1], o[3]),\n      h = (s - a) * (u - i),\n      f = (p - l) * (d - c);\n  if (h <= 0 || f <= 0) return 0;\n  var m = Math.max(a, l),\n      g = Math.max(i, c),\n      v = Math.min(s, p),\n      y = Math.min(u, d),\n      x = Math.max(v - m, 0) * Math.max(y - g, 0);\n  return x / (h + f - x);\n}\n\nfunction split(e, t, r) {\n  var n = Array(e.rank).fill(0),\n      o = e.shape.slice();\n  return t.map(function (t) {\n    o[r] = t;\n    var a = e.slice(n, o);\n    return n[r] += t, a;\n  });\n}\n\nfunction topkImpl(e, t, r, n, o) {\n  for (var a = t[t.length - 1], i = [e.length / a, a], s = i[0], u = i[1], l = getTypedArrayFromDType(r, s * n), c = getTypedArrayFromDType(\"int32\", s * n), p = 0; p < s; p++) {\n    for (var d = p * u, h = e.subarray(d, d + u), f = [], m = 0; m < h.length; m++) {\n      f.push({\n        value: h[m],\n        index: m\n      });\n    }\n\n    f.sort(function (e, t) {\n      return t.value - e.value;\n    });\n    var g = p * n,\n        v = l.subarray(g, g + n),\n        y = c.subarray(g, g + n);\n\n    for (m = 0; m < n; m++) {\n      v[m] = f[m].value, y[m] = f[m].index;\n    }\n  }\n\n  var x = t.slice();\n  return x[x.length - 1] = n, [tensor(l, x, r), tensor(c, x, \"int32\")];\n}\n\nvar ArgMinMaxProgram = function () {\n  return function (e, t, r) {\n    this.variableNames = [\"A\"];\n    var n = e.windowSize,\n        o = e.batchSize,\n        a = e.inSize,\n        i = Math.ceil(a / n);\n    r || this.variableNames.push(\"bestIndicesA\"), this.outputShape = [o, i];\n    var s = \"max\" === t ? \">\" : \"<\",\n        u = r ? \"inOffset + i;\" : \"round(getBestIndicesA(batch, inOffset + i));\";\n    this.userCode = \"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = outIdx * \" + n + \";\\n\\n        int bestIndex = inOffset;\\n        float bestValue = getA(batch, bestIndex);\\n\\n        for (int i = 0; i < \" + n + \"; i++) {\\n          int inIdx = \" + u + \";\\n          float candidate = getA(batch, inIdx);\\n          if (candidate \" + s + \" bestValue) {\\n            bestValue = candidate;\\n            bestIndex = inIdx;\\n          }\\n        }\\n        setOutput(float(bestIndex));\\n      }\\n    \";\n  };\n}(),\n    AvgPool2DBackpropProgram = function () {\n  return function (e) {\n    this.variableNames = [\"dy\"], this.outputShape = e.inShape;\n    var t = e.filterHeight,\n        r = e.filterWidth,\n        n = e.strideHeight,\n        o = e.strideWidth,\n        a = e.dilationHeight,\n        i = e.dilationWidth,\n        s = e.effectiveFilterHeight,\n        u = e.effectiveFilterWidth,\n        l = s - 1 - e.padInfo.top,\n        c = u - 1 - e.padInfo.left,\n        p = 1 / (t * r);\n    this.userCode = \"\\n      const ivec2 pads = ivec2(\" + l + \", \" + c + \");\\n      const float avgMultiplier = float(\" + p + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 dyRCCorner = coords.yz - pads;\\n        int dyRCorner = dyRCCorner.x;\\n        int dyCCorner = dyRCCorner.y;\\n\\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + s + \";\\n            wR += \" + a + \") {\\n          float dyR = float(dyRCorner + wR) / \" + n + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + e.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          for (int wC = 0; wC < \" + u + \";\\n            wC+= \" + i + \") {\\n            float dyC = float(dyCCorner + wC) / \" + o + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + e.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            float dyValue = getDy(b, idyR, idyC, d);\\n\\n            dotProd += dyValue * avgMultiplier;\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n  };\n}();\n\nfunction getBroadcastDims(e, t) {\n  for (var r = e.length, n = [], o = 0; o < r; o++) {\n    var a = r - 1 - o,\n        i = e[a] || 1;\n    (t[t.length - 1 - o] || 1) > 1 && 1 === i && n.unshift(a);\n  }\n\n  return n;\n}\n\nfunction getReductionAxes(e, t) {\n  for (var r = [], n = 0; n < t.length; n++) {\n    var o = e[e.length - n - 1],\n        a = t.length - n - 1,\n        i = t[a];\n    (null == o || 1 === o && i > 1) && r.unshift(a);\n  }\n\n  return r;\n}\n\nfunction broadcastDimsAreOuter(e) {\n  for (var t = 0; t < e.length; t++) {\n    if (e[t] !== t) return !1;\n  }\n\n  return !0;\n}\n\nfunction assertAndGetBroadcastShape(e, t) {\n  for (var r = [], n = Math.max(e.length, t.length), o = 0; o < n; o++) {\n    var a = e[e.length - o - 1];\n    null == a && (a = 1);\n    var i = t[t.length - o - 1];\n    if (null == i && (i = 1), 1 === a) r.unshift(i);else if (1 === i) r.unshift(a);else {\n      if (a !== i) throw Error(\"Operands could not be broadcast together with shapes \" + e + \" and \" + t + \".\");\n      r.unshift(a);\n    }\n  }\n\n  return r;\n}\n\nvar BatchNormProgram = function () {\n  return function (e, t, r, n, o, a) {\n    this.outputShape = [], this.supportsBroadcasting = !0, this.variableNames = [\"x\", \"mean\", \"variance\"], assertAndGetBroadcastShape(e, t), assertAndGetBroadcastShape(e, r);\n    var i = \"0.0\";\n    null != n && (assertAndGetBroadcastShape(e, n), this.variableNames.push(\"offset\"), i = \"getOffsetAtOutCoords()\");\n    var s = \"1.0\";\n    null != o && (assertAndGetBroadcastShape(e, o), this.variableNames.push(\"scale\"), s = \"getScaleAtOutCoords()\"), this.outputShape = e, this.userCode = \"\\n      void main() {\\n        float x = getXAtOutCoords();\\n        float mean = getMeanAtOutCoords();\\n        float variance = getVarianceAtOutCoords();\\n        float offset = \" + i + \";\\n        float scale = \" + s + \";\\n        float inv = scale * inversesqrt(variance + float(\" + a + \"));\\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\\n      }\\n    \";\n  };\n}(),\n    BatchNormPackedProgram = function () {\n  return function (e, t, r, n, o, a) {\n    this.supportsBroadcasting = !0, this.usesPackedTextures = !0, this.variableNames = [\"x\", \"mean\", \"variance\"], assertAndGetBroadcastShape(e, t), assertAndGetBroadcastShape(e, r);\n    var i = broadcastSample(\"mean\", t.length),\n        s = broadcastSample(\"variance\", r.length),\n        u = \"vec4 offset = vec4(0.0)\";\n    null != n && (assertAndGetBroadcastShape(e, n), this.variableNames.push(\"offset\"), u = broadcastSample(\"offset\", n.length));\n    var l = \"vec4 scale = vec4(1.0)\";\n    null != o && (assertAndGetBroadcastShape(e, o), this.variableNames.push(\"scale\"), l = broadcastSample(\"scale\", o.length)), this.outputShape = e, this.userCode = \"\\n      void main() {\\n        ivec4 rc = getOutputCoords();\\n\\n        \" + u + \";\\n        \" + l + \";\\n\\n        vec4 x = getX(rc.x, rc.y, rc.z, rc.w);\\n        \" + i + \";\\n        \" + s + \";\\n\\n        vec4 inv = scale * inversesqrt(variance + vec4(\" + a + \"));\\n\\n        setOutput((x - mean) * inv + offset);\\n      }\\n    \";\n  };\n}();\n\nfunction broadcastSample(e, t) {\n  var r = \"get\" + e.charAt(0).toUpperCase() + e.slice(1);\n  return 1 === t ? \"\\n      vec4 \" + e + \"Sample = \" + r + \"(rc.w);\\n      vec4 \" + e + \" = vec4(\" + e + \"Sample.xy, \" + e + \"Sample.xy);\\n    \" : \"vec4 \" + e + \" = \" + r + \"(rc.x, rc.y, rc.z, rc.w)\";\n}\n\nvar COMPLEX_MULTIPLY = {\n  REAL: \"return areal * breal - aimag * bimag;\",\n  IMAG: \"return areal * bimag + aimag * breal;\"\n},\n    BinaryOpComplexProgram = function () {\n  return function (e, t, r) {\n    this.variableNames = [\"AReal\", \"AImag\", \"BReal\", \"BImag\"], this.supportsBroadcasting = !0, this.outputShape = assertAndGetBroadcastShape(t, r), this.userCode = \"\\n      float binaryOpComplex(\\n          float areal, float aimag, float breal, float bimag) {\\n        \" + e + \"\\n      }\\n\\n      void main() {\\n        float areal = getARealAtOutCoords();\\n        float aimag = getAImagAtOutCoords();\\n        float breal = getBRealAtOutCoords();\\n        float bimag = getBImagAtOutCoords();\\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\\n      }\\n    \";\n  };\n}(),\n    CHECK_NAN_SNIPPET = \"\\n  if (isNaN(a)) return a;\\n  if (isNaN(b)) return b;\\n\",\n    ADD = \"return a + b;\",\n    SUB = \"return a - b;\",\n    MUL = \"return a * b;\",\n    DIV = \"if (a == b) return 1.0;\\n  return a / b;\",\n    INT_DIV = \"\\n  float resultSign = sign(a) * sign(b);\\n  int ia = round(a);\\n  int ib = round(b);\\n  int result = ia / ib;\\n  int amodb = ia - ib * result;\\n\\n  if (resultSign < 0.0 && amodb != 0) {\\n    result -= 1;\\n  }\\n  return float(result);\\n\",\n    POW = \"\\nif(a < 0.0 && floor(b) < b){\\n  return NAN;\\n}\\nreturn (round(mod(b, 2.0)) == 0 || round(mod(b, 2.0)) == 2) ?\\n    pow(abs(a), b) : sign(a) * pow(abs(a), b);\\n\",\n    SQUARED_DIFFERENCE = \"return (a - b) * (a - b);\",\n    EQUAL = \"return float(a == b);\",\n    NOT_EQUAL = \"return float(a != b);\",\n    LESS = \"return float(a < b);\",\n    LESS_EQUAL = \"return float(a <= b);\",\n    GREATER = \"return float(a > b);\",\n    GREATER_EQUAL = \"return float(a >= b);\",\n    LOGICAL_AND = \"return float(a >= 1.0 && b >= 1.0);\",\n    LOGICAL_OR = \"return float(a >= 1.0 || b >= 1.0);\",\n    MAX = CHECK_NAN_SNIPPET + \"\\n  return max(a, b);\\n\",\n    MIN = CHECK_NAN_SNIPPET + \"\\n  return min(a, b);\\n\",\n    MOD = \"if (b == 0.0) return NAN;\\n  return mod(a, b);\",\n    ATAN2 = CHECK_NAN_SNIPPET + \"\\n  return atan(a, b);\\n\",\n    ELU_DER = \"return (b >= 1.0) ? a : a * (b + 1.0);\",\n    BinaryOpProgram = function () {\n  function e(e, t, r) {\n    this.variableNames = [\"A\", \"B\"], this.supportsBroadcasting = !0, this.outputShape = assertAndGetBroadcastShape(t, r), this.userCode = \"\\n      uniform float NAN;\\n      float binaryOperation(float a, float b) {\\n        \" + e + \"\\n      }\\n\\n      void main() {\\n        float a = getAAtOutCoords();\\n        float b = getBAtOutCoords();\\n        setOutput(binaryOperation(a, b));\\n      }\\n    \";\n  }\n\n  return e.prototype.getCustomSetupFunc = function () {\n    var e = this;\n    return function (t, r) {\n      null == e.startLoc && (e.startLoc = t.getUniformLocationNoThrow(r, \"NAN\"), null == e.startLoc) || t.gl.uniform1f(e.startLoc, NaN);\n    };\n  }, e;\n}(),\n    ClipProgram = function () {\n  return function (e, t, r) {\n    this.variableNames = [\"A\"], this.outputShape = e, this.userCode = \"\\n      void main() {\\n        float value = getAAtOutCoords();\\n        if (isNaN(value)) {\\n          setOutput(value);\\n          return;\\n        }\\n\\n        setOutput(clamp(value, float(\" + t + \"), float(\" + r + \")));\\n      }\\n    \";\n  };\n}(),\n    ComplexAbsProgram = function () {\n  return function (e) {\n    this.variableNames = [\"real\", \"imag\"], this.outputShape = e, this.userCode = \"\\n      void main() {\\n        float re = abs(getRealAtOutCoords());\\n        float im = abs(getImagAtOutCoords());\\n        float mx = max(re, im);\\n\\n        // sadly the length function in glsl is not underflow-safe\\n        // (at least not on Intel GPUs). So the safe solution is\\n        // to ensure underflow-safety in all cases.\\n        setOutput(\\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\\n        );\\n      }\\n    \";\n  };\n}(),\n    ConcatProgram = function () {\n  return function (e, t) {\n    this.variableNames = [\"A\", \"B\"], this.outputShape = [], this.outputShape = computeOutShape([e, t], 1), this.userCode = \"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int yR = coords.x;\\n        int yC = coords.y;\\n\\n        float value = 0.0;\\n        if (yC < \" + e[1] + \") {\\n          value = getA(yR, yC);\\n        } else {\\n          yC -= \" + e[1] + \";\\n          value = getB(yR, yC);\\n        }\\n\\n        setOutput(value);\\n      }\\n    \";\n  };\n}(),\n    Conv2DDerFilterProgram = function () {\n  return function (e) {\n    this.variableNames = [\"x\", \"dy\"], this.outputShape = e.filterShape;\n    var t = e.strideHeight,\n        r = e.strideWidth,\n        n = e.padInfo.top,\n        o = e.padInfo.left;\n    this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int wR = coords.x;\\n        int wC = coords.y;\\n        int d1 = coords.z;\\n        int d2 = coords.w;\\n\\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n\\n        for (int b = 0; b < \" + e.batchSize + \"; b++) {\\n          for (int yR = 0; yR < \" + e.outHeight + \"; yR++) {\\n            int xR = wR + yR * \" + t + \" - \" + n + \";\\n\\n            if (xR < 0 || xR >= \" + e.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int yC = 0; yC < \" + e.outWidth + \"; yC++) {\\n              int xC = wC + yC * \" + r + \" - \" + o + \";\\n\\n              if (xC < 0 || xC >= \" + e.inWidth + \") {\\n                continue;\\n              }\\n\\n              float dyValue = getDy(b, yR, yC, d2);\\n              float xValue = getX(b, xR, xC, d1);\\n              dotProd += (xValue * dyValue);\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n  };\n}(),\n    Conv2DDerInputProgram = function () {\n  return function (e) {\n    this.variableNames = [\"dy\", \"W\"], this.outputShape = e.inShape;\n    var t = e.filterHeight,\n        r = e.filterWidth,\n        n = e.strideHeight,\n        o = e.strideWidth,\n        a = t - 1 - e.padInfo.top,\n        i = r - 1 - e.padInfo.left;\n    this.userCode = \"\\n      const ivec2 pads = ivec2(\" + a + \", \" + i + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d1 = coords[3];\\n\\n        ivec2 dyCorner = coords.yz - pads;\\n        int dyRCorner = dyCorner.x;\\n        int dyCCorner = dyCorner.y;\\n\\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + t + \"; wR++) {\\n          float dyR = float(dyRCorner + wR) / \" + n + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + e.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          int wRPerm = \" + t + \" - 1 - wR;\\n\\n          for (int wC = 0; wC < \" + r + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + o + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + e.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            int wCPerm = \" + r + \" - 1 - wC;\\n\\n            for (int d2 = 0; d2 < \" + e.outChannels + \"; d2++) {\\n              float xValue = getDy(batch, idyR, idyC, d2);\\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\\n              dotProd += xValue * wValue;\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n  };\n}(),\n    DepthwiseConv2DDerFilterProgram = function () {\n  return function (e) {\n    this.variableNames = [\"x\", \"dy\"], this.outputShape = e.filterShape;\n    var t = e.strideHeight,\n        r = e.strideWidth,\n        n = e.padInfo.top,\n        o = e.padInfo.left,\n        a = e.outChannels / e.inChannels;\n    this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int wR = coords.x;\\n        int wC = coords.y;\\n        int d1 = coords.z;\\n        int dm = coords.w;\\n        int d2 = d1 * \" + a + \" + dm;\\n\\n        float dotProd = 0.0;\\n\\n        // TODO: Vec4 over the batch size\\n        for (int b = 0; b < \" + e.batchSize + \"; b++) {\\n          for (int yR = 0; yR < \" + e.outHeight + \"; yR++) {\\n            int xR = wR + yR * \" + t + \" - \" + n + \";\\n\\n            if (xR < 0 || xR >= \" + e.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int yC = 0; yC < \" + e.outWidth + \"; yC++) {\\n              int xC = wC + yC * \" + r + \" - \" + o + \";\\n\\n              if (xC < 0 || xC >= \" + e.inWidth + \") {\\n                continue;\\n              }\\n\\n              float dyValue = getDy(b, yR, yC, d2);\\n              float xValue = getX(b, xR, xC, d1);\\n              dotProd += (xValue * dyValue);\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n  };\n}(),\n    DepthwiseConv2DDerInputProgram = function () {\n  return function (e) {\n    this.variableNames = [\"dy\", \"W\"], this.outputShape = e.inShape;\n    var t = e.filterHeight,\n        r = e.filterWidth,\n        n = e.strideHeight,\n        o = e.strideWidth,\n        a = t - 1 - e.padInfo.top,\n        i = r - 1 - e.padInfo.left,\n        s = e.outChannels / e.inChannels;\n    this.userCode = \"\\n      const ivec2 pads = ivec2(\" + a + \", \" + i + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d1 = coords[3];\\n        ivec2 dyCorner = coords.yz - pads;\\n        int dyRCorner = dyCorner.x;\\n        int dyCCorner = dyCorner.y;\\n\\n        float dotProd = 0.0;\\n\\n        for (int wR = 0; wR < \" + t + \"; wR++) {\\n          float dyR = float(dyRCorner + wR) / \" + n + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + e.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          int wRPerm = \" + t + \" - 1 - wR;\\n\\n          for (int wC = 0; wC < \" + r + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + o + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + e.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            int wCPerm = \" + r + \" - 1 - wC;\\n\\n            // TODO: Vec4 over the channelMul\\n            for (int dm = 0; dm < \" + s + \"; dm++) {\\n              int d2 = d1 * \" + s + \" + dm;\\n              float xValue = getDy(batch, idyR, idyC, d2);\\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\\n              dotProd += xValue * wValue;\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n  };\n}(),\n    Conv2DProgram = function () {\n  return function (e) {\n    this.variableNames = [\"x\", \"W\"], this.outputShape = e.outShape;\n    var t = e.padInfo.top,\n        r = e.padInfo.left,\n        n = e.strideHeight,\n        o = e.strideWidth,\n        a = e.dilationHeight,\n        i = e.dilationWidth,\n        s = e.filterHeight,\n        u = e.filterWidth,\n        l = 4 * Math.floor(e.inChannels / 4),\n        c = e.inChannels % 4;\n    this.userCode = \"\\n      const ivec2 strides = ivec2(\" + n + \", \" + o + \");\\n      const ivec2 pads = ivec2(\" + t + \", \" + r + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d2 = coords[3];\\n\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + s + \"; wR++) {\\n          int xR = xRCorner + wR * \" + a + \";\\n\\n          if (xR < 0 || xR >= \" + e.inHeight + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + u + \"; wC++) {\\n            int xC = xCCorner + wC * \" + i + \";\\n\\n            if (xC < 0 || xC >= \" + e.inWidth + \") {\\n              continue;\\n            }\\n\\n            for (int d1 = 0; d1 < \" + l + \"; d1 += 4) {\\n              vec4 xValues = vec4(\\n                getX(batch, xR, xC, d1),\\n                getX(batch, xR, xC, d1 + 1),\\n                getX(batch, xR, xC, d1 + 2),\\n                getX(batch, xR, xC, d1 + 3)\\n              );\\n              vec4 wValues = vec4(\\n                getW(wR, wC, d1, d2),\\n                getW(wR, wC, d1 + 1, d2),\\n                getW(wR, wC, d1 + 2, d2),\\n                getW(wR, wC, d1 + 3, d2)\\n              );\\n\\n              dotProd += dot(xValues, wValues);\\n            }\\n\\n            if (\" + (1 === c) + \") {\\n              dotProd +=\\n                getX(batch, xR, xC, \" + l + \") *\\n                getW(wR, wC, \" + l + \", d2);\\n            } else if (\" + (2 === c) + \") {\\n              vec2 xValues = vec2(\\n                getX(batch, xR, xC, \" + l + \"),\\n                getX(batch, xR, xC, \" + l + \" + 1)\\n              );\\n              vec2 wValues = vec2(\\n                getW(wR, wC, \" + l + \", d2),\\n                getW(wR, wC, \" + l + \" + 1, d2)\\n              );\\n              dotProd += dot(xValues, wValues);\\n            } else if (\" + (3 === c) + \") {\\n              vec3 xValues = vec3(\\n                getX(batch, xR, xC, \" + l + \"),\\n                getX(batch, xR, xC, \" + l + \" + 1),\\n                getX(batch, xR, xC, \" + l + \" + 2)\\n              );\\n              vec3 wValues = vec3(\\n                getW(wR, wC, \" + l + \", d2),\\n                getW(wR, wC, \" + l + \" + 1, d2),\\n                getW(wR, wC, \" + l + \" + 2, d2)\\n              );\\n              dotProd += dot(xValues, wValues);\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n  };\n}(),\n    DepthwiseConv2DProgram = function () {\n  return function (e) {\n    this.variableNames = [\"x\", \"W\"], this.outputShape = e.outShape;\n    var t = e.inHeight,\n        r = e.inWidth,\n        n = e.padInfo.top,\n        o = e.padInfo.left,\n        a = e.strideHeight,\n        i = e.strideWidth,\n        s = e.dilationHeight,\n        u = e.dilationWidth,\n        l = e.filterHeight,\n        c = e.filterWidth,\n        p = e.outChannels / e.inChannels;\n    this.userCode = \"\\n      const ivec2 strides = ivec2(\" + a + \", \" + i + \");\\n      const ivec2 pads = ivec2(\" + n + \", \" + o + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords.x;\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int d2 = coords.w;\\n        int d1 = d2 / \" + p + \";\\n        int q = d2 - d1 * \" + p + \";\\n\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\\n        for (int wR = 0; wR < \" + l + \"; wR++) {\\n          int xR = xRCorner + wR * \" + s + \";\\n\\n          if (xR < 0 || xR >= \" + t + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + c + \"; wC++) {\\n            int xC = xCCorner + wC * \" + u + \";\\n\\n            if (xC < 0 || xC >= \" + r + \") {\\n              continue;\\n            }\\n\\n            float xVal = getX(batch, xR, xC, d1);\\n            float wVal = getW(wR, wC, d1, q);\\n            dotProd += xVal * wVal;\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n  };\n}(),\n    CropAndResizeProgram = function () {\n  return function (e, t, r, n, o) {\n    this.variableNames = [\"Image\", \"Boxes\", \"BoxInd\"], this.outputShape = [];\n    var a = e[0],\n        i = e[1],\n        s = e[2],\n        u = e[3],\n        l = t[0],\n        c = r[0],\n        p = r[1];\n    this.outputShape = [l, c, p, u];\n    var d = \"bilinear\" === n ? 1 : 0,\n        h = [i - 1 + \".0\", s - 1 + \".0\"],\n        f = h[0],\n        m = h[1],\n        g = c > 1 ? [\"\" + (i - 1) / (c - 1), \"(y2-y1) * height_ratio\", \"y1*\" + f + \" + float(y)*(height_scale)\"] : [\"0.0\", \"0.0\", \"0.5 * (y1+y2) * \" + f],\n        v = g[0],\n        y = g[1],\n        x = g[2],\n        T = p > 1 ? [\"\" + (s - 1) / (p - 1), \"(x2-x1) * width_ratio\", \"x1*\" + m + \" + float(x)*(width_scale)\"] : [\"0.0\", \"0.0\", \"0.5 * (x1+x2) * \" + m],\n        E = T[0],\n        w = T[1],\n        S = T[2];\n    this.userCode = \"\\n      const float height_ratio = float(\" + v + \");\\n      const float width_ratio = float(\" + E + \");\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int y = coords[1];\\n        int x = coords[2];\\n        int d = coords[3];\\n\\n        // get box vals\\n        float y1 = getBoxes(b,0);\\n        float x1 = getBoxes(b,1);\\n        float y2 = getBoxes(b,2);\\n        float x2 = getBoxes(b,3);\\n\\n        // get image in batch index\\n        int bInd = round(getBoxInd(b));\\n        if(bInd < 0 || bInd >= \" + a + \") {\\n          return;\\n        }\\n\\n        float height_scale = \" + y + \";\\n        float width_scale = \" + w + \";\\n\\n        float in_y = \" + x + \";\\n        if( in_y < 0.0 || in_y > \" + f + \" ) {\\n          setOutput(float(\" + o + \"));\\n          return;\\n        }\\n        float in_x = \" + S + \";\\n        if( in_x < 0.0 || in_x > \" + m + \" ) {\\n          setOutput(float(\" + o + \"));\\n          return;\\n        }\\n\\n        vec2 sourceFracIndexRC = vec2(in_y,in_x);\\n        if(\" + d + \" == 1) {\\n          // Compute the four integer indices.\\n          ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\\n          ivec2 sourceCeilRC = ivec2(ceil(sourceFracIndexRC));\\n\\n          float topLeft = getImage(b, sourceFloorRC.x, sourceFloorRC.y, d);\\n          float bottomLeft = getImage(b, sourceCeilRC.x, sourceFloorRC.y, d);\\n          float topRight = getImage(b, sourceFloorRC.x, sourceCeilRC.y, d);\\n          float bottomRight = getImage(b, sourceCeilRC.x, sourceCeilRC.y, d);\\n\\n          vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\\n\\n          float top = topLeft + (topRight - topLeft) * fracRC.y;\\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\\n          float newValue = top + (bottom - top) * fracRC.x;\\n          setOutput(newValue);\\n        } else {\\n          // Compute the coordinators of nearest neighbor point.\\n          ivec2 sourceNearestRC = ivec2(floor(\\n            sourceFracIndexRC + vec2(0.5,0.5)));\\n          float newValue = getImage(b, sourceNearestRC.x, sourceNearestRC.y, d);\\n          setOutput(newValue);\\n        }\\n      }\\n    \";\n  };\n}();\n\nfunction getLogicalCoordinatesFromFlatIndex(e, t, r) {\n  void 0 === r && (r = \"index\");\n  var n = computeStrides(t);\n  return n.map(function (t, o) {\n    return \"int \" + e[o] + \" = \" + r + \" / \" + t + \"; \" + (o === n.length - 1 ? \"int \" + e[o + 1] + \" = \" + r + \" - \" + e[o] + \" * \" + t : \"index -= \" + e[o] + \" * \" + t) + \";\";\n  }).join(\"\");\n}\n\nfunction buildVec(e) {\n  return 1 === e.length ? \"\" + e[0] : \"vec\" + e.length + \"(\" + e.join(\",\") + \")\";\n}\n\nfunction dotify(e, t) {\n  if (e.length !== t.length) throw new Error(\"Vectors to be dotted must be of the same length -got \" + e.length + \" and \" + t.length);\n\n  for (var r = [], n = Math.floor(e.length / 4), o = e.length % 4, a = 0; a < n; a++) {\n    var i = e.slice(4 * a, 4 * a + 4),\n        s = t.slice(4 * a, 4 * a + 4);\n    r.push(buildVec(i) + \", \" + buildVec(s));\n  }\n\n  if (0 !== o) {\n    i = e.slice(4 * n), s = t.slice(4 * n);\n    1 === i.length && (i = i.map(function (e) {\n      return \"float(\" + e + \")\";\n    }), s = s.map(function (e) {\n      return \"float(\" + e + \")\";\n    })), r.push(buildVec(i) + \", \" + buildVec(s));\n  }\n\n  return r.map(function (e, t) {\n    return \"dot(\" + e + \")\";\n  }).join(\"+\");\n}\n\nfunction makeShader(e, t, r, n, o) {\n  var a = e.map(function (e) {\n    var t = sizeFromShape(e.shapeInfo.logicalShape);\n    return e.shapeInfo.isUniform ? \"uniform float \" + e.name + (t > 1 ? \"[\" + t + \"]\" : \"\") + \";\" : \"uniform sampler2D \" + e.name + \";\";\n  });\n  a = a.join(\"\\n\");\n  var i,\n      s,\n      u = e.map(function (e) {\n    return getInputSamplingSnippet(e, t, n);\n  }).join(\"\\n\"),\n      l = t.texShape,\n      c = SHADER_PREFIX;\n  return t.isPacked ? (i = getPackedOutputSamplingSnippet(t.logicalShape, l), s = FLOAT_TEXTURE_SET_RGBA_SNIPPET) : (i = getOutputSamplingSnippet(t.logicalShape, l), s = FLOAT_TEXTURE_SET_R_SNIPPET), o && (c += SHADER_PACKED_PREFIX), [c, FLOAT_TEXTURE_SAMPLE_SNIPPET, s, a, i, u, r].join(\"\\n\");\n}\n\nfunction getSamplerFromInInfo(e) {\n  var t = e.shapeInfo.logicalShape;\n\n  switch (t.length) {\n    case 0:\n      return getSamplerScalar(e);\n\n    case 1:\n      return getSampler1D(e);\n\n    case 2:\n      return getSampler2D(e);\n\n    case 3:\n      return getSampler3D(e);\n\n    case 4:\n      return getSampler4D(e);\n\n    case 5:\n      return getSampler5D(e);\n\n    case 6:\n      return getSampler6D(e);\n\n    default:\n      throw new Error(t.length + \"-D input sampling is not yet supported\");\n  }\n}\n\nfunction getPackedSamplerFromInInfo(e) {\n  var t = e.shapeInfo.logicalShape;\n\n  switch (t.length) {\n    case 1:\n      return getPackedSampler1D(e);\n\n    case 2:\n      return getPackedSampler2D(e);\n\n    case 3:\n      return getPackedSampler3D(e);\n\n    case 4:\n      return getPackedSampler4D(e);\n\n    default:\n      throw new Error(\"Packed \" + t.length + \"-D input sampling is not yet supported\");\n  }\n}\n\nfunction getInputSamplingSnippet(e, t, r) {\n  var n = getSamplerFlat(e);\n  return e.shapeInfo.isPacked ? n += getPackedSamplerFromInInfo(e) : n += getSamplerFromInInfo(e), (r || arraysEqual(e.shapeInfo.logicalShape, t.logicalShape)) && (n += getSamplerAtOutputCoords(e, t, r)), n;\n}\n\nfunction getPackedOutputSamplingSnippet(e, t) {\n  switch (e.length) {\n    case 0:\n      return getOutputScalarCoords();\n\n    case 1:\n      return getOutputPacked1DCoords(e, t);\n\n    case 2:\n      return getOutputPacked2DCoords(e, t);\n\n    case 3:\n      return getOutputPacked3DCoords(e, t);\n\n    case 4:\n      return getOutputPacked4DCoords(e, t);\n\n    default:\n      throw new Error(e.length + \"-D packed output coordinate fetching is not yet supported\");\n  }\n}\n\nfunction getOutputSamplingSnippet(e, t) {\n  switch (e.length) {\n    case 0:\n      return getOutputScalarCoords();\n\n    case 1:\n      return getOutput1DCoords(e, t);\n\n    case 2:\n      return getOutput2DCoords(e, t);\n\n    case 3:\n      return getOutput3DCoords(e, t);\n\n    case 4:\n      return getOutput4DCoords(e, t);\n\n    case 5:\n      return getOutput5DCoords(e, t);\n\n    case 6:\n      return getOutput6DCoords(e, t);\n\n    default:\n      throw new Error(e.length + \"-D output sampling is not yet supported\");\n  }\n}\n\nvar SAMPLE_1D_SNIPPET = \"\\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\\n  int texelIndex = index / 2;\\n  int texR = texelIndex / texNumC;\\n  int texC = texelIndex - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",\n    SAMPLE_2D_SNIPPET = \"\\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\\n  int index = row * numC + col;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\\n  int texNumC, int row, int col) {\\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\\n  int texR = texelIndex / texNumC;\\n  int texC = texelIndex - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",\n    SAMPLE_3D_SNIPPET = \"\\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\\n    int stride1, int row, int col, int depth) {\\n  // Explicitly use integer operations as dot() only works on floats.\\n  int index = row * stride0 + col * stride1 + depth;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\nvec2 packedUVfrom3D(int texNumR, int texNumC,\\n    int texelsInBatch, int texelsInLogicalRow, int b,\\n    int row, int col) {\\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",\n    SAMPLE_4D_SNIPPET = \"\\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\\n    int stride1, int stride2, int row, int col, int depth,\\n    int depth2) {\\n  // Explicitly use integer operations as dot() only works on floats.\\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\nvec2 packedUVfrom4D(int texNumR, int texNumC, int texelsInBatch2,\\n    int texelsInBatch, int texelsInLogicalRow, int b2, int b,\\n    int row, int col) {\\n  int index = b2 * texelsInBatch2 + b * texelsInBatch +\\n    (row / 2) * texelsInLogicalRow + (col / 2);\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",\n    SAMPLE_5D_SNIPPET = \"\\nvec2 UVfrom5D(int texNumR, int texNumC, int stride0,\\n    int stride1, int stride2, int stride3, int row, int col, int depth,\\n    int depth2, int depth3) {\\n  // Explicitly use integer operations as dot() only works on floats.\\n  int index = row * stride0 + col * stride1 +\\n              depth * stride2 + depth2 * stride3 + depth3;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",\n    SAMPLE_6D_SNIPPET = \"\\nvec2 UVfrom6D(int texNumR, int texNumC, int stride0,\\n    int stride1, int stride2, int stride3, int stride4,\\n    int row, int col, int depth, int depth2, int depth3, int depth4) {\\n  // Explicitly use integer operations as dot() only works on floats.\\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2 *\\n    stride3 + depth3 * stride4 + depth4;\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",\n    FLOAT_TEXTURE_SAMPLE_SNIPPET = \"\\n  float sampleTexture(sampler2D textureSampler, vec2 uv) {\\n    return texture2D(textureSampler, uv).r;\\n  }\\n\",\n    FLOAT_TEXTURE_SET_R_SNIPPET = \"\\n  void setOutput(float val) {\\n    gl_FragColor = vec4(val, 0, 0, 0);\\n  }\\n\",\n    FLOAT_TEXTURE_SET_RGBA_SNIPPET = \"\\n  void setOutput(vec4 val) {\\n    gl_FragColor = val;\\n  }\\n\",\n    SHADER_PREFIX = \"\\n  precision highp float;\\n  precision highp int;\\n  varying vec2 resultUV;\\n  const vec2 halfCR = vec2(0.5, 0.5);\\n\\n  struct ivec5\\n  {\\n    int x;\\n    int y;\\n    int z;\\n    int w;\\n    int u;\\n  };\\n\\n  struct ivec6\\n  {\\n    int x;\\n    int y;\\n    int z;\\n    int w;\\n    int u;\\n    int v;\\n  };\\n\\n  bool isNaN(float val) {\\n    return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\\n  }\\n\\n  bool hasNaN(vec4 values) {\\n    vec4 v1 = values * values;\\n    vec4 v2 = values * values;\\n    return any(notEqual(v1, v2));\\n  }\\n\\n  float getNaN(vec4 values) {\\n    return dot(vec4(1), values);\\n  }\\n\\n  int round(float value) {\\n    return int(floor(value + 0.5));\\n  }\\n\\n  int imod(int x, int y) {\\n    return x - y * (x / y);\\n  }\\n\\n  //Based on the work of Dave Hoskins\\n  //https://www.shadertoy.com/view/4djSRW\\n  #define HASHSCALE1 443.8975\\n  float random(float seed){\\n    vec2 p = resultUV * seed;\\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n  }\\n\\n  \" + SAMPLE_1D_SNIPPET + \"\\n  \" + SAMPLE_2D_SNIPPET + \"\\n  \" + SAMPLE_3D_SNIPPET + \"\\n  \" + SAMPLE_4D_SNIPPET + \"\\n  \" + SAMPLE_5D_SNIPPET + \"\\n  \" + SAMPLE_6D_SNIPPET + \"\\n\",\n    SHADER_PACKED_PREFIX = \"\\n  float getChannel(vec4 frag, vec2 innerDims) {\\n    vec2 modCoord = mod(innerDims, 2.);\\n    return modCoord.x == 0. ?\\n      (modCoord.y == 0. ? frag.r : frag.g) :\\n      (modCoord.y == 0. ? frag.b : frag.a);\\n  }\\n  float getChannel(vec4 frag, int dim) {\\n    float modCoord = mod(float(dim), 2.);\\n    return modCoord == 0. ? frag.r : frag.g;\\n  }\\n\";\n\nfunction getOutputScalarCoords() {\n  return \"\\n    int getOutputCoords() {\\n      return 0;\\n    }\\n  \";\n}\n\nfunction getOutputPacked1DCoords(e, t) {\n  var r = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];\n  return 1 === t[0] ? \"\\n      int getOutputCoords() {\\n        return 2 * int(resultUV.x * \" + r[1] + \".0);\\n      }\\n    \" : 1 === t[1] ? \"\\n      int getOutputCoords() {\\n        return 2 * int(resultUV.y * \" + r[0] + \".0);\\n      }\\n    \" : \"\\n    int getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + r[0] + \", \" + r[1] + \"));\\n      return resTexRC.x * \" + r[1] + \" + resTexRC.y;\\n    }\\n  \";\n}\n\nfunction getOutput1DCoords(e, t) {\n  return 1 === t[0] ? \"\\n      int getOutputCoords() {\\n        return int(resultUV.x * \" + t[1] + \".0);\\n      }\\n    \" : 1 === t[1] ? \"\\n      int getOutputCoords() {\\n        return int(resultUV.y * \" + t[0] + \".0);\\n      }\\n    \" : \"\\n    int getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + t[0] + \", \" + t[1] + \"));\\n      return resTexRC.x * \" + t[1] + \" + resTexRC.y;\\n    }\\n  \";\n}\n\nfunction getOutputPacked3DCoords(e, t) {\n  var r = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)],\n      n = Math.ceil(e[2] / 2),\n      o = n * Math.ceil(e[1] / 2);\n  return \"\\n    ivec3 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + r[0] + \", \" + r[1] + \"));\\n      int index = resTexRC.x * \" + r[1] + \" + resTexRC.y;\\n\\n      int b = index / \" + o + \";\\n      index -= b * \" + o + \";\\n\\n      int r = 2 * (index / \" + n + \");\\n      int c = imod(index, \" + n + \") * 2;\\n\\n      return ivec3(b, r, c);\\n    }\\n  \";\n}\n\nfunction getOutput3DCoords(e, t) {\n  var r = getLogicalCoordinatesFromFlatIndex([\"r\", \"c\", \"d\"], e);\n  return \"\\n    ivec3 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + t[0] + \", \" + t[1] + \"));\\n      int index = resTexRC.x * \" + t[1] + \" + resTexRC.y;\\n      \" + r + \"\\n      return ivec3(r, c, d);\\n    }\\n  \";\n}\n\nfunction getOutputPacked4DCoords(e, t) {\n  var r = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)],\n      n = Math.ceil(e[3] / 2),\n      o = n * Math.ceil(e[2] / 2),\n      a = o * e[1];\n  return \"\\n    ivec4 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + r[0] + \", \" + r[1] + \"));\\n      int index = resTexRC.x * \" + r[1] + \" + resTexRC.y;\\n\\n      int b2 = index / \" + a + \";\\n      index -= b2 * \" + a + \";\\n\\n      int b = index / \" + o + \";\\n      index -= b * \" + o + \";\\n\\n      int r = 2 * (index / \" + n + \");\\n      int c = imod(index, \" + n + \") * 2;\\n\\n      return ivec4(b2, b, r, c);\\n    }\\n  \";\n}\n\nfunction getOutput4DCoords(e, t) {\n  var r = getLogicalCoordinatesFromFlatIndex([\"r\", \"c\", \"d\", \"d2\"], e);\n  return \"\\n    ivec4 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n        vec2(\" + t[0] + \", \" + t[1] + \"));\\n      int index = resTexRC.x * \" + t[1] + \" + resTexRC.y;\\n      \" + r + \"\\n      return ivec4(r, c, d, d2);\\n    }\\n  \";\n}\n\nfunction getOutput5DCoords(e, t) {\n  var r = getLogicalCoordinatesFromFlatIndex([\"r\", \"c\", \"d\", \"d2\", \"d3\"], e);\n  return \"\\n    ivec5 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(\" + t[0] + \",\\n                             \" + t[1] + \"));\\n\\n      int index = resTexRC.x * \" + t[1] + \" + resTexRC.y;\\n\\n      \" + r + \"\\n\\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\\n      return outShape;\\n    }\\n  \";\n}\n\nfunction getOutput6DCoords(e, t) {\n  var r = getLogicalCoordinatesFromFlatIndex([\"r\", \"c\", \"d\", \"d2\", \"d3\", \"d4\"], e);\n  return \"\\n    ivec6 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n        vec2(\" + t[0] + \", \" + t[1] + \"));\\n      int index = resTexRC.x * \" + t[1] + \" + resTexRC.y;\\n\\n      \" + r + \"\\n\\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\\n      return result;\\n    }\\n  \";\n}\n\nfunction getOutputPacked2DCoords(e, t) {\n  var r = [Math.ceil(t[0] / 2), Math.ceil(t[1] / 2)];\n  if (arraysEqual(e, t)) return \"\\n      ivec2 getOutputCoords() {\\n        return 2 * ivec2(resultUV.yx * vec2(\" + r[0] + \", \" + r[1] + \"));\\n      }\\n    \";\n  var n = Math.ceil(e[1] / 2);\n  return \"\\n    ivec2 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + r[0] + \", \" + r[1] + \"));\\n\\n      int index = resTexRC.x * \" + r[1] + \" + resTexRC.y;\\n      int r = 2 * (index / \" + n + \");\\n      int c = imod(index, \" + n + \") * 2;\\n\\n      return ivec2(r, c);\\n    }\\n  \";\n}\n\nfunction getOutput2DCoords(e, t) {\n  return arraysEqual(e, t) ? \"\\n      ivec2 getOutputCoords() {\\n        return ivec2(resultUV.yx * vec2(\" + t[0] + \", \" + t[1] + \"));\\n      }\\n    \" : 1 === e[1] ? \"\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(\" + t[0] + \", \" + t[1] + \"));\\n        int index = resTexRC.x * \" + t[1] + \" + resTexRC.y;\\n        return ivec2(index, 0);\\n      }\\n    \" : 1 === e[0] ? \"\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(\" + t[0] + \", \" + t[1] + \"));\\n        int index = resTexRC.x * \" + t[1] + \" + resTexRC.y;\\n        return ivec2(0, index);\\n      }\\n    \" : \"\\n    ivec2 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + t[0] + \", \" + t[1] + \"));\\n      int index = resTexRC.x * \" + t[1] + \" + resTexRC.y;\\n      int r = index / \" + e[1] + \";\\n      int c = index - r * \" + e[1] + \";\\n      return ivec2(r, c);\\n    }\\n  \";\n}\n\nfunction getSamplerScalar(e) {\n  var t = e.name,\n      r = \"get\" + t.charAt(0).toUpperCase() + t.slice(1);\n  return e.shapeInfo.isUniform ? \"float \" + r + \"() {return \" + t + \";}\" : \"\\n    float \" + r + \"() {\\n      return sampleTexture(\" + t + \", halfCR);\\n    }\\n  \";\n}\n\nfunction getPackedSampler1D(e) {\n  var t = e.name,\n      r = \"get\" + t.charAt(0).toUpperCase() + t.slice(1),\n      n = e.shapeInfo.texShape,\n      o = [Math.ceil(n[0] / 2), Math.ceil(n[1] / 2)];\n  return \"\\n    vec4 \" + r + \"(int index) {\\n      vec2 uv = packedUVfrom1D(\\n        \" + o[0] + \", \" + o[1] + \", index);\\n      return texture2D(\" + t + \", uv);\\n    }\\n  \";\n}\n\nfunction getSampler1D(e) {\n  var t = e.name,\n      r = \"get\" + t.charAt(0).toUpperCase() + t.slice(1);\n  return \"\\n    float \" + r + \"(int index) {\\n      return \" + r + \"Flat(index);\\n    }\\n  \";\n}\n\nfunction getPackedSampler2D(e) {\n  var t = e.shapeInfo.logicalShape,\n      r = e.name,\n      n = \"get\" + r.charAt(0).toUpperCase() + r.slice(1),\n      o = e.shapeInfo.texShape,\n      a = o[0],\n      i = o[1];\n  if (null != o && arraysEqual(t, o)) return \"\\n      vec4 \" + n + \"(int row, int col) {\\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(\" + i + \".0, \" + a + \".0);\\n\\n        return texture2D(\" + r + \", uv);\\n      }\\n    \";\n  var s = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)];\n  return \"\\n    vec4 \" + n + \"(int row, int col) {\\n      vec2 uv = packedUVfrom2D(\" + Math.ceil(t[1] / 2) + \", \" + s[0] + \", \" + s[1] + \", row, col);\\n      return texture2D(\" + r + \", uv);\\n    }\\n  \";\n}\n\nfunction getSampler2D(e) {\n  var t = e.shapeInfo.logicalShape,\n      r = e.name,\n      n = \"get\" + r.charAt(0).toUpperCase() + r.slice(1),\n      o = e.shapeInfo.texShape;\n\n  if (null != o && arraysEqual(t, o)) {\n    var a = o[0];\n    return \"\\n    float \" + n + \"(int row, int col) {\\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(\" + o[1] + \".0, \" + a + \".0);\\n      return sampleTexture(\" + r + \", uv);\\n    }\\n  \";\n  }\n\n  var i = squeezeShape(t),\n      s = i.newShape,\n      u = i.keptDims,\n      l = s;\n\n  if (l.length < t.length) {\n    return \"\\n      \" + getSamplerFromInInfo(squeezeInputInfo(e, l)) + \"\\n      float \" + n + \"(int row, int col) {\\n        return \" + n + \"(\" + getSqueezedParams([\"row\", \"col\"], u) + \");\\n      }\\n    \";\n  }\n\n  if (e.shapeInfo.isUniform) return \"\\n      float \" + n + \"(int row, int col) {\\n        float index = dot(vec2(row, col), vec2(\" + t[1] + \", 1));\\n        return \" + n + \"Flat(round(index));\\n      }\\n    \";\n  var c = o[0],\n      p = o[1];\n  return 1 === p ? \"\\n    float \" + n + \"(int row, int col) {\\n      float index = dot(vec2(row, col), vec2(\" + t[1] + \", 1));\\n      vec2 uv = vec2(0.5, (index + 0.5) / \" + c + \".0);\\n      return sampleTexture(\" + r + \", uv);\\n    }\\n  \" : 1 === c ? \"\\n    float \" + n + \"(int row, int col) {\\n      float index = dot(vec2(row, col), vec2(\" + t[1] + \", 1));\\n      vec2 uv = vec2((index + 0.5) / \" + p + \".0, 0.5);\\n      return sampleTexture(\" + r + \", uv);\\n    }\\n  \" : \"\\n  float \" + n + \"(int row, int col) {\\n    vec2 uv = UVfrom2D(\" + c + \", \" + p + \", \" + t[1] + \", row, col);\\n    return sampleTexture(\" + r + \", uv);\\n  }\\n\";\n}\n\nfunction getPackedSampler3D(e) {\n  var t = e.shapeInfo.logicalShape,\n      r = e.name,\n      n = \"get\" + r.charAt(0).toUpperCase() + r.slice(1),\n      o = e.shapeInfo.texShape,\n      a = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)];\n\n  if (1 === t[0]) {\n    return \"\\n        \" + getPackedSamplerFromInInfo(squeezeInputInfo(e, t.slice(1))) + \"\\n        vec4 \" + n + \"(int b, int row, int col) {\\n          return \" + n + \"(\" + getSqueezedParams([\"b\", \"row\", \"col\"], [1, 2]) + \");\\n        }\\n      \";\n  }\n\n  var i = a[0],\n      s = a[1],\n      u = Math.ceil(t[2] / 2);\n  return \"\\n    vec4 \" + n + \"(int b, int row, int col) {\\n      vec2 uv = packedUVfrom3D(\\n        \" + i + \", \" + s + \", \" + u * Math.ceil(t[1] / 2) + \", \" + u + \", b, row, col);\\n      return texture2D(\" + r + \", uv);\\n    }\\n  \";\n}\n\nfunction getSampler3D(e) {\n  var t = e.shapeInfo.logicalShape,\n      r = e.name,\n      n = \"get\" + r.charAt(0).toUpperCase() + r.slice(1),\n      o = t[1] * t[2],\n      a = t[2],\n      i = squeezeShape(t),\n      s = i.newShape,\n      u = i.keptDims,\n      l = s;\n\n  if (l.length < t.length) {\n    return \"\\n        \" + getSamplerFromInInfo(squeezeInputInfo(e, l)) + \"\\n        float \" + n + \"(int row, int col, int depth) {\\n          return \" + n + \"(\" + getSqueezedParams([\"row\", \"col\", \"depth\"], u) + \");\\n        }\\n      \";\n  }\n\n  if (e.shapeInfo.isUniform) return \"\\n      float \" + n + \"(int row, int col, int depth) {\\n        float index = dot(vec3(row, col, depth),\\n                          vec3(\" + o + \", \" + a + \", 1));\\n        return \" + n + \"Flat(round(index));\\n      }\\n    \";\n  var c = e.shapeInfo.texShape,\n      p = c[0],\n      d = c[1];\n  return d === o ? \"\\n        float \" + n + \"(int row, int col, int depth) {\\n          float texR = float(row);\\n          float texC = dot(vec2(col, depth), vec2(\" + a + \", 1));\\n          vec2 uv = (vec2(texC, texR) + halfCR) /\\n                     vec2(\" + d + \".0, \" + p + \".0);\\n          return sampleTexture(\" + r + \", uv);\\n        }\\n      \" : d === a ? \"\\n    float \" + n + \"(int row, int col, int depth) {\\n      float texR = dot(vec2(row, col), vec2(\" + t[1] + \", 1));\\n      float texC = float(depth);\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + d + \".0, \" + p + \".0);\\n      return sampleTexture(\" + r + \", uv);\\n    }\\n  \" : \"\\n      float \" + n + \"(int row, int col, int depth) {\\n        vec2 uv = UVfrom3D(\\n            \" + p + \", \" + d + \", \" + o + \", \" + a + \", row, col, depth);\\n        return sampleTexture(\" + r + \", uv);\\n      }\\n  \";\n}\n\nfunction getPackedSampler4D(e) {\n  var t = e.shapeInfo.logicalShape,\n      r = e.name,\n      n = \"get\" + r.charAt(0).toUpperCase() + r.slice(1),\n      o = e.shapeInfo.texShape,\n      a = [Math.ceil(o[0] / 2), Math.ceil(o[1] / 2)],\n      i = a[0],\n      s = a[1],\n      u = Math.ceil(t[3] / 2),\n      l = u * Math.ceil(t[2] / 2);\n  return \"\\n    vec4 \" + n + \"(int b2, int b, int row, int col) {\\n      vec2 uv = packedUVfrom4D(\\n        \" + i + \", \" + s + \", \" + l * t[1] + \",\\n        \" + l + \", \" + u + \", b2, b, row, col);\\n      return texture2D(\" + r + \", uv);\\n    }\\n  \";\n}\n\nfunction getSampler4D(e) {\n  var t = e.shapeInfo.logicalShape,\n      r = e.name,\n      n = \"get\" + r.charAt(0).toUpperCase() + r.slice(1),\n      o = t[3],\n      a = t[2] * o,\n      i = t[1] * a,\n      s = squeezeShape(t),\n      u = s.newShape,\n      l = s.keptDims;\n\n  if (u.length < t.length) {\n    return \"\\n      \" + getSamplerFromInInfo(squeezeInputInfo(e, u)) + \"\\n      float \" + n + \"(int row, int col, int depth, int depth2) {\\n        return \" + n + \"(\" + getSqueezedParams([\"row\", \"col\", \"depth\", \"depth2\"], l) + \");\\n      }\\n    \";\n  }\n\n  if (e.shapeInfo.isUniform) return \"\\n      float \" + n + \"(int row, int col, int depth, int depth2) {\\n        float index = dot(vec4(row, col, depth, depth2),\\n                          vec4(\" + i + \", \" + a + \", \" + o + \", 1));\\n        return \" + n + \"Flat(round(index));\\n      }\\n    \";\n  var c = e.shapeInfo.texShape,\n      p = c[0],\n      d = c[1];\n  return d === i ? \"\\n      float \" + n + \"(int row, int col, int depth, int depth2) {\\n        float texR = float(row);\\n        float texC =\\n            dot(vec3(col, depth, depth2), vec3(\" + a + \", \" + o + \", 1));\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + d + \".0, \" + p + \".0);\\n        return sampleTexture(\" + r + \", uv);\\n      }\\n    \" : d === o ? \"\\n      float \" + n + \"(int row, int col, int depth, int depth2) {\\n        float texR = dot(vec3(row, col, depth),\\n                         vec3(\" + t[1] * t[2] + \", \" + t[2] + \", 1));\\n        float texC = float(depth2);\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + d + \".0, \" + p + \".0);\\n        return sampleTexture(\" + r + \", uv);\\n      }\\n    \" : \"\\n    float \" + n + \"(int row, int col, int depth, int depth2) {\\n      vec2 uv = UVfrom4D(\" + p + \", \" + d + \", \" + i + \", \" + a + \",\\n          \" + o + \", row, col, depth, depth2);\\n      return sampleTexture(\" + r + \", uv);\\n    }\\n  \";\n}\n\nfunction getSampler5D(e) {\n  var t = e.shapeInfo.logicalShape,\n      r = e.name,\n      n = \"get\" + r.charAt(0).toUpperCase() + r.slice(1),\n      o = t[4],\n      a = t[3] * o,\n      i = t[2] * a,\n      s = t[1] * i,\n      u = squeezeShape(t),\n      l = u.newShape,\n      c = u.keptDims;\n\n  if (l.length < t.length) {\n    return \"\\n      \" + getSamplerFromInInfo(squeezeInputInfo(e, l)) + \"\\n      float \" + n + \"(int row, int col, int depth, int depth2, int depth3) {\\n        return \" + n + \"(\" + getSqueezedParams([\"row\", \"col\", \"depth\", \"depth2\", \"depth3\"], c) + \");\\n      }\\n    \";\n  }\n\n  if (e.shapeInfo.isUniform) return \"\\n      float \" + n + \"(int row, int col, int depth, int depth2, int depth3) {\\n        float index = dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(\" + s + \", \" + i + \", \" + a + \", \" + o + \")) +\\n          depth3;\\n        return \" + n + \"Flat(index);\\n      }\\n    \";\n  var p = e.shapeInfo.texShape,\n      d = p[0],\n      h = p[1];\n  return h === s ? \"\\n      float \" + n + \"(int row, int col, int depth, int depth2, int depth3) {\\n        int texR = row;\\n        float texC = dot(\\n          vec4(col, depth, depth2, depth3),\\n          vec4(\" + i + \", \" + a + \", \" + o + \", 1));\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + h + \".0, \" + d + \".0);\\n        return sampleTexture(\" + r + \", uv);\\n      }\\n    \" : h === o ? \"\\n      float \" + n + \"(int row, int col, int depth, int depth2, int depth3) {\\n        float texR = dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(\" + t[1] * t[2] * t[3] + \", \" + t[2] * t[3] + \",\\n            \" + t[3] + \", 1));\\n        int texC = depth3;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + h + \".0, \" + d + \".0);\\n        return sampleTexture(\" + r + \", uv);\\n      }\\n    \" : \"\\n    float \" + n + \"(int row, int col, int depth, int depth2, int depth3) {\\n      vec2 uv = UVfrom5D(\" + d + \", \" + h + \", \" + s + \", \" + i + \",\\n          \" + a + \", \" + o + \", row, col, depth, depth2, depth3);\\n      return sampleTexture(\" + r + \", uv);\\n    }\\n  \";\n}\n\nfunction getSampler6D(e) {\n  var t = e.shapeInfo.logicalShape,\n      r = e.name,\n      n = \"get\" + r.charAt(0).toUpperCase() + r.slice(1),\n      o = t[5],\n      a = t[4] * o,\n      i = t[3] * a,\n      s = t[2] * i,\n      u = t[1] * s,\n      l = squeezeShape(t),\n      c = l.newShape,\n      p = l.keptDims;\n\n  if (c.length < t.length) {\n    return \"\\n      \" + getSamplerFromInInfo(squeezeInputInfo(e, c)) + \"\\n      float \" + n + \"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        return \" + n + \"(\" + getSqueezedParams([\"row\", \"col\", \"depth\", \"depth2\", \"depth3\", \"depth4\"], p) + \");\\n      }\\n    \";\n  }\n\n  if (e.shapeInfo.isUniform) return \"\\n      float \" + n + \"(int row, int col, int depth,\\n                  int depth2, int depth3, int depth4) {\\n        float index = dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(\" + u + \", \" + s + \", \" + i + \", \" + a + \")) +\\n          dot(\\n            vec2(depth3, depth4),\\n            vec2(\" + o + \", 1));\\n        return \" + n + \"Flat(index);\\n      }\\n    \";\n  var d = e.shapeInfo.texShape,\n      h = d[0],\n      f = d[1];\n  return f === u ? \"\\n      float \" + n + \"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        int texR = row;\\n        float texC = dot(\\n          vec4(col, depth, depth2, depth3),\\n          vec4(\" + s + \", \" + i + \", \" + a + \", \" + o + \")) + depth4;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(\" + f + \".0, \" + h + \".0);\\n        return sampleTexture(\" + r + \", uv);\\n      }\\n    \" : f === o ? \"\\n      float \" + n + \"(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        float texR = dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(\" + t[1] * t[2] * t[3] * t[4] + \",\\n               \" + t[2] * t[3] * t[4] + \",\\n               \" + t[3] * t[4] + \",\\n               \" + t[4] + \")) + depth3;\\n        int texC = depth4;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(\" + f + \".0, \" + h + \".0);\\n        return sampleTexture(\" + r + \", uv);\\n      }\\n    \" : \"\\n    float \" + n + \"(int row, int col, int depth,\\n                  int depth2, int depth3, int depth4) {\\n      vec2 uv = UVfrom6D(\" + h + \", \" + f + \", \" + u + \", \" + s + \",\\n          \" + i + \", \" + a + \", \" + o + \"\\n          ,row, col, depth, depth2, depth3, depth4);\\n      return sampleTexture(\" + r + \", uv);\\n    }\\n  \";\n}\n\nfunction getSamplerFlat(e) {\n  var t = e.name,\n      r = \"get\" + t.charAt(0).toUpperCase() + t.slice(1) + \"Flat\",\n      n = sizeFromShape(e.shapeInfo.logicalShape);\n  if (e.shapeInfo.isUniform) return 1 === n ? \"float \" + r + \"(int index) {return \" + t + \";}\" : \"\\n      float \" + r + \"(int index) {\\n        for (int i = 0; i < \" + n + \"; i++) {\\n          if (i == index) {\\n            return \" + t + \"[i];\\n          }\\n        }\\n      }\\n    \";\n  var o = e.shapeInfo.texShape,\n      a = o[0],\n      i = o[1];\n  return 1 === i && 1 === a ? \"\\n      float \" + r + \"(int index) {\\n        return sampleTexture(\" + t + \", halfCR);\\n      }\\n    \" : 1 === i ? \"\\n      float \" + r + \"(int index) {\\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / \" + a + \".0);\\n        return sampleTexture(\" + t + \", uv);\\n      }\\n    \" : 1 === a ? \"\\n      float \" + r + \"(int index) {\\n        vec2 uv = vec2((float(index) + 0.5) / \" + i + \".0, 0.5);\\n        return sampleTexture(\" + t + \", uv);\\n      }\\n    \" : \"\\n    float \" + r + \"(int index) {\\n      vec2 uv = UVfrom1D(\" + a + \", \" + i + \", index);\\n      return sampleTexture(\" + t + \", uv);\\n    }\\n  \";\n}\n\nfunction getBroadcastOutputCoordsSampler(e, t, r, n) {\n  var o = e.shapeInfo.logicalShape.length,\n      a = t.logicalShape.length,\n      i = \"int\";\n  2 === a ? i = \"ivec2\" : 3 === a ? i = \"ivec3\" : 4 === a && (i = \"ivec4\");\n  var s = getBroadcastDims(e.shapeInfo.logicalShape, t.logicalShape),\n      u = a - o;\n  return \"\\n    float \" + n + \"() {\\n      \" + i + \" coords = getOutputCoords();\\n      \" + (0 === o ? \"\" : a < 2 && s.length >= 1 ? \"coords = 0;\" : s.map(function (e) {\n    return \"coords[\" + (e + u) + \"] = 0;\";\n  }).join(\"\\n\")) + \"\\n      return get\" + r + \"(\" + (a < 2 && o > 0 ? \"coords\" : e.shapeInfo.logicalShape.map(function (e, t) {\n    return \"coords[\" + (t + u) + \"]\";\n  }).join(\", \")) + \");\\n    }\\n  \";\n}\n\nfunction getSamplerAtOutputCoords(e, t, r) {\n  var n = e.name,\n      o = n.charAt(0).toUpperCase() + n.slice(1),\n      a = \"get\" + o + \"AtOutCoords\",\n      i = getBroadcastDims(e.shapeInfo.logicalShape, t.logicalShape),\n      s = e.shapeInfo.logicalShape.length,\n      u = t.logicalShape.length,\n      l = r && (u > s || i.length > 0),\n      c = broadcastDimsAreOuter(i),\n      p = e.shapeInfo.isUniform;\n  if (l && !c) return getBroadcastOutputCoordsSampler(e, t, o, a);\n  var d = sizeFromShape(e.shapeInfo.logicalShape),\n      h = \"\";\n  l && c && (h = \"\\n        int mainPart = index / \" + d + \";\\n        index -= mainPart * \" + d + \";\\n      \");\n  var f = t.texShape;\n  if (p) return 1 === d ? \"float \" + a + \"() {return \" + n + \";}\" : \"\\n      float \" + a + \"() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                              vec2(\" + f[0] + \", \" + f[1] + \"));\\n        int index = resTexRC.x * \" + f[1] + \" + resTexRC.y;\\n        \" + h + \"\\n        return get\" + o + \"Flat(index);\\n      }\\n    \";\n  var m = e.shapeInfo.texShape;\n  return arraysEqual(m, f) ? \"\\n      float \" + a + \"() {\\n        return sampleTexture(\" + n + \", resultUV);\\n      }\\n    \" : \"\\n    float \" + a + \"() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(\" + f[0] + \", \" + f[1] + \"));\\n      int index = resTexRC.x * \" + f[1] + \" + resTexRC.y;\\n      \" + h + \"\\n      int texR = index / \" + m[1] + \";\\n      int texC = index - texR * \" + m[1] + \";\\n      vec2 uv = (vec2(texC, texR) + halfCR) /\\n                 vec2(\" + m[1] + \".0, \" + m[0] + \".0);\\n\\n      return sampleTexture(\" + n + \", uv);\\n    }\\n  \";\n}\n\nfunction getCoordsDataType(e) {\n  if (e <= 1) return \"int\";\n  if (2 === e) return \"ivec2\";\n  if (3 === e) return \"ivec3\";\n  if (4 === e) return \"ivec4\";\n  if (5 === e) return \"ivec5\";\n  if (6 === e) return \"ivec6\";\n  throw Error(\"GPU for rank \" + e + \" is not yet supported\");\n}\n\nfunction squeezeInputInfo(e, t) {\n  var r = JSON.parse(JSON.stringify(e));\n  return r.shapeInfo.logicalShape = t, r;\n}\n\nfunction getSqueezedParams(e, t) {\n  return t.map(function (t) {\n    return e[t];\n  }).join(\", \");\n}\n\nvar CumSumProgram = function () {\n  return function (e, t, r) {\n    this.variableNames = [\"x\"], this.outputShape = e;\n    var n = e.length,\n        o = e[e.length - 1],\n        a = r ? \"<\" : \">\";\n    this.userCode = \"\\n      int getIndex(int i) {\\n        \" + (r ? \"return \" + o + \" -i - 1;\" : \"return i;\") + \"\\n      }\\n\\n      void main() {\\n        \" + getCoordsDataType(n) + \" coords = getOutputCoords();\\n        int end = \" + getFinalCoord(n, \"coords\") + \";\\n        float val = 0.0;\\n        for (int i = \" + o + \" - 1; i >= 0; i -= 1) {\\n          int idx = getIndex(i);\\n          if (idx \" + a + \" end) {\\n            continue;\\n          }\\n          if (idx == end && \" + t + \") {\\n            continue;\\n          }\\n          \" + getFinalCoord(n, \"coords\") + \" = idx;\\n          val += getX(\" + getCoords(n, \"coords\") + \");\\n        }\\n        setOutput(val);\\n      }\\n    \";\n  };\n}();\n\nfunction getCoords(e, t) {\n  if (1 === e) return \"\" + t;\n  if (2 === e) return t + \".x, \" + t + \".y\";\n  if (3 === e) return t + \".x, \" + t + \".y, \" + t + \".z\";\n  if (4 === e) return t + \".x, \" + t + \".y, \" + t + \".z, \" + t + \".w\";\n  throw Error(\"Cumulative sum for rank \" + e + \" is not yet supported\");\n}\n\nfunction getFinalCoord(e, t) {\n  if (1 === e) return \"\" + t;\n  if (2 === e) return t + \".y\";\n  if (3 === e) return t + \".z\";\n  if (4 === e) return t + \".w\";\n  throw Error(\"Cumulative sum for rank \" + e + \" is not yet supported\");\n}\n\nvar DepthToSpaceProgram = function () {\n  function e(e, t, r) {\n    this.variableNames = [\"x\"], this.outputShape = [], this.outputShape = e, this.blockSize = t, this.dataFormat = r, this.userCode = \"\\n    void main() {\\n      ivec4 coords = getOutputCoords();\\n      int b = coords[0];\\n      int h = \" + this.getHeightCoordString() + \";\\n      int w = \" + this.getWidthCoordString() + \";\\n      int d = \" + this.getDepthCoordString() + \";\\n\\n      int in_h = h / \" + t + \";\\n      int offset_h = imod(h, \" + t + \");\\n      int in_w = w / \" + t + \";\\n      int offset_w = imod(w, \" + t + \");\\n      int offset_d = (offset_h * \" + t + \" + offset_w) *\\n        \" + this.getOutputDepthSize() + \";\\n      int in_d = d + offset_d;\\n\\n      float result = \" + this.getInputSamplingString() + \";\\n      setOutput(result);\\n    }\\n  \";\n  }\n\n  return e.prototype.getHeightCoordString = function () {\n    return \"NHWC\" === this.dataFormat ? \"coords[1]\" : \"coords[2]\";\n  }, e.prototype.getWidthCoordString = function () {\n    return \"NHWC\" === this.dataFormat ? \"coords[2]\" : \"coords[3]\";\n  }, e.prototype.getDepthCoordString = function () {\n    return \"NHWC\" === this.dataFormat ? \"coords[3]\" : \"coords[1]\";\n  }, e.prototype.getOutputDepthSize = function () {\n    return \"NHWC\" === this.dataFormat ? this.outputShape[3] : this.outputShape[1];\n  }, e.prototype.getInputSamplingString = function () {\n    return \"NHWC\" === this.dataFormat ? \"getX(b, in_h, in_w, in_d)\" : \"getX(b, in_d, in_h, in_w)\";\n  }, e;\n}(),\n    EncodeFloatProgram = function () {\n  return function (e) {\n    this.variableNames = [\"A\"], this.outputShape = e, this.userCode = \"\\n      const float FLOAT_MAX = 1.70141184e38;\\n      const float FLOAT_MIN = 1.17549435e-38;\\n\\n      lowp vec4 encode_float(highp float v) {\\n        if (isNaN(v)) {\\n          return vec4(255, 255, 255, 255);\\n        }\\n\\n        highp float av = abs(v);\\n\\n        if(av < FLOAT_MIN) {\\n          return vec4(0.0, 0.0, 0.0, 0.0);\\n        } else if(v > FLOAT_MAX) {\\n          return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\\n        } else if(v < -FLOAT_MAX) {\\n          return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\\n        }\\n\\n        highp vec4 c = vec4(0,0,0,0);\\n\\n        highp float e = floor(log2(av));\\n        highp float m = exp2(fract(log2(av))) - 1.0;\\n\\n        c[2] = floor(128.0 * m);\\n        m -= c[2] / 128.0;\\n        c[1] = floor(32768.0 * m);\\n        m -= c[1] / 32768.0;\\n        c[0] = floor(8388608.0 * m);\\n\\n        highp float ebias = e + 127.0;\\n        c[3] = floor(ebias / 2.0);\\n        ebias -= c[3] * 2.0;\\n        c[2] += floor(ebias) * 128.0;\\n\\n        c[3] += 128.0 * step(0.0, -v);\\n\\n        return c / 255.0;\\n      }\\n\\n      void main() {\\n        float x = getAAtOutCoords();\\n        gl_FragColor = encode_float(x);\\n      }\\n    \";\n  };\n}(),\n    COMPLEX_FFT = {\n  REAL: \"return real * expR - imag * expI;\",\n  IMAG: \"return real * expI + imag * expR;\"\n},\n    FFTProgram = function () {\n  return function (e, t, r) {\n    this.variableNames = [\"real\", \"imag\"];\n    var n = t[1];\n    this.outputShape = t;\n    var o = r ? \"2.0 * \" + Math.PI : \"-2.0 * \" + Math.PI,\n        a = r ? n + \".0\" : \"1.0\";\n    this.userCode = \"\\n      const float exponentMultiplier = \" + o + \";\\n\\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\\n        \" + e + \"\\n      }\\n\\n      float mulMatDFT(int batch, int index) {\\n        float indexRatio = float(index) / float(\" + n + \");\\n        float exponentMultiplierTimesIndexRatio =\\n            exponentMultiplier * indexRatio;\\n\\n        float result = 0.0;\\n\\n        for (int i = 0; i < \" + n + \"; i++) {\\n          // x = (-2|2 * PI / N) * index * i;\\n          float x = exponentMultiplierTimesIndexRatio * float(i);\\n          float expR = cos(x);\\n          float expI = sin(x);\\n          float real = getReal(batch, i);\\n          float imag = getImag(batch, i);\\n\\n          result +=\\n              unaryOpComplex(real, expR, imag, expI) / \" + a + \";\\n        }\\n\\n        return result;\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        setOutput(mulMatDFT(coords[0], coords[1]));\\n      }\\n    \";\n  };\n}(),\n    FromPixelsProgram = function () {\n  return function (e) {\n    this.variableNames = [\"A\"];\n    var t = e[0],\n        r = e[1];\n    this.outputShape = e, this.userCode = \"\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n        int texR = coords[0];\\n        int texC = coords[1];\\n        int depth = coords[2];\\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(\" + r + \".0, \" + t + \".0);\\n\\n        vec4 values = texture2D(A, uv);\\n        float value;\\n        if (depth == 0) {\\n          value = values.r;\\n        } else if (depth == 1) {\\n          value = values.g;\\n        } else if (depth == 2) {\\n          value = values.b;\\n        } else if (depth == 3) {\\n          value = values.a;\\n        }\\n\\n        setOutput(floor(value * 255.0 + 0.5));\\n      }\\n    \";\n  };\n}(),\n    GatherProgram = function () {\n  return function (e, t, r) {\n    this.variableNames = [\"A\", \"indices\"];\n    var n = e.slice();\n    n[r] = t, this.outputShape = n, this.rank = n.length;\n    var o = getCoordsDataType(this.rank),\n        a = getSourceCoords(e, r);\n    this.userCode = \"\\n      void main() {\\n        \" + o + \" resRC = getOutputCoords();\\n        setOutput(getA(\" + a + \"));\\n      }\\n    \";\n  };\n}();\n\nfunction getSourceCoords(e, t) {\n  var r = e.length;\n  if (r > 4) throw Error(\"Gather for rank \" + r + \" is not yet supported\");\n  if (1 === r) return \"int(getIndices(resRC))\";\n\n  for (var n = [\"resRC.x\", \"resRC.y\", \"resRC.z\", \"resRC.w\"], o = [], a = 0; a < e.length; a++) {\n    a === t ? o.push(\"int(getIndices(\" + n[a] + \"))\") : o.push(\"\" + n[a]);\n  }\n\n  return o.join();\n}\n\nvar TextureUsage,\n    PhysicalTextureType,\n    GatherNDProgram = function () {\n  return function (e, t, r) {\n    this.sliceDim = e, this.strides = t, this.variableNames = [\"x\", \"indices\"], this.outputShape = r;\n    var n = getCoordsDataType(t.length),\n        o = getCoordsDataType(r.length),\n        a = this.sliceDim > 1 ? \"strides[j]\" : \"strides\";\n    this.userCode = \"\\n        \" + n + \" strides = \" + n + \"(\" + this.strides + \");\\n         void main() {\\n          \" + o + \" coords = getOutputCoords();\\n          int flattenIndex = 0;\\n          for (int j = 0; j < \" + this.sliceDim + \"; j++) {\\n            int index = round(getIndices(coords[0], j));\\n            flattenIndex += index * \" + a + \";\\n          }\\n          setOutput(getX(flattenIndex, coords[1]));\\n        }\\n      \";\n  };\n}();\n\nfunction getUnpackedMatrixTextureShapeWidthHeight(e, t) {\n  return [t, e];\n}\n\nfunction getUnpackedArraySizeFromMatrixSize(e, t) {\n  return e * t;\n}\n\nfunction getMatrixSizeFromUnpackedArraySize(e, t) {\n  if (e % t != 0) throw new Error(\"unpackedSize (\" + e + \") must be a multiple of \" + t);\n  return e / t;\n}\n\nfunction encodeMatrixToUnpackedArray(e, t, r) {\n  var n = getUnpackedArraySizeFromMatrixSize(e.length, r);\n  if (t.length < n) throw new Error(\"unpackedArray length (\" + t.length + \") must be >= \" + n);\n\n  for (var o = 0, a = 0; a < e.length; ++a) {\n    t[o] = e[a], o += r;\n  }\n}\n\nfunction decodeMatrixFromUnpackedArray(e, t, r) {\n  var n = getMatrixSizeFromUnpackedArraySize(e.length, r);\n  if (t.length < n) throw new Error(\"matrix length (\" + t.length + \") must be >= \" + n);\n\n  for (var o = 0, a = 0; a < e.length; a += r) {\n    t[o++] = e[a];\n  }\n}\n\nfunction getPackedMatrixTextureShapeWidthHeight(e, t) {\n  return [Math.ceil(t / 2), Math.ceil(e / 2)];\n}\n\nfunction getPackedRGBAArraySizeFromMatrixShape(e, t) {\n  var r = getPackedMatrixTextureShapeWidthHeight(e, t);\n  return r[0] * r[1] * 4;\n}\n\nfunction encodeMatrixToPackedRGBA(e, t, r, n, o) {\n  var a = getPackedRGBAArraySizeFromMatrixShape(r, n);\n  if (o.length < a) throw new Error(\"packedRGBA length (\" + o.length + \") must be >=\\n        \" + a);\n\n  for (var i = n % 2 == 1, s = r % 2 == 1, u = Math.floor(n / 2), l = Math.floor(r / 2), c = Math.ceil(n / 2), p = c * Math.ceil(r / 2), d = nearestLargerEven(r) * nearestLargerEven(n), h = 0; h < t; h++) {\n    for (var f = h * r * n, m = h * d, g = i ? 4 : 0, v = n, y = m, x = 0; x < l; ++x) {\n      for (var T = 2 * x * n, E = 0; E < u; ++E) {\n        var w = f + T + 2 * E;\n        o[y] = e[w], o[y + 1] = e[w + 1], o[y + 2] = e[w + v], o[y + 3] = e[w + v + 1], y += 4;\n      }\n\n      y += g;\n    }\n\n    if (i) {\n      w = f + n - 1, y = m + 4 * (c - 1);\n      var S = 2 * n;\n\n      for (g = 4 * c, x = 0; x < l; ++x) {\n        o[y] = e[w], o[y + 2] = e[w + n], w += S, y += g;\n      }\n    }\n\n    if (s) {\n      for (w = f + (r - 1) * n, y = m + 4 * (p - c), E = 0; E < u; ++E) {\n        o[y++] = e[w++], o[y++] = e[w++], y += 2;\n      }\n\n      i && s && (o[m + d - 4] = e[w]);\n    }\n  }\n\n  return o;\n}\n\nfunction decodeMatrixFromPackedRGBA(e, t, r, n, o) {\n  var a = r * n;\n  if (o.length < a) throw new Error(\"matrix length (\" + o.length + \") must be >= \" + a);\n\n  for (var i = n % 2 == 1, s = r % 2 == 1, u = Math.floor(n / 2), l = Math.floor(r / 2), c = Math.ceil(n / 2), p = c * Math.ceil(r / 2), d = nearestLargerEven(r) * nearestLargerEven(n), h = 0; h < t; h++) {\n    for (var f = h * r * n, m = h * d, g = i ? 4 : 0, v = n + (i ? 1 : 0), y = m, x = f, T = f + n, E = 0; E < l; ++E) {\n      for (var w = 0; w < u; ++w) {\n        o[x++] = e[y++], o[x++] = e[y++], o[T++] = e[y++], o[T++] = e[y++];\n      }\n\n      y += g, x += v, T += v;\n    }\n\n    if (i) {\n      y = m + 4 * (c - 1);\n      var S = f + n - 1;\n\n      for (g = 4 * c, v = 2 * n, E = 0; E < l; ++E) {\n        o[S] = e[y], o[S + n] = e[y + 2], y += g, S += v;\n      }\n    }\n\n    if (s) {\n      for (y = m + 4 * (p - c), S = f + (r - 1) * n, w = 0; w < u; ++w) {\n        o[S++] = e[y++], o[S++] = e[y++], y += 2;\n      }\n\n      i && (o[f + r * n - 1] = e[y]);\n    }\n  }\n\n  return o;\n}\n\nfunction callAndCheck(e, t) {\n  var r = t();\n  return checkWebGLError(e), r;\n}\n\n!function (e) {\n  e[e.RENDER = 0] = \"RENDER\", e[e.UPLOAD = 1] = \"UPLOAD\", e[e.PIXELS = 2] = \"PIXELS\", e[e.DOWNLOAD = 3] = \"DOWNLOAD\";\n}(TextureUsage || (TextureUsage = {})), function (e) {\n  e[e.UNPACKED_FLOAT16 = 0] = \"UNPACKED_FLOAT16\", e[e.UNPACKED_FLOAT32 = 1] = \"UNPACKED_FLOAT32\", e[e.PACKED_4X1_UNSIGNED_BYTE = 2] = \"PACKED_4X1_UNSIGNED_BYTE\", e[e.PACKED_2X2_FLOAT32 = 3] = \"PACKED_2X2_FLOAT32\", e[e.PACKED_2X2_FLOAT16 = 4] = \"PACKED_2X2_FLOAT16\";\n}(PhysicalTextureType || (PhysicalTextureType = {}));\nvar webGLDebugErrorCheckingEnabled = !1;\n\nfunction enableDebugWebGLErrorChecking(e) {\n  webGLDebugErrorCheckingEnabled = e;\n}\n\nfunction checkWebGLError(e) {\n  if (webGLDebugErrorCheckingEnabled) {\n    var t = e.getError();\n    if (t !== e.NO_ERROR) throw new Error(\"WebGL Error: \" + getWebGLErrorMessage(e, t));\n  }\n}\n\nfunction getWebGLErrorMessage(e, t) {\n  switch (t) {\n    case e.NO_ERROR:\n      return \"NO_ERROR\";\n\n    case e.INVALID_ENUM:\n      return \"INVALID_ENUM\";\n\n    case e.INVALID_VALUE:\n      return \"INVALID_VALUE\";\n\n    case e.INVALID_OPERATION:\n      return \"INVALID_OPERATION\";\n\n    case e.INVALID_FRAMEBUFFER_OPERATION:\n      return \"INVALID_FRAMEBUFFER_OPERATION\";\n\n    case e.OUT_OF_MEMORY:\n      return \"OUT_OF_MEMORY\";\n\n    case e.CONTEXT_LOST_WEBGL:\n      return \"CONTEXT_LOST_WEBGL\";\n\n    default:\n      return \"Unknown error code \" + t;\n  }\n}\n\nfunction getExtensionOrThrow(e, t) {\n  return throwIfNull(e, function () {\n    return e.getExtension(t);\n  }, 'Extension \"' + t + '\" not supported on this browser.');\n}\n\nfunction createVertexShader(e, t) {\n  var r = throwIfNull(e, function () {\n    return e.createShader(e.VERTEX_SHADER);\n  }, \"Unable to create vertex WebGLShader.\");\n  if (callAndCheck(e, function () {\n    return e.shaderSource(r, t);\n  }), callAndCheck(e, function () {\n    return e.compileShader(r);\n  }), !1 === e.getShaderParameter(r, e.COMPILE_STATUS)) throw console.log(e.getShaderInfoLog(r)), new Error(\"Failed to compile vertex shader.\");\n  return r;\n}\n\nfunction createFragmentShader(e, t) {\n  var r = throwIfNull(e, function () {\n    return e.createShader(e.FRAGMENT_SHADER);\n  }, \"Unable to create fragment WebGLShader.\");\n  if (callAndCheck(e, function () {\n    return e.shaderSource(r, t);\n  }), callAndCheck(e, function () {\n    return e.compileShader(r);\n  }), !1 === e.getShaderParameter(r, e.COMPILE_STATUS)) throw logShaderSourceAndInfoLog(t, e.getShaderInfoLog(r)), new Error(\"Failed to compile fragment shader.\");\n  return r;\n}\n\nvar lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\n\nfunction logShaderSourceAndInfoLog(e, t) {\n  var r = lineNumberRegex.exec(t);\n  if (null == r) return console.log(\"Couldn't parse line number in error: \" + t), void console.log(e);\n\n  for (var n = +r[1], o = e.split(\"\\n\"), a = o.length.toString().length + 2, i = o.map(function (e, t) {\n    return rightPad((t + 1).toString(), a) + e;\n  }), s = 0, u = 0; u < i.length; u++) {\n    s = Math.max(i[u].length, s);\n  }\n\n  var l = i.slice(0, n - 1),\n      c = i.slice(n - 1, n),\n      p = i.slice(n);\n  console.log(l.join(\"\\n\")), console.log(t.split(\"\\n\")[0]), console.log(\"%c \" + rightPad(c[0], s), \"border:1px solid red; background-color:#e3d2d2; color:#a61717\"), console.log(p.join(\"\\n\"));\n}\n\nfunction createProgram(e) {\n  return throwIfNull(e, function () {\n    return e.createProgram();\n  }, \"Unable to create WebGLProgram.\");\n}\n\nfunction linkProgram(e, t) {\n  if (callAndCheck(e, function () {\n    return e.linkProgram(t);\n  }), !1 === e.getProgramParameter(t, e.LINK_STATUS)) throw console.log(e.getProgramInfoLog(t)), new Error(\"Failed to link vertex and fragment shaders.\");\n}\n\nfunction validateProgram(e, t) {\n  if (callAndCheck(e, function () {\n    return e.validateProgram(t);\n  }), !1 === e.getProgramParameter(t, e.VALIDATE_STATUS)) throw console.log(e.getProgramInfoLog(t)), new Error(\"Shader program validation failed.\");\n}\n\nfunction createStaticVertexBuffer(e, t) {\n  var r = throwIfNull(e, function () {\n    return e.createBuffer();\n  }, \"Unable to create WebGLBuffer\");\n  return callAndCheck(e, function () {\n    return e.bindBuffer(e.ARRAY_BUFFER, r);\n  }), callAndCheck(e, function () {\n    return e.bufferData(e.ARRAY_BUFFER, t, e.STATIC_DRAW);\n  }), r;\n}\n\nfunction createStaticIndexBuffer(e, t) {\n  var r = throwIfNull(e, function () {\n    return e.createBuffer();\n  }, \"Unable to create WebGLBuffer\");\n  return callAndCheck(e, function () {\n    return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, r);\n  }), callAndCheck(e, function () {\n    return e.bufferData(e.ELEMENT_ARRAY_BUFFER, t, e.STATIC_DRAW);\n  }), r;\n}\n\nfunction getNumChannels() {\n  return 2 === ENV.get(\"WEBGL_VERSION\") ? 1 : 4;\n}\n\nfunction createTexture(e) {\n  return throwIfNull(e, function () {\n    return e.createTexture();\n  }, \"Unable to create WebGLTexture.\");\n}\n\nfunction validateTextureSize(e, t) {\n  var r = ENV.get(\"WEBGL_MAX_TEXTURE_SIZE\");\n\n  if (e <= 0 || t <= 0) {\n    var n = \"[\" + e + \"x\" + t + \"]\";\n    throw new Error(\"Requested texture size \" + n + \" is invalid.\");\n  }\n\n  if (e > r || t > r) {\n    n = \"[\" + e + \"x\" + t + \"]\";\n    throw new Error(\"Requested texture size \" + n + \" greater than WebGL maximum on this browser / GPU \" + (\"[\" + r + \"x\" + r + \"]\") + \".\");\n  }\n}\n\nfunction createFramebuffer(e) {\n  return throwIfNull(e, function () {\n    return e.createFramebuffer();\n  }, \"Unable to create WebGLFramebuffer.\");\n}\n\nfunction bindVertexBufferToProgramAttribute(e, t, r, n, o, a, i) {\n  var s = e.getAttribLocation(t, r);\n  return -1 !== s && (callAndCheck(e, function () {\n    return e.bindBuffer(e.ARRAY_BUFFER, n);\n  }), callAndCheck(e, function () {\n    return e.vertexAttribPointer(s, o, e.FLOAT, !1, a, i);\n  }), callAndCheck(e, function () {\n    return e.enableVertexAttribArray(s);\n  }), !0);\n}\n\nfunction bindTextureUnit(e, t, r) {\n  validateTextureUnit(e, r), callAndCheck(e, function () {\n    return e.activeTexture(e.TEXTURE0 + r);\n  }), callAndCheck(e, function () {\n    return e.bindTexture(e.TEXTURE_2D, t);\n  });\n}\n\nfunction unbindTextureUnit(e, t) {\n  validateTextureUnit(e, t), callAndCheck(e, function () {\n    return e.activeTexture(e.TEXTURE0 + t);\n  }), callAndCheck(e, function () {\n    return e.bindTexture(e.TEXTURE_2D, null);\n  });\n}\n\nfunction getProgramUniformLocationOrThrow(e, t, r) {\n  return throwIfNull(e, function () {\n    return e.getUniformLocation(t, r);\n  }, 'uniform \"' + r + '\" not present in program.');\n}\n\nfunction getProgramUniformLocation(e, t, r) {\n  return e.getUniformLocation(t, r);\n}\n\nfunction bindTextureToProgramUniformSampler(e, t, r, n, o) {\n  callAndCheck(e, function () {\n    return bindTextureUnit(e, r, o);\n  }), callAndCheck(e, function () {\n    return e.uniform1i(n, o);\n  });\n}\n\nfunction bindCanvasToFramebuffer(e) {\n  callAndCheck(e, function () {\n    return e.bindFramebuffer(e.FRAMEBUFFER, null);\n  }), callAndCheck(e, function () {\n    return e.viewport(0, 0, e.canvas.width, e.canvas.height);\n  }), callAndCheck(e, function () {\n    return e.scissor(0, 0, e.canvas.width, e.canvas.height);\n  });\n}\n\nfunction bindColorTextureToFramebuffer(e, t, r) {\n  callAndCheck(e, function () {\n    return e.bindFramebuffer(e.FRAMEBUFFER, r);\n  }), callAndCheck(e, function () {\n    return e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0);\n  });\n}\n\nfunction unbindColorTextureFromFramebuffer(e, t) {\n  callAndCheck(e, function () {\n    return e.bindFramebuffer(e.FRAMEBUFFER, t);\n  }), callAndCheck(e, function () {\n    return e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, null, 0);\n  });\n}\n\nfunction validateFramebuffer(e) {\n  var t = e.checkFramebufferStatus(e.FRAMEBUFFER);\n  if (t !== e.FRAMEBUFFER_COMPLETE) throw new Error(\"Error binding framebuffer: \" + getFramebufferErrorMessage(e, t));\n}\n\nfunction getFramebufferErrorMessage(e, t) {\n  switch (t) {\n    case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n      return \"FRAMEBUFFER_INCOMPLETE_ATTACHMENT\";\n\n    case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n      return \"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\";\n\n    case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n      return \"FRAMEBUFFER_INCOMPLETE_DIMENSIONS\";\n\n    case e.FRAMEBUFFER_UNSUPPORTED:\n      return \"FRAMEBUFFER_UNSUPPORTED\";\n\n    default:\n      return \"unknown error \" + t;\n  }\n}\n\nfunction throwIfNull(e, t, r) {\n  var n = callAndCheck(e, function () {\n    return t();\n  });\n  if (null == n) throw new Error(r);\n  return n;\n}\n\nfunction validateTextureUnit(e, t) {\n  var r = e.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1,\n      n = t + e.TEXTURE0;\n  if (n < e.TEXTURE0 || n > r) throw new Error(\"textureUnit must be in \" + (\"[gl.TEXTURE0, gl.TEXTURE\" + r + \"]\") + \".\");\n}\n\nfunction getTextureShapeFromLogicalShape(e, t) {\n  void 0 === t && (t = !1);\n  var r = ENV.get(\"WEBGL_MAX_TEXTURE_SIZE\");\n\n  if (t && (r *= 2, e = e.map(function (t, r) {\n    return r >= e.length - 2 ? nearestLargerEven(e[r]) : e[r];\n  })), 2 !== e.length) {\n    var n = squeezeShape(e);\n    e = n.newShape;\n  }\n\n  var o = sizeFromShape(e);\n  return e.length <= 1 && o <= r ? [1, o] : 2 === e.length && e[0] <= r && e[1] <= r ? e : 3 === e.length && e[0] * e[1] <= r && e[2] <= r ? [e[0] * e[1], e[2]] : 3 === e.length && e[0] <= r && e[1] * e[2] <= r ? [e[0], e[1] * e[2]] : 4 === e.length && e[0] * e[1] * e[2] <= r && e[3] <= r ? [e[0] * e[1] * e[2], e[3]] : 4 === e.length && e[0] <= r && e[1] * e[2] * e[3] <= r ? [e[0], e[1] * e[2] * e[3]] : sizeToSquarishShape(o);\n}\n\nfunction isEven(e) {\n  return e % 2 == 0;\n}\n\nfunction isReshapeFree(e, t) {\n  if (arraysEqual(e = e.slice(-2), t = t.slice(-2))) return !0;\n  if (!e.length || !t.length) return !0;\n  if (0 === e[0] || 0 === e[1] || 0 === t[0] || 0 === t[1]) return !0;\n\n  if (e.length !== t.length) {\n    var r = e.slice(-1)[0],\n        n = t.slice(-1)[0];\n    if (r === n) return !0;\n    if (isEven(r) && isEven(n) && (1 === e[0] || 1 === t[0])) return !0;\n  } else if (isEven(e[0]) && isEven(t[0])) {\n    if (isEven(e[1]) && isEven(t[1])) return !0;\n    if (e[1] === t[1]) return !0;\n  }\n\n  return !1;\n}\n\nvar webgl_util = Object.freeze({\n  callAndCheck: callAndCheck,\n  enableDebugWebGLErrorChecking: enableDebugWebGLErrorChecking,\n  checkWebGLError: checkWebGLError,\n  getWebGLErrorMessage: getWebGLErrorMessage,\n  getExtensionOrThrow: getExtensionOrThrow,\n  createVertexShader: createVertexShader,\n  createFragmentShader: createFragmentShader,\n  createProgram: createProgram,\n  linkProgram: linkProgram,\n  validateProgram: validateProgram,\n  createStaticVertexBuffer: createStaticVertexBuffer,\n  createStaticIndexBuffer: createStaticIndexBuffer,\n  getNumChannels: getNumChannels,\n  createTexture: createTexture,\n  validateTextureSize: validateTextureSize,\n  createFramebuffer: createFramebuffer,\n  bindVertexBufferToProgramAttribute: bindVertexBufferToProgramAttribute,\n  bindTextureUnit: bindTextureUnit,\n  unbindTextureUnit: unbindTextureUnit,\n  getProgramUniformLocationOrThrow: getProgramUniformLocationOrThrow,\n  getProgramUniformLocation: getProgramUniformLocation,\n  bindTextureToProgramUniformSampler: bindTextureToProgramUniformSampler,\n  bindCanvasToFramebuffer: bindCanvasToFramebuffer,\n  bindColorTextureToFramebuffer: bindColorTextureToFramebuffer,\n  unbindColorTextureFromFramebuffer: unbindColorTextureFromFramebuffer,\n  validateFramebuffer: validateFramebuffer,\n  getFramebufferErrorMessage: getFramebufferErrorMessage,\n  getTextureShapeFromLogicalShape: getTextureShapeFromLogicalShape,\n  isReshapeFree: isReshapeFree\n});\n\nfunction createVertexShader$1(e) {\n  return createVertexShader(e, \"\\n    precision highp float;\\n    attribute vec3 clipSpacePos;\\n    attribute vec2 uv;\\n    varying vec2 resultUV;\\n\\n    void main() {\\n      gl_Position = vec4(clipSpacePos, 1);\\n      resultUV = uv;\\n    }\");\n}\n\nfunction createVertexBuffer(e) {\n  return createStaticVertexBuffer(e, new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]));\n}\n\nfunction createIndexBuffer(e) {\n  return createStaticIndexBuffer(e, new Uint16Array([0, 1, 2, 2, 1, 3]));\n}\n\nfunction getTextureConfig(e, t) {\n  var r,\n      n,\n      o,\n      a,\n      i,\n      s,\n      u,\n      l = e;\n  return 2 === ENV.get(\"WEBGL_VERSION\") ? (r = l.R32F, n = l.R16F, o = l.RGBA32F, a = l.RED, i = 4, s = 1, u = l.HALF_FLOAT) : (r = e.RGBA, n = e.RGBA, o = l.RGBA, a = e.RGBA, i = 4, s = 4, u = null != t ? t.HALF_FLOAT_OES : null), {\n    internalFormatFloat: r,\n    internalFormatHalfFloat: n,\n    internalFormatPackedFloat: o,\n    textureFormatFloat: a,\n    downloadTextureFormat: e.RGBA,\n    downloadUnpackNumChannels: i,\n    defaultNumChannels: s,\n    textureTypeHalfFloat: u\n  };\n}\n\nfunction createAndConfigureTexture(e, t, r, n, o, a) {\n  validateTextureSize(t, r);\n  var i = createTexture(e),\n      s = e.TEXTURE_2D;\n  return callAndCheck(e, function () {\n    return e.bindTexture(s, i);\n  }), callAndCheck(e, function () {\n    return e.texParameteri(s, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE);\n  }), callAndCheck(e, function () {\n    return e.texParameteri(s, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE);\n  }), callAndCheck(e, function () {\n    return e.texParameteri(s, e.TEXTURE_MIN_FILTER, e.NEAREST);\n  }), callAndCheck(e, function () {\n    return e.texParameteri(s, e.TEXTURE_MAG_FILTER, e.NEAREST);\n  }), callAndCheck(e, function () {\n    return e.texImage2D(s, 0, n, t, r, 0, o, a, null);\n  }), callAndCheck(e, function () {\n    return e.bindTexture(e.TEXTURE_2D, null);\n  }), i;\n}\n\nfunction createFloat32MatrixTexture(e, t, r, n) {\n  var o = getUnpackedMatrixTextureShapeWidthHeight(t, r);\n  return createAndConfigureTexture(e, o[0], o[1], n.internalFormatFloat, n.textureFormatFloat, e.FLOAT);\n}\n\nfunction createFloat16MatrixTexture(e, t, r, n) {\n  var o = getUnpackedMatrixTextureShapeWidthHeight(t, r);\n  return createAndConfigureTexture(e, o[0], o[1], n.internalFormatFloat, n.textureFormatFloat, n.textureTypeHalfFloat);\n}\n\nfunction createUnsignedBytesMatrixTexture(e, t, r, n) {\n  var o = getUnpackedMatrixTextureShapeWidthHeight(t, r);\n  return createAndConfigureTexture(e, o[0], o[1], e.RGBA, e.RGBA, e.UNSIGNED_BYTE);\n}\n\nfunction createPackedMatrixTexture(e, t, r, n) {\n  var o = getPackedMatrixTextureShapeWidthHeight(t, r);\n  return createAndConfigureTexture(e, o[0], o[1], n.internalFormatPackedFloat, e.RGBA, e.FLOAT);\n}\n\nfunction createFloat16PackedMatrixTexture(e, t, r, n) {\n  var o = getPackedMatrixTextureShapeWidthHeight(t, r);\n  return createAndConfigureTexture(e, o[0], o[1], n.internalFormatHalfFloat, e.RGBA, n.textureTypeHalfFloat);\n}\n\nfunction bindVertexProgramAttributeStreams(e, t, r) {\n  return callAndCheck(e, function () {\n    return e.bindBuffer(e.ARRAY_BUFFER, r);\n  }), bindVertexBufferToProgramAttribute(e, t, \"clipSpacePos\", r, 3, 20, 0) && bindVertexBufferToProgramAttribute(e, t, \"uv\", r, 2, 20, 12);\n}\n\nfunction uploadPixelDataToTexture(e, t, r) {\n  callAndCheck(e, function () {\n    return e.bindTexture(e.TEXTURE_2D, t);\n  }), callAndCheck(e, function () {\n    return e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, r);\n  }), callAndCheck(e, function () {\n    return e.bindTexture(e.TEXTURE_2D, null);\n  });\n}\n\nfunction uploadDataToTexture(e, t, r, n, o, a) {\n  validateTextureSize(r, n), callAndCheck(e, function () {\n    return e.bindTexture(e.TEXTURE_2D, t);\n  }), callAndCheck(e, function () {\n    return e.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, r, n, a, e.FLOAT, o);\n  }), callAndCheck(e, function () {\n    return e.bindTexture(e.TEXTURE_2D, null);\n  });\n}\n\nfunction uploadMatrixToTexture(e, t, r, n, o, a, i) {\n  var s,\n      u = getUnpackedMatrixTextureShapeWidthHeight(r, n),\n      l = u[0],\n      c = u[1];\n  1 === i.defaultNumChannels ? s = o : encodeMatrixToUnpackedArray(o, s = new Float32Array(getUnpackedArraySizeFromMatrixSize(o.length, a)), a), uploadDataToTexture(e, t, l, c, s, i.textureFormatFloat);\n}\n\nfunction uploadMatrixToPackedTexture(e, t, r, n, o, a, i, s, u) {\n  var l = getPackedMatrixTextureShapeWidthHeight(a, i),\n      c = l[0],\n      p = l[1],\n      d = new Float32Array(r * getPackedRGBAArraySizeFromMatrixShape(n, o));\n  encodeMatrixToPackedRGBA(s, r, n, o, d), uploadDataToTexture(e, t, c, p, d, e.RGBA);\n}\n\nfunction maybeCreateBufferFromOutputTexture(e, t, r, n, o) {\n  var a = t;\n\n  if (2 === ENV.get(\"WEBGL_VERSION\")) {\n    var i = e,\n        s = i.createBuffer();\n    callAndCheck(e, function () {\n      return e.bindBuffer(i.PIXEL_PACK_BUFFER, s);\n    });\n    var u = 4 * getUnpackedArraySizeFromMatrixSize(r * n, o.downloadUnpackNumChannels);\n    callAndCheck(e, function () {\n      return e.bufferData(i.PIXEL_PACK_BUFFER, u, e.STATIC_DRAW);\n    }), callAndCheck(e, function () {\n      return i.readPixels(0, 0, n, r, e.RGBA, e.FLOAT, 0);\n    }), callAndCheck(e, function () {\n      return e.bindBuffer(i.PIXEL_PACK_BUFFER, null);\n    }), a = s;\n  }\n\n  return a;\n}\n\nfunction downloadFloat32MatrixFromBuffer(e, t, r, n, o) {\n  var a = e,\n      i = new Float32Array(getUnpackedArraySizeFromMatrixSize(r * n, o.downloadUnpackNumChannels));\n  a.bindBuffer(e.ARRAY_BUFFER, t), a.getBufferSubData(e.ARRAY_BUFFER, 0, i), a.bindBuffer(e.ARRAY_BUFFER, null);\n  var s = new Float32Array(r * n);\n  return decodeMatrixFromUnpackedArray(i, s, o.downloadUnpackNumChannels), s;\n}\n\nfunction downloadFloat32MatrixFromOutputTexture(e, t, r, n) {\n  var o = getUnpackedMatrixTextureShapeWidthHeight(t, r),\n      a = o[0],\n      i = o[1],\n      s = new Float32Array(getUnpackedArraySizeFromMatrixSize(t * r, n.downloadUnpackNumChannels));\n  callAndCheck(e, function () {\n    return e.readPixels(0, 0, a, i, n.downloadTextureFormat, e.FLOAT, s);\n  });\n  var u = new Float32Array(t * r);\n  return decodeMatrixFromUnpackedArray(s, u, n.downloadUnpackNumChannels), u;\n}\n\nfunction downloadByteEncodedFloatMatrixFromOutputTexture(e, t, r, n) {\n  var o = getUnpackedMatrixTextureShapeWidthHeight(t, r),\n      a = o[0],\n      i = o[1],\n      s = new Uint8Array(getUnpackedArraySizeFromMatrixSize(t * r, 4));\n  return callAndCheck(e, function () {\n    return e.readPixels(0, 0, a, i, n.downloadTextureFormat, e.UNSIGNED_BYTE, s);\n  }), new Float32Array(s.buffer);\n}\n\nfunction downloadMatrixFromPackedOutputTexture(e, t, r, n, o, a, i) {\n  var s = getPackedMatrixTextureShapeWidthHeight(o, a),\n      u = s[0],\n      l = s[1],\n      c = new Float32Array(getPackedRGBAArraySizeFromMatrixShape(o, a));\n  callAndCheck(e, function () {\n    return e.readPixels(0, 0, u, l, e.RGBA, e.FLOAT, c);\n  });\n  var p = new Float32Array(sizeFromShape([t, r, n]));\n  return decodeMatrixFromPackedRGBA(c, t, r, n, p);\n}\n\nvar gpgpu_util = Object.freeze({\n  createVertexShader: createVertexShader$1,\n  createVertexBuffer: createVertexBuffer,\n  createIndexBuffer: createIndexBuffer,\n  getTextureConfig: getTextureConfig,\n  createFloat32MatrixTexture: createFloat32MatrixTexture,\n  createFloat16MatrixTexture: createFloat16MatrixTexture,\n  createUnsignedBytesMatrixTexture: createUnsignedBytesMatrixTexture,\n  createPackedMatrixTexture: createPackedMatrixTexture,\n  createFloat16PackedMatrixTexture: createFloat16PackedMatrixTexture,\n  bindVertexProgramAttributeStreams: bindVertexProgramAttributeStreams,\n  uploadPixelDataToTexture: uploadPixelDataToTexture,\n  uploadMatrixToTexture: uploadMatrixToTexture,\n  uploadMatrixToPackedTexture: uploadMatrixToPackedTexture,\n  maybeCreateBufferFromOutputTexture: maybeCreateBufferFromOutputTexture,\n  downloadFloat32MatrixFromBuffer: downloadFloat32MatrixFromBuffer,\n  downloadFloat32MatrixFromOutputTexture: downloadFloat32MatrixFromOutputTexture,\n  downloadByteEncodedFloatMatrixFromOutputTexture: downloadByteEncodedFloatMatrixFromOutputTexture,\n  downloadMatrixFromPackedOutputTexture: downloadMatrixFromPackedOutputTexture\n}),\n    GPGPUContext = function () {\n  function e(e) {\n    this.outputTexture = null, this.program = null, this.disposed = !1, this.autoDebugValidate = !1, this.vertexAttrsAreBound = !1, this.itemsToPoll = [], this.gl = null != e ? e : getWebGLContext(ENV.get(\"WEBGL_VERSION\")), 1 === ENV.get(\"WEBGL_VERSION\") ? (this.textureFloatExtension = getExtensionOrThrow(this.gl, \"OES_texture_float\"), this.colorBufferFloatExtension = this.gl.getExtension(\"WEBGL_color_buffer_float\"), ENV.get(\"WEBGL_RENDER_FLOAT32_ENABLED\") || (this.textureHalfFloatExtension = getExtensionOrThrow(this.gl, \"OES_texture_half_float\"), this.colorBufferHalfFloatExtension = this.gl.getExtension(\"EXT_color_buffer_half_float\"))) : this.colorBufferFloatExtension = getExtensionOrThrow(this.gl, \"EXT_color_buffer_float\"), this.vertexBuffer = createVertexBuffer(this.gl), this.indexBuffer = createIndexBuffer(this.gl), this.framebuffer = createFramebuffer(this.gl), this.textureConfig = getTextureConfig(this.gl, this.textureHalfFloatExtension);\n  }\n\n  return e.prototype.dispose = function () {\n    var e = this;\n\n    if (!this.disposed) {\n      null != this.program && console.warn(\"Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing.\"), null != this.outputTexture && console.warn(\"Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.\");\n      var t = this.gl;\n      callAndCheck(t, function () {\n        return t.finish();\n      }), callAndCheck(t, function () {\n        return t.bindFramebuffer(t.FRAMEBUFFER, null);\n      }), callAndCheck(t, function () {\n        return t.deleteFramebuffer(e.framebuffer);\n      }), callAndCheck(t, function () {\n        return t.bindBuffer(t.ARRAY_BUFFER, null);\n      }), callAndCheck(t, function () {\n        return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, null);\n      }), callAndCheck(t, function () {\n        return t.deleteBuffer(e.indexBuffer);\n      }), this.disposed = !0;\n    }\n  }, e.prototype.enableAutomaticDebugValidation = function (e) {\n    this.autoDebugValidate = e, enableDebugWebGLErrorChecking(e);\n  }, e.prototype.createFloat32MatrixTexture = function (e, t) {\n    return this.throwIfDisposed(), createFloat32MatrixTexture(this.gl, e, t, this.textureConfig);\n  }, e.prototype.createFloat16MatrixTexture = function (e, t) {\n    return this.throwIfDisposed(), createFloat16MatrixTexture(this.gl, e, t, this.textureConfig);\n  }, e.prototype.createUnsignedBytesMatrixTexture = function (e, t) {\n    return this.throwIfDisposed(), createUnsignedBytesMatrixTexture(this.gl, e, t, this.textureConfig);\n  }, e.prototype.uploadPixelDataToTexture = function (e, t) {\n    this.throwIfDisposed(), uploadPixelDataToTexture(this.gl, e, t);\n  }, e.prototype.createFloat16PackedMatrixTexture = function (e, t) {\n    return this.throwIfDisposed(), createFloat16PackedMatrixTexture(this.gl, e, t, this.textureConfig);\n  }, e.prototype.createPackedMatrixTexture = function (e, t) {\n    return this.throwIfDisposed(), createPackedMatrixTexture(this.gl, e, t, this.textureConfig);\n  }, e.prototype.deleteMatrixTexture = function (e) {\n    var t = this;\n    this.throwIfDisposed(), this.outputTexture === e && (unbindColorTextureFromFramebuffer(this.gl, this.framebuffer), this.outputTexture = null), callAndCheck(this.gl, function () {\n      return t.gl.deleteTexture(e);\n    });\n  }, e.prototype.uploadMatrixToTexture = function (e, t, r, n) {\n    this.throwIfDisposed();\n    var o = getNumChannels();\n    return uploadMatrixToTexture(this.gl, e, t, r, n, o, this.textureConfig);\n  }, e.prototype.uploadMatrixToPackedTexture = function (e, t, r, n, o, a, i) {\n    return this.throwIfDisposed(), uploadMatrixToPackedTexture(this.gl, e, t, r, n, o, a, i, this.textureConfig);\n  }, e.prototype.downloadFloat32MatrixFromOutputTexture = function (e, t, r) {\n    var n = this;\n    return this.downloadMatrixDriver(e, function () {\n      return downloadFloat32MatrixFromOutputTexture(n.gl, t, r, n.textureConfig);\n    });\n  }, e.prototype.downloadByteEncodedFloatMatrixFromOutputTexture = function (e, t, r) {\n    var n = this;\n    return this.downloadMatrixDriver(e, function () {\n      return downloadByteEncodedFloatMatrixFromOutputTexture(n.gl, t, r, n.textureConfig);\n    });\n  }, e.prototype.downloadFloat32MatrixFromBuffer = function (e, t, r) {\n    return downloadFloat32MatrixFromBuffer(this.gl, e, t, r, this.textureConfig);\n  }, e.prototype.maybeCreateBufferFromTexture = function (e, t, r) {\n    this.bindTextureToFrameBuffer(e);\n    var n = maybeCreateBufferFromOutputTexture(this.gl, e, t, r, this.textureConfig);\n    return this.unbindTextureToFrameBuffer(), n;\n  }, e.prototype.createAndWaitForFence = function () {\n    var e = this.createFence(this.gl);\n    return this.pollFence(e);\n  }, e.prototype.createFence = function (e) {\n    var t,\n        r,\n        n = this;\n\n    if (ENV.get(\"WEBGL_FENCE_API_ENABLED\")) {\n      var o = e,\n          a = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0);\n      e.flush(), r = function r() {\n        var e = o.clientWaitSync(a, 0, 0);\n        return e === o.ALREADY_SIGNALED || e === o.CONDITION_SATISFIED;\n      }, t = a;\n    } else ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") > 0 ? (t = this.beginQuery(), this.endQuery(), r = function r() {\n      return n.isQueryAvailable(t, ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"));\n    }) : r = function r() {\n      return !0;\n    };\n\n    return {\n      query: t,\n      isFencePassed: r\n    };\n  }, e.prototype.downloadMatrixFromPackedTexture = function (e, t, r, n, o, a) {\n    var i = this;\n    return this.downloadMatrixDriver(e, function () {\n      return downloadMatrixFromPackedOutputTexture(i.gl, t, r, n, o, a, i.textureConfig);\n    });\n  }, e.prototype.createProgram = function (e) {\n    this.throwIfDisposed();\n    var t = this.gl,\n        r = createFragmentShader(t, e),\n        n = createVertexShader$1(t),\n        o = createProgram(t);\n    return callAndCheck(t, function () {\n      return t.attachShader(o, n);\n    }), callAndCheck(t, function () {\n      return t.attachShader(o, r);\n    }), linkProgram(t, o), this.autoDebugValidate && validateProgram(t, o), this.vertexAttrsAreBound || (this.setProgram(o), this.vertexAttrsAreBound = bindVertexProgramAttributeStreams(t, this.program, this.vertexBuffer)), o;\n  }, e.prototype.deleteProgram = function (e) {\n    var t = this;\n    this.throwIfDisposed(), e === this.program && (this.program = null), null != e && callAndCheck(this.gl, function () {\n      return t.gl.deleteProgram(e);\n    });\n  }, e.prototype.setProgram = function (e) {\n    var t = this;\n    this.throwIfDisposed(), this.program = e, null != this.program && this.autoDebugValidate && validateProgram(this.gl, this.program), callAndCheck(this.gl, function () {\n      return t.gl.useProgram(e);\n    });\n  }, e.prototype.getUniformLocation = function (e, t, r) {\n    return void 0 === r && (r = !0), this.throwIfDisposed(), r ? getProgramUniformLocationOrThrow(this.gl, e, t) : getProgramUniformLocation(this.gl, e, t);\n  }, e.prototype.getAttributeLocation = function (e, t) {\n    var r = this;\n    return this.throwIfDisposed(), callAndCheck(this.gl, function () {\n      return r.gl.getAttribLocation(e, t);\n    });\n  }, e.prototype.getUniformLocationNoThrow = function (e, t) {\n    return this.throwIfDisposed(), this.gl.getUniformLocation(e, t);\n  }, e.prototype.setInputMatrixTexture = function (e, t, r) {\n    this.throwIfDisposed(), this.throwIfNoProgram(), bindTextureToProgramUniformSampler(this.gl, this.program, e, t, r);\n  }, e.prototype.setOutputMatrixTexture = function (e, t, r) {\n    this.setOutputMatrixTextureDriver(e, r, t);\n  }, e.prototype.setOutputPackedMatrixTexture = function (e, t, r) {\n    this.throwIfDisposed();\n    var n = getPackedMatrixTextureShapeWidthHeight(t, r),\n        o = n[0],\n        a = n[1];\n    this.setOutputMatrixTextureDriver(e, o, a);\n  }, e.prototype.setOutputMatrixWriteRegion = function (e, t, r, n) {\n    this.setOutputMatrixWriteRegionDriver(r, e, n, t);\n  }, e.prototype.setOutputPackedMatrixWriteRegion = function (e, t, r, n) {\n    throw new Error(\"setOutputPackedMatrixWriteRegion not implemented.\");\n  }, e.prototype.debugValidate = function () {\n    null != this.program && validateProgram(this.gl, this.program), validateFramebuffer(this.gl);\n  }, e.prototype.executeProgram = function () {\n    this.throwIfDisposed(), this.throwIfNoProgram();\n    var e = this.gl;\n    this.autoDebugValidate && this.debugValidate(), callAndCheck(e, function () {\n      return e.drawElements(e.TRIANGLES, 6, e.UNSIGNED_SHORT, 0);\n    });\n  }, e.prototype.blockUntilAllProgramsCompleted = function () {\n    var e = this;\n    this.throwIfDisposed(), callAndCheck(this.gl, function () {\n      return e.gl.finish();\n    });\n  }, e.prototype.getQueryTimerExtension = function () {\n    return null == this.disjointQueryTimerExtension && (this.disjointQueryTimerExtension = getExtensionOrThrow(this.gl, 2 === ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") ? \"EXT_disjoint_timer_query_webgl2\" : \"EXT_disjoint_timer_query\")), this.disjointQueryTimerExtension;\n  }, e.prototype.getQueryTimerExtensionWebGL2 = function () {\n    return this.getQueryTimerExtension();\n  }, e.prototype.getQueryTimerExtensionWebGL1 = function () {\n    return this.getQueryTimerExtension();\n  }, e.prototype.beginQuery = function () {\n    if (2 === ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")) {\n      var e = this.gl,\n          t = this.getQueryTimerExtensionWebGL2(),\n          r = e.createQuery();\n      return e.beginQuery(t.TIME_ELAPSED_EXT, r), r;\n    }\n\n    var n = this.getQueryTimerExtensionWebGL1(),\n        o = n.createQueryEXT();\n    return n.beginQueryEXT(n.TIME_ELAPSED_EXT, o), o;\n  }, e.prototype.endQuery = function () {\n    if (2 !== ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\")) {\n      var e = this.getQueryTimerExtensionWebGL1();\n      e.endQueryEXT(e.TIME_ELAPSED_EXT);\n    } else {\n      var t = this.gl,\n          r = this.getQueryTimerExtensionWebGL2();\n      t.endQuery(r.TIME_ELAPSED_EXT);\n    }\n  }, e.prototype.waitForQueryAndGetTime = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t = this;\n      return __generator(this, function (r) {\n        switch (r.label) {\n          case 0:\n            return [4, repeatedTry(function () {\n              return t.disposed || t.isQueryAvailable(e, ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"));\n            })];\n\n          case 1:\n            return r.sent(), [2, this.getQueryTime(e, ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\"))];\n        }\n      });\n    });\n  }, e.prototype.getQueryTime = function (e, t) {\n    if (0 === t) return null;\n\n    if (2 === t) {\n      var r = this.gl;\n      return r.getQueryParameter(e, r.QUERY_RESULT) / 1e6;\n    }\n\n    var n = this.getQueryTimerExtensionWebGL1();\n    return n.getQueryObjectEXT(e, n.QUERY_RESULT_EXT) / 1e6;\n  }, e.prototype.isQueryAvailable = function (e, t) {\n    if (0 === t) return !0;\n\n    if (2 === t) {\n      var r = this.gl,\n          n = this.getQueryTimerExtensionWebGL2(),\n          o = r.getQueryParameter(e, r.QUERY_RESULT_AVAILABLE);\n      return null == this.disjoint && (this.disjoint = this.gl.getParameter(n.GPU_DISJOINT_EXT)), o && !this.disjoint;\n    }\n\n    o = (n = this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(e, n.QUERY_RESULT_AVAILABLE_EXT);\n    return null == this.disjoint && (this.disjoint = this.gl.getParameter(n.GPU_DISJOINT_EXT)), o && !this.disjoint;\n  }, e.prototype.pollFence = function (e) {\n    var t = this;\n    return new Promise(function (r) {\n      t.addItemToPoll(function () {\n        return e.isFencePassed();\n      }, function () {\n        return r();\n      });\n    });\n  }, e.prototype.pollItems = function () {\n    for (var e = binSearchLastTrue(this.itemsToPoll.map(function (e) {\n      return e.isDoneFn;\n    })), t = 0; t <= e; ++t) {\n      (0, this.itemsToPoll[t].resolveFn)();\n    }\n\n    this.itemsToPoll = this.itemsToPoll.slice(e + 1);\n  }, e.prototype.addItemToPoll = function (e, t) {\n    var r = this;\n    this.itemsToPoll.push({\n      isDoneFn: e,\n      resolveFn: t\n    }), this.itemsToPoll.length > 1 || repeatedTry(function () {\n      return r.pollItems(), 0 === r.itemsToPoll.length;\n    });\n  }, e.prototype.bindTextureToFrameBuffer = function (e) {\n    this.throwIfDisposed(), bindColorTextureToFramebuffer(this.gl, e, this.framebuffer), this.autoDebugValidate && validateFramebuffer(this.gl);\n  }, e.prototype.unbindTextureToFrameBuffer = function () {\n    null != this.outputTexture ? (bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer), this.autoDebugValidate && validateFramebuffer(this.gl)) : unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n  }, e.prototype.downloadMatrixDriver = function (e, t) {\n    this.bindTextureToFrameBuffer(e);\n    var r = t();\n    return this.unbindTextureToFrameBuffer(), r;\n  }, e.prototype.setOutputMatrixTextureDriver = function (e, t, r) {\n    this.throwIfDisposed();\n    var n = this.gl;\n    bindColorTextureToFramebuffer(n, e, this.framebuffer), this.autoDebugValidate && validateFramebuffer(n), this.outputTexture = e, callAndCheck(n, function () {\n      return n.viewport(0, 0, t, r);\n    }), callAndCheck(n, function () {\n      return n.scissor(0, 0, t, r);\n    });\n  }, e.prototype.setOutputMatrixWriteRegionDriver = function (e, t, r, n) {\n    var o = this;\n    this.throwIfDisposed(), callAndCheck(this.gl, function () {\n      return o.gl.scissor(e, t, r, n);\n    });\n  }, e.prototype.throwIfDisposed = function () {\n    if (this.disposed) throw new Error(\"Attempted to use disposed GPGPUContext.\");\n  }, e.prototype.throwIfNoProgram = function () {\n    if (null == this.program) throw new Error(\"No GPU program is currently set.\");\n  }, e;\n}();\n\nfunction binSearchLastTrue(e) {\n  for (var t = 0, r = e.length - 1, n = -1; t <= r;) {\n    var o = t + r >> 1;\n    e[o]() ? (n = o, t = o + 1) : r = o - 1;\n  }\n\n  return n;\n}\n\nfunction compileProgram(e, t, r, n) {\n  for (var o = t.userCode, a = r.map(function (e, r) {\n    var n = {\n      logicalShape: e.shape,\n      texShape: e.isUniform ? null : e.texData.texShape,\n      isUniform: e.isUniform,\n      isPacked: !e.isUniform && e.texData.isPacked\n    };\n    return {\n      name: t.variableNames[r],\n      shapeInfo: n\n    };\n  }), i = a.map(function (e) {\n    return e.shapeInfo;\n  }), s = {\n    logicalShape: n.shape,\n    texShape: n.texData.texShape,\n    isUniform: !1,\n    isPacked: n.texData.isPacked\n  }, u = makeShader(a, s, o, !0 === t.supportsBroadcasting, t.usesPackedTextures), l = e.createProgram(u), c = {}, p = 0; p < t.variableNames.length; p++) {\n    var d = t.variableNames[p];\n    c[d] = e.getUniformLocation(l, d, !1);\n  }\n\n  return {\n    program: t,\n    source: u,\n    webGLProgram: l,\n    uniformLocations: c,\n    gpgpu: e,\n    inShapeInfos: i,\n    outShapeInfo: s\n  };\n}\n\nfunction validateBinaryAndProgram(e, t) {\n  if (e.length !== t.length) throw Error(\"Binary was compiled with \" + e.length + \" inputs, but was executed with \" + t.length + \" inputs\");\n  e.forEach(function (e, r) {\n    var n = e.logicalShape,\n        o = t[r],\n        a = o.shape;\n    if (!arraysEqual(n, a)) throw Error(\"Binary was compiled with different shapes than the current args. Shapes \" + n + \" and \" + a + \" must match\");\n\n    if (!e.isUniform || !o.isUniform) {\n      var i = e.texShape,\n          s = o.isUniform ? null : o.texData.texShape;\n      if (!arraysEqual(i, s)) throw Error(\"Binary was compiled with different texture shapes than the current args. Shape \" + i + \" and \" + s + \" must match\");\n    }\n  });\n}\n\nfunction runProgram(e, t, r, n) {\n  validateBinaryAndProgram(e.inShapeInfos, t), validateBinaryAndProgram([e.outShapeInfo], [r]);\n  var o = r.texData.texture,\n      a = r.texData.texShape,\n      i = e.gpgpu;\n  r.texData.isPacked ? i.setOutputPackedMatrixTexture(o, a[0], a[1]) : i.setOutputMatrixTexture(o, a[0], a[1]), i.setProgram(e.webGLProgram), t.forEach(function (t, r) {\n    var n = e.program.variableNames[r],\n        o = e.uniformLocations[n];\n\n    if (null != o) {\n      if (t.isUniform) {\n        if (1 === sizeFromShape(t.shape)) i.gl.uniform1f(o, t.uniformValues[0]);else {\n          var a = t.uniformValues;\n          a instanceof Float32Array || (a = new Float32Array(a)), i.gl.uniform1fv(o, a);\n        }\n        return;\n      }\n\n      var s = t.texData.texture;\n      i.setInputMatrixTexture(s, o, r);\n    }\n  }), null != n && n(i, e.webGLProgram), i.executeProgram();\n}\n\nfunction makeShaderKey(e, t, r) {\n  var n = \"\";\n  t.concat(r).forEach(function (e) {\n    n += e.shape + \"_\" + (e.isUniform ? \"uniform\" : e.texData.texShape);\n  });\n  var o = e.userCode,\n      a = (!0 === e.supportsBroadcasting).toString(),\n      i = e.constructor.name;\n  return i += \"_\" + a + \"_\" + n + \"_\" + o;\n}\n\nvar Im2ColProgram = function () {\n  return function (e, t, r) {\n    this.variableNames = [\"A\"], this.outputShape = e;\n    var n = r.filterWidth,\n        o = r.inChannels,\n        a = r.strideWidth,\n        i = r.strideHeight,\n        s = r.padInfo,\n        u = r.outWidth,\n        l = r.dilationWidth,\n        c = r.dilationHeight,\n        p = s.left,\n        d = s.top,\n        h = o * n;\n    this.userCode = \"\\n      void main() {\\n        ivec2 rc = getOutputCoords();\\n\\n        vec4 result = vec4(0);\\n\\n        for(int row=0; row<=1; row++) {\\n          for(int col=0; col<=1; col++) {\\n            int blockIndex = rc.y + col;\\n            int pos = rc.x + row;\\n\\n            if(blockIndex >= \" + e[1] + \" || pos >= \" + e[0] + \") continue;\\n\\n            int offsetY = int(blockIndex / (\" + u + \")) * \" + i + \" - \" + d + \";\\n            int d0 = offsetY + \" + c + \" * (pos / \" + h + \");\\n\\n            if(d0 >= \" + t[0] + \" || d0 < 0) continue;\\n\\n            int offsetX = int(mod(float(blockIndex), \" + u + \".) * \" + a + \". - \" + p + \".);\\n            int d1 = offsetX + \" + l + \" * (int(mod(float(pos), \" + h + \".) / \" + o + \".));\\n\\n            if(d1 >= \" + t[1] + \" || d1 < 0) continue;\\n\\n            result[row * 2 + col] = getA(d0, d1, int(mod(float(pos), \" + o + \".)));\\n          }\\n        }\\n\\n        gl_FragColor = result;\\n      }\\n    \";\n  };\n}(),\n    LRNProgram = function () {\n  return function (e, t, r, n, o) {\n    this.variableNames = [\"x\"], this.outputShape = [];\n    var a,\n        i = t,\n        s = e[3] - 1;\n    this.outputShape = e;\n    var u = \"float(\" + r + \") + float(\" + n + \") * sum\";\n    a = .5 === o ? \"inversesqrt(\" + u + \")\" : 1 === o ? \"1.0/(\" + u + \")\" : \"exp(log(\" + u + \") * float(-\" + o + \"));\", this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int r = coords[1];\\n        int c = coords[2];\\n        int d = coords[3];\\n        float x = getX(b, r, c, d);\\n        float sum = 0.0;\\n        for (int j = -\" + i + \"; j <= \" + i + \"; j++) {\\n          int idx = d + j;\\n          if (idx >= 0 && idx <=  \" + s + \") {\\n            float z = getX(b, r, c, idx);\\n            sum += z * z;\\n          }\\n        }\\n        float val = x * \" + a + \";\\n        setOutput(val);\\n      }\\n    \";\n  };\n}(),\n    LRNGradProgram = function () {\n  return function (e, t, r, n, o) {\n    this.variableNames = [\"inputImage\", \"outputImage\", \"dy\"], this.outputShape = [], this.outputShape = e, this.depth = e[3], this.depthRadius = t, this.bias = r, this.alpha = n, this.beta = o, this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float result = 0.0;\\n        for (int d = 0; d < \" + this.depth + \"; ++d) {\\n          int depthBegin = int(max(0.0, float(d - \" + t + \")));\\n          int depthEnd = int(min(float(\" + this.depth + \"),\\n              float(d + \" + t + \" + 1)));\\n\\n          const int MIN_DEPTH_BEGIN = 0;\\n          const int MAX_DEPTH_END = \" + this.depth + \";\\n\\n          float norm = 0.0;\\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\\n            if (k < depthBegin){\\n              continue;\\n            }\\n            else if (k >= depthBegin && k < depthEnd) {\\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\\n            }\\n            else {\\n              break;\\n            }\\n          }\\n\\n          norm = float(\" + n + \") * norm + float(\" + r + \");\\n\\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\\n            if (k < depthBegin){\\n              continue;\\n            }\\n            else if (k >= depthBegin && k < depthEnd){\\n              float dyi = -2.0 * float(\" + n + \")\\n                * float(\" + o + \")\\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\\n                / norm;\\n              if (k == d) {\\n                dyi += pow(norm, -1.0 * \" + o + \");\\n              }\\n              if (k == coords[3]) {\\n                dyi *= getDy(b, r, c, d);\\n                result += dyi;\\n              }\\n            }\\n            else {\\n              break;\\n            }\\n          }\\n      }\\n      setOutput(result);\\n      }\\n    \";\n  };\n}(),\n    MaxPool2DBackpropProgram = function () {\n  return function (e) {\n    this.variableNames = [\"dy\", \"maxPos\"], this.outputShape = e.inShape;\n    var t = e.strideHeight,\n        r = e.strideWidth,\n        n = e.dilationHeight,\n        o = e.effectiveFilterHeight,\n        a = e.effectiveFilterWidth,\n        i = o - 1 - e.padInfo.top,\n        s = a - 1 - e.padInfo.left,\n        u = o * a - 1;\n    this.userCode = \"\\n      const ivec2 pads = ivec2(\" + i + \", \" + s + \");\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 dyRCCorner = coords.yz - pads;\\n        int dyRCorner = dyRCCorner.x;\\n        int dyCCorner = dyRCCorner.y;\\n\\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < \" + o + \";\\n          wR += \" + n + \") {\\n          float dyR = float(dyRCorner + wR) / \" + t + \".0;\\n\\n          if (dyR < 0.0 || dyR >= \" + e.outHeight + \".0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          for (int wC = 0; wC < \" + a + \"; wC++) {\\n            float dyC = float(dyCCorner + wC) / \" + r + \".0;\\n\\n            if (dyC < 0.0 || dyC >= \" + e.outWidth + \".0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            float dyValue = getDy(b, idyR, idyC, d);\\n            int maxPosValue = \" + u + \" - int(getMaxPos(b, idyR, idyC, d));\\n\\n            // Get the current value, check it against the value from the\\n            // position matrix.\\n            int curPosValue = wR * \" + a + \" + wC;\\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\\n\\n            dotProd += dyValue * mask;\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    \";\n  };\n}(),\n    MatMulProgram = function () {\n  return function (e, t, r, n) {\n    void 0 === r && (r = !1), void 0 === n && (n = !1), this.variableNames = [\"matrixA\", \"matrixB\"];\n    var o = e[0],\n        a = r ? e[2] : e[1],\n        i = n ? t[1] : t[2],\n        s = r ? e[1] : e[2];\n    this.outputShape = [o, a, i];\n\n    var u = function u(e, t) {\n      return r ? \"batch, \" + t + \" + \" + e + \", aRow\" : \"batch, aRow, \" + t + \" + \" + e;\n    },\n        l = function l(e, t) {\n      return n ? \"batch, bCol, \" + t + \" + \" + e : \"batch, \" + t + \" + \" + e + \", bCol\";\n    },\n        c = 4 * Math.floor(s / 4),\n        p = s % 4;\n\n    this.userCode = \" float dotARowBCol(int batch, int aRow, int bCol) {\\n      float result = 0.0;\\n      for (int i = 0; i < \" + c + \"; i += 4) {\\n        vec4 a = vec4(\\n          getMatrixA(\" + u(0, \"i\") + \"),\\n          getMatrixA(\" + u(1, \"i\") + \"),\\n          getMatrixA(\" + u(2, \"i\") + \"),\\n          getMatrixA(\" + u(3, \"i\") + \")\\n        );\\n        vec4 b = vec4(\\n          getMatrixB(\" + l(0, \"i\") + \"),\\n          getMatrixB(\" + l(1, \"i\") + \"),\\n          getMatrixB(\" + l(2, \"i\") + \"),\\n          getMatrixB(\" + l(3, \"i\") + \")\\n        );\\n\\n        result += dot(a, b);\\n      }\\n\\n      if (\" + (1 === p) + \") {\\n        result += getMatrixA(\" + u(0, c) + \") *\\n          getMatrixB(\" + l(0, c) + \");\\n      } else if (\" + (2 === p) + \") {\\n        vec2 a = vec2(\\n          getMatrixA(\" + u(0, c) + \"),\\n          getMatrixA(\" + u(1, c) + \")\\n        );\\n        vec2 b = vec2(\\n          getMatrixB(\" + l(0, c) + \"),\\n          getMatrixB(\" + l(1, c) + \")\\n        );\\n        result += dot(a, b);\\n      } else if (\" + (3 === p) + \") {\\n        vec3 a = vec3(\\n          getMatrixA(\" + u(0, c) + \"),\\n          getMatrixA(\" + u(1, c) + \"),\\n          getMatrixA(\" + u(2, c) + \")\\n        );\\n        vec3 b = vec3(\\n          getMatrixB(\" + l(0, c) + \"),\\n          getMatrixB(\" + l(1, c) + \"),\\n          getMatrixB(\" + l(2, c) + \")\\n        );\\n        result += dot(a, b);\\n      }\\n\\n      return result;\\n    }\\n\\n    void main() {\\n      ivec3 resBRC = getOutputCoords();\\n      setOutput(dotARowBCol(resBRC.x, resBRC.y, resBRC.z));\\n    }\\n    \";\n  };\n}(),\n    MatMulPackedProgram = function () {\n  return function (e, t, r, n, o) {\n    void 0 === n && (n = !1), void 0 === o && (o = !1), this.variableNames = [\"matrixA\", \"matrixB\"], this.usesPackedTextures = !0, this.outputShape = r;\n    var a = n ? e[0] : e[1],\n        i = Math.ceil(a / 2),\n        s = n ? \"i * 2, rc.x\" : \"rc.x, i * 2\",\n        u = o ? \"rc.y, i * 2\" : \"i * 2, rc.y\",\n        l = n ? [\"a.xxyy\", \"a.zzww\"] : [\"a.xxzz\", \"a.yyww\"],\n        c = o ? [\"b.xzxz\", \"b.ywyw\"] : [\"b.xyxy\", \"b.zwzw\"];\n    this.userCode = \"\\n      const float sharedDimension = \" + i + \".0;\\n\\n      vec4 dot2x2ARowBCol(ivec2 rc) {\\n        vec4 result = vec4(0);\\n        for (int i = 0; i < \" + i + \"; i++) {\\n          vec4 a = getMatrixA(\" + s + \");\\n          vec4 b = getMatrixB(\" + u + \");\\n\\n          result += (\" + l[0] + \" * \" + c[0] + \") + (\" + l[1] + \" * \" + c[1] + \");\\n        }\\n        return result;\\n      }\\n\\n      void main() {\\n        ivec2 rc = getOutputCoords();\\n        setOutput(dot2x2ARowBCol(rc));\\n      }\\n    \";\n  };\n}(),\n    MultinomialProgram = function () {\n  function e(e, t, r) {\n    this.variableNames = [\"probs\"], this.outputShape = [e, r], this.userCode = \"\\n      uniform float seed;\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n\\n        float r = random(seed);\\n        float cdf = 0.0;\\n\\n        for (int i = 0; i < \" + (t - 1) + \"; i++) {\\n          cdf += getProbs(batch, i);\\n\\n          if (r < cdf) {\\n            setOutput(float(i));\\n            return;\\n          }\\n        }\\n\\n        // If no other event happened, last event happened.\\n        setOutput(float(\" + (t - 1) + \"));\\n      }\\n    \";\n  }\n\n  return e.prototype.getCustomSetupFunc = function (e) {\n    var t = this;\n    return function (r, n) {\n      null == t.seedLoc && (t.seedLoc = r.getUniformLocation(n, \"seed\")), r.gl.uniform1f(t.seedLoc, e);\n    };\n  }, e;\n}(),\n    OneHotProgram = function () {\n  return function (e, t, r, n) {\n    this.variableNames = [\"indices\"], this.outputShape = [e, t], this.userCode = \"\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int index = round(getIndices(coords.x));\\n        setOutput(mix(float(\" + n + \"), float(\" + r + \"),\\n                      float(index == coords.y)));\\n      }\\n    \";\n  };\n}();\n\nfunction getVecChannels(e, t) {\n  return [\"x\", \"y\", \"z\", \"w\", \"u\", \"v\"].slice(0, t).map(function (t) {\n    return e + \".\" + t;\n  });\n}\n\nfunction getChannels(e, t) {\n  return 1 === t ? [e] : getVecChannels(e, t);\n}\n\nfunction getSourceCoords$1(e, t) {\n  if (1 === e) return \"rc\";\n\n  for (var r = \"\", n = 0; n < e; n++) {\n    r += t[n], n < e - 1 && (r += \",\");\n  }\n\n  return r;\n}\n\nvar PackProgram = function () {\n  return function (e) {\n    this.variableNames = [\"A\"], this.isPackShader = !0, this.outputShape = e;\n    var t = e.length,\n        r = getChannels(\"rc\", t),\n        n = getCoordsDataType(t),\n        o = getOutOfBoundsCondition(t, e, r),\n        a = getSetup(t, e[e.length - 1], e[e.length - 2], r),\n        i = getOutput(e, r);\n    this.userCode = \"\\n      void main() {\\n        \" + n + \" rc = getOutputCoords();\\n\\n        if(\" + o + \") {\\n          gl_FragColor = vec4(0);\\n        } else {\\n          \" + a + \"\\n\\n          setOutput(vec4(\" + i + \"));\\n        }\\n      }\\n    \";\n  };\n}();\n\nfunction getSourceCoordsArr(e, t) {\n  for (var r = [], n = 0; n <= 1; n++) {\n    for (var o = 0; o <= 1; o++) {\n      for (var a = (0 === n ? \"r\" : \"rp1\") + \", \" + (0 === o ? \"c\" : \"cp1\"), i = 2; i < e; i++) {\n        a = t[t.length - 1 - i] + \",\" + a;\n      }\n\n      r.push(a);\n    }\n  }\n\n  return r;\n}\n\nfunction getOutOfBoundsCondition(e, t, r) {\n  if (1 === e) return \"rc > \" + t[0];\n\n  for (var n = \"\", o = e - 2; o < e; o++) {\n    n += r[o] + \" >= \" + t[o], o < e - 1 && (n += \"||\");\n  }\n\n  return n;\n}\n\nfunction getSetup(e, t, r, n) {\n  if (1 === e) return \"\";\n  var o = n.slice(-2);\n  return \"\\n    int r = \" + o[0] + \";\\n    int c = \" + o[1] + \";\\n    int rp1 = r + 1;\\n    int cp1 = c + 1;\\n\\n    bool cEdge = cp1 >= \" + t + \";\\n    bool rEdge = rp1 >= \" + r + \";\\n  \";\n}\n\nfunction getOutput(e, t) {\n  var r = e.length,\n      n = getSourceCoordsArr(r, t);\n  return 1 === r ? \"getA(rc),\\n            rc + 1 >= \" + e[0] + \" ? 0. : getA(rc + 1),\\n            0, 0\" : \"getA(\" + n[0] + \"),\\n          cEdge ? 0. : getA(\" + n[1] + \"),\\n          rEdge ? 0. : getA(\" + n[2] + \"),\\n          rEdge || cEdge ? 0. : getA(\" + n[3] + \")\";\n}\n\nvar PadProgram = function () {\n  return function (e, t, r) {\n    this.variableNames = [\"x\"], this.outputShape = t.map(function (t, r) {\n      return t[0] + e[r] + t[1];\n    });\n    var n = e.length,\n        o = getCoordsDataType(n),\n        a = t.map(function (e) {\n      return e[0];\n    }).join(\",\"),\n        i = t.map(function (t, r) {\n      return t[0] + e[r];\n    }).join(\",\"),\n        s = [\"coords[0]\", \"coords[1]\", \"coords[2]\", \"coords[3]\"].slice(0, n);\n    this.userCode = 1 !== n ? \"\\n      \" + o + \" start = \" + o + \"(\" + a + \");\\n      \" + o + \" end = \" + o + \"(\" + i + \");\\n\\n      void main() {\\n        \" + o + \" outC = getOutputCoords();\\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\\n          setOutput(float(\" + r + \"));\\n        } else {\\n          \" + o + \" coords = outC - start;\\n          setOutput(getX(\" + s + \"));\\n        }\\n      }\\n    \" : \"\\n        int start = \" + a + \";\\n        int end = \" + i + \";\\n\\n        void main() {\\n          int outC = getOutputCoords();\\n          if (outC < start || outC >= end) {\\n            setOutput(float(\" + r + \"));\\n          } else {\\n            setOutput(getX(outC - start));\\n          }\\n        }\\n      \";\n  };\n}(),\n    Pool2DProgram = function () {\n  return function (e, t, r) {\n    if (this.variableNames = [\"x\"], \"avg\" === t && r) throw new Error(\"Cannot compute positions for average pool.\");\n    var n = e.filterWidth,\n        o = e.strideHeight,\n        a = e.strideWidth,\n        i = e.dilationHeight,\n        s = e.dilationWidth,\n        u = e.effectiveFilterHeight,\n        l = e.effectiveFilterWidth,\n        c = e.padInfo.top,\n        p = e.padInfo.left;\n    this.outputShape = e.outShape;\n    var d = \"avg\" === t,\n        h = \"0.0\";\n    if (d || (h = \"-1.0 / 0.0\"), r) this.userCode = \"\\n        const ivec2 strides = ivec2(\" + o + \", \" + a + \");\\n        const ivec2 pads = ivec2(\" + c + \", \" + p + \");\\n\\n        void main() {\\n          ivec4 coords = getOutputCoords();\\n          int batch = coords[0];\\n          int d = coords[3];\\n\\n          ivec2 xRCCorner = coords.yz * strides - pads;\\n          int xRCorner = xRCCorner.x;\\n          int xCCorner = xRCCorner.y;\\n\\n          // max/min x(?, ?, d) to get y(yR, yC, d).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n          float avgValue = 0.0;\\n\\n          for (int wR = 0; wR < \" + u + \";\\n              wR += \" + i + \") {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= \" + e.inHeight + \") {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < \" + l + \";\\n                wC += \" + s + \") {\\n              int xC = xCCorner + wC;\\n\\n              if (xC < 0 || xC >= \" + e.inWidth + \") {\\n                continue;\\n              }\\n\\n              float value = getX(batch, xR, xC, d);\\n\\n              // If a min / max value has already been found, use it. If not,\\n              // use the current value.\\n              float currMinMaxValue = mix(\\n                  value, minMaxValue, minMaxValueFound);\\n              if (value >= currMinMaxValue) {\\n                minMaxValue = value;\\n                minMaxValueFound = 1.0;\\n                minMaxPosition = wR * \" + l + \" + wC;\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      \";else {\n      var f = t + \"(\" + t + \"(\" + t + \"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])\";\n      \"avg\" === t && (f = \"avgValue / count\");\n      var m = 4 * Math.floor(n / 4),\n          g = n % 4,\n          v = \"\\n      if (\" + d + \") {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = max(values, minMaxValue);\\n      }\\n    \";\n      this.userCode = \"\\n      const ivec2 strides = ivec2(\" + o + \", \" + a + \");\\n      const ivec2 pads = ivec2(\" + c + \", \" + p + \");\\n      const float initializationValue = \" + h + \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float count = 0.0;\\n\\n      float getValue(int batch, int xR, int xC, int d) {\\n        if (xC < 0 || xC >= \" + e.inWidth + \") {\\n          return initializationValue;\\n        }\\n        count += 1.0;\\n        return getX(batch, xR, xC, d);\\n      }\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // max/min x(?, ?, d) to get y(yR, yC, d).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(\" + h + \");\\n        float avgValue = 0.0;\\n        count = 0.0;\\n\\n        for (int wR = 0; wR < \" + u + \";\\n            wR += \" + i + \") {\\n          int xR = xRCorner + wR;\\n\\n          if (xR < 0 || xR >= \" + e.inHeight + \") {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < \" + m + \"; wC += 4) {\\n            int xC = xCCorner + wC * \" + s + \";\\n\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \" + s + \", d),\\n              getValue(batch, xR, xC + 2 * \" + s + \", d),\\n              getValue(batch, xR, xC + 3 * \" + s + \", d)\\n            );\\n\\n            \" + v + \"\\n          }\\n\\n          int xC = xCCorner + \" + m + \";\\n          if (\" + (1 === g) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              initializationValue,\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \" + v + \"\\n          } else if (\" + (2 === g) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \" + s + \", d),\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            \" + v + \"\\n          } else if (\" + (3 === g) + \") {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + \" + s + \", d),\\n              getValue(batch, xR, xC + 2 * \" + s + \", d),\\n              initializationValue\\n            );\\n\\n            \" + v + \"\\n          }\\n        }\\n        setOutput(\" + f + \");\\n      }\\n    \";\n    }\n  };\n}(),\n    ReduceProgram = function () {\n  return function (e, t) {\n    this.variableNames = [\"x\"];\n    var r = e.windowSize,\n        n = e.batchSize,\n        o = e.inSize,\n        a = Math.ceil(o / r);\n    this.outputShape = [n, a];\n    var i = \"0.0\",\n        s = \"\";\n    \"prod\" === t ? i = \"1.0\" : \"min\" === t ? (i = \"1.0 / 0.0\", s = \"min\") : \"max\" === t && (i = \"-1.0 / 0.0\", s = \"max\");\n    var u = t + \"(\" + t + \"(\" + t + \"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])\";\n    \"sum\" === t ? u = \"sumValue\" : \"prod\" === t ? u = \"prodValue\" : \"all\" === t ? u = \"allValue\" : \"any\" === t && (u = \"anyValue\");\n    var l = 4 * Math.floor(r / 4),\n        c = r % 4,\n        p = \"\\n      if (\" + (\"sum\" === t) + \") {\\n        sumValue += dot(values, ones);\\n      } else if (\" + (\"prod\" === t) + \") {\\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\\n        prodValue *= tmp[0] * tmp[1];\\n      } else {\\n        minMaxValue = \" + s + \"(values, minMaxValue);\\n      }\\n    \",\n        d = \"vec4\";\n    \"all\" === t ? (i = \"1.0\", p = \"\\n        bool reducedAllValue = all(values);\\n        float floatedReducedAllValue = float(reducedAllValue);\\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\\n      \", d = \"bvec4\") : \"any\" === t && (i = \"0.0\", p = \"\\n        bool reducedAnyValue = any(values);\\n        float floatedReducedAnyValue = float(reducedAnyValue);\\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\\n      \", d = \"bvec4\");\n    var h = \"\";\n    o % r > 0 && (h = \"\\n        if (inIdx < 0 || inIdx >= \" + o + \") {\\n          return initializationValue;\\n        }\\n      \"), this.userCode = \"\\n      const float initializationValue = \" + i + \";\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float getValue(int batch, int inIdx) {\\n        \" + h + \"\\n        return getX(batch, inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = outIdx * \" + r + \";\\n\\n        vec4 minMaxValue = vec4(\" + i + \");\\n        float prodValue = 1.0;\\n        float sumValue = 0.0;\\n        float allValue = 1.0;\\n        float anyValue = 0.0;\\n\\n        for (int i = 0; i < \" + l + \"; i += 4) {\\n          int inIdx = inOffset + i;\\n          \" + d + \" values = \" + d + \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          \" + p + \"\\n        }\\n\\n        int inIdx = inOffset + \" + l + \";\\n        if (\" + (1 === c) + \") {\\n          \" + d + \" values = \" + d + \"(\\n            getValue(batch, inIdx),\\n            initializationValue,\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          \" + p + \"\\n        } else if (\" + (2 === c) + \") {\\n          \" + d + \" values = \" + d + \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          \" + p + \"\\n        } else if (\" + (3 === c) + \") {\\n          \" + d + \" values = \" + d + \"(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            initializationValue\\n          );\\n\\n          \" + p + \"\\n        }\\n        setOutput(\" + u + \");\\n      }\\n    \";\n  };\n}(),\n    ReshapePackedProgram = function () {\n  return function (e, t) {\n    this.variableNames = [\"A\"], this.usesPackedTextures = !0, this.outputShape = e;\n\n    for (var r = \"\", n = 0; n < 4; n++) {\n      var o = \"thisRC = rc;\";\n      n % 2 == 1 && (o += \"thisRC.z += 1;\"), n > 1 && (o += \"thisRC.y += 1;\"), r += \"\\n        \" + o + \"\\n        \" + (n > 0 ? \"if(thisRC.y < rows && thisRC.z < cols){\" : \"\") + \"\\n          int flatIndex = getFlatIndex(thisRC);\\n\\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\\n\\n          result[\" + n + \"] =\\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\\n        \" + (n > 0 ? \"}\" : \"\") + \"\\n      \";\n    }\n\n    this.userCode = \"\\n      \" + getReshapedInputCoords(t) + \"\\n      \" + getFlatIndex(e) + \"\\n\\n      void main() {\\n        ivec3 rc = getOutputCoords();\\n\\n        vec4 result = vec4(0.);\\n\\n        ivec3 thisRC;\\n        int rows = \" + e[1] + \";\\n        int cols = \" + e[2] + \";\\n\\n        \" + r + \"\\n\\n        setOutput(result);\\n      }\\n    \";\n  };\n}();\n\nfunction getFlatIndex(e) {\n  return \"\\n    int getFlatIndex(ivec3 coords) {\\n      return round(\" + dotify([\"coords.x\", \"coords.y\", \"coords.z\"], computeStrides(e).map(function (e) {\n    return e.toString();\n  }).concat([\"1.\"])) + \");\\n    }\\n  \";\n}\n\nfunction getReshapedInputCoords(e) {\n  return \"\\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\\n      \" + getLogicalCoordinatesFromFlatIndex([\"r\", \"c\", \"d\"], e) + \"\\n      return ivec3(r, c, d);\\n    }\\n  \";\n}\n\nvar ResizeBilinearBackpropProgram = function () {\n  return function (e, t, r) {\n    this.variableNames = [\"dy\"], this.outputShape = [], this.outputShape = t.shape;\n    var n = t.shape,\n        o = n[1],\n        a = n[2],\n        i = e.shape,\n        s = i[1],\n        u = i[2],\n        l = [r && s > 1 ? o - 1 : o, r && u > 1 ? a - 1 : a],\n        c = [r && s > 1 ? s - 1 : s, r && u > 1 ? u - 1 : u],\n        p = l[0] / c[0],\n        d = l[1] / c[1],\n        h = 1 / p,\n        f = 1 / d,\n        m = 2 * Math.ceil(h) + 2,\n        g = 2 * Math.ceil(f) + 2;\n    this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float accumulator = 0.0;\\n\\n        const float heightScale = float(\" + p + \");\\n        const float widthScale = float(\" + d + \");\\n\\n        const float invHeightScale = float(\" + h + \");\\n        const float invWidthScale = float(\" + f + \");\\n\\n        const int winHeight = int(\" + m + \");\\n        const int winWidth = int(\" + g + \");\\n\\n        // Compute bounds for where in dy we will look\\n        float startRLerp = floor(float(r) * invHeightScale);\\n        int startDyR = int(startRLerp - float(winHeight / 2));\\n\\n        float startCLerp = floor(float(c) * invWidthScale);\\n        int startDyC = int(startCLerp - float(winWidth / 2));\\n\\n        // Loop over dy\\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\\n          int dyR = dyROffset + startDyR;\\n\\n          // Guard against the window exceeding the bounds of dy\\n          if (dyR < 0 || dyR >= \" + s + \") {\\n            continue;\\n          }\\n\\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\\n            int dyC = dyCOffset + startDyC;\\n\\n            // Guard against the window exceeding the bounds of dy\\n            if (dyC < 0 || dyC >= \" + u + \") {\\n              continue;\\n            }\\n\\n            float dxR = float(dyR) * heightScale;\\n            int topDxRIndex = int(floor(dxR));\\n            int bottomDxRIndex = int(min(ceil(dxR), \" + (o - 1) + \".0));\\n            float dxRLerp = dxR - float(topDxRIndex);\\n            float inverseDxRLerp = 1.0 - dxRLerp;\\n\\n            float dxC = float(dyC) * widthScale;\\n            int leftDxCIndex = int(floor(dxC));\\n            int rightDxCIndex = int(min(ceil(dxC), \" + (a - 1) + \".0));\\n            float dxCLerp = dxC - float(leftDxCIndex);\\n            float inverseDxCLerp = 1.0 - dxCLerp;\\n\\n            if (r == topDxRIndex && c == leftDxCIndex) {\\n              // topLeft\\n              accumulator +=\\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\\n            }\\n\\n            if (r == topDxRIndex && c == rightDxCIndex) {\\n              // topRight\\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\\n            }\\n\\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\\n              // bottomLeft\\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\\n            }\\n\\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\\n              // bottomRight\\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\\n            }\\n          }\\n        }\\n        // End loop over dy\\n\\n        setOutput(accumulator);\\n      }\\n    \";\n  };\n}(),\n    ResizeBilinearProgram = function () {\n  return function (e, t, r, n) {\n    this.variableNames = [\"A\"], this.outputShape = [];\n    var o = e[0],\n        a = e[1],\n        i = e[2],\n        s = e[3];\n    this.outputShape = [o, t, r, s];\n    var u = [n && t > 1 ? a - 1 : a, n && r > 1 ? i - 1 : i],\n        l = [n && t > 1 ? t - 1 : t, n && r > 1 ? r - 1 : r];\n    this.userCode = \"\\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\\n          \" + u[0] / l[0] + \",\\n          \" + u[1] / l[1] + \");\\n      const vec2 inputShapeRC = vec2(\" + a + \".0, \" + i + \".0);\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        ivec2 yRC = coords.yz;\\n\\n        // Fractional source index.\\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\\n\\n        // Compute the four integer indices.\\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\\n        ivec2 sourceCeilRC = ivec2(\\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\\n\\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\\n\\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\\n\\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\\n        float newValue = top + (bottom - top) * fracRC.x;\\n\\n        setOutput(newValue);\\n      }\\n    \";\n  };\n}(),\n    ResizeNearestNeigborBackpropProgram = function () {\n  return function (e, t, r) {\n    this.variableNames = [\"dy\"], this.outputShape = [], this.outputShape = t.shape;\n    var n = t.shape,\n        o = n[1],\n        a = n[2],\n        i = e.shape,\n        s = i[1],\n        u = i[2],\n        l = [r && s > 1 ? o - 1 : o, r && u > 1 ? a - 1 : a],\n        c = [r && s > 1 ? s - 1 : s, r && u > 1 ? u - 1 : u],\n        p = l[0] / c[0],\n        d = l[1] / c[1],\n        h = 1 / p,\n        f = 1 / d,\n        m = 2 * Math.ceil(h) + 2,\n        g = 2 * Math.ceil(f) + 2;\n    this.userCode = \"\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        int r = coords[1];\\n        int c = coords[2];\\n\\n        float accumulator = 0.0;\\n\\n        const float heightScale = float(\" + p + \");\\n        const float widthScale = float(\" + d + \");\\n\\n        const float invHeightScale = float(\" + h + \");\\n        const float invWidthScale = float(\" + f + \");\\n\\n        const int winHeight = int(\" + m + \");\\n        const int winWidth = int(\" + g + \");\\n\\n        // Compute bounds for where in dy we will look\\n        float startRLerp = floor(float(r) * invHeightScale);\\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\\n\\n        float startCLerp = floor(float(c) * invWidthScale);\\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\\n\\n        // Loop over dy\\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\\n          int dyR = dyROffset + startDyR;\\n\\n          // Guard against the window exceeding the bounds of dy\\n          if (dyR < 0 || dyR >= \" + s + \") {\\n            continue;\\n          }\\n\\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\\n            int dyC = dyCOffset + startDyC;\\n\\n            // Guard against the window exceeding the bounds of dy\\n            if (dyC < 0 || dyC >= \" + u + \") {\\n              continue;\\n            }\\n\\n            float sourceFracRow =\\n              float(\" + l[0] + \") *\\n                (float(dyR) / float(\" + c[0] + \"));\\n\\n            float sourceFracCol =\\n                float(\" + l[1] + \") *\\n                  (float(dyC) / float(\" + c[1] + \"));\\n\\n            int sourceNearestRow = int(min(\\n                float(int(\" + o + \") - 1),\\n                \" + r + \" ? float(round(sourceFracRow)) :\\n                                  float(floor(sourceFracRow))));\\n\\n            int sourceNearestCol = int(min(\\n                float(int(\" + a + \") - 1),\\n                \" + r + \" ? float(round(sourceFracCol)) :\\n                                  float(floor(sourceFracCol))));\\n\\n            if (r == sourceNearestRow && c == sourceNearestCol) {\\n              accumulator += getDy(b, dyR, dyC, d);\\n            }\\n          }\\n        }\\n        // End loop over dy\\n\\n        setOutput(accumulator);\\n      }\\n    \";\n  };\n}(),\n    ResizeNearestNeighborProgram = function () {\n  return function (e, t, r, n) {\n    this.variableNames = [\"A\"], this.outputShape = [];\n    var o = e[0],\n        a = e[1],\n        i = e[2],\n        s = e[3];\n    this.outputShape = [o, t, r, s];\n    var u = [n && t > 1 ? a - 1 : a, n && r > 1 ? i - 1 : i],\n        l = [n && t > 1 ? t - 1 : t, n && r > 1 ? r - 1 : r],\n        c = n ? \"0.5\" : \"0.0\";\n    this.userCode = \"\\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\\n          \" + u[0] / l[0] + \",\\n          \" + u[1] / l[1] + \");\\n      const vec2 inputShapeRC = vec2(\" + a + \".0, \" + i + \".0);\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int d = coords[3];\\n        ivec2 yRC = coords.yz;\\n\\n        // Fractional source index.\\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\\n\\n        // Compute the coordinators of nearest neighbor point.\\n        ivec2 sourceNearestRC = ivec2(\\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + \" + c + \")));\\n\\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\\n\\n        setOutput(newValue);\\n      }\\n    \";\n  };\n}(),\n    ReverseProgram = function () {\n  return function (e, t) {\n    this.variableNames = [\"x\"];\n    var r = e.length;\n    if (r > 4) throw new Error(\"WebGL backend: Reverse of rank-\" + r + \" tensor is not yet supported\");\n\n    if (this.outputShape = e, 1 !== r) {\n      var n = e.map(function (r, n) {\n        return function (r) {\n          return -1 !== t.indexOf(r) && 1 !== e[r] ? e[r] + \" - coords[\" + r + \"] - 1\" : \"coords[\" + r + \"]\";\n        }(n);\n      }).join(\",\"),\n          o = getCoordsDataType(r);\n      this.userCode = \"\\n      void main() {\\n        \" + o + \" coords = getOutputCoords();\\n        setOutput(getX(\" + n + \"));\\n      }\\n    \";\n    } else this.userCode = \"\\n        void main() {\\n          int coord = getOutputCoords();\\n          setOutput(getX(\" + e[0] + \" - coord - 1));\\n        }\\n      \";\n  };\n}(),\n    ScatterProgram = function () {\n  return function (e, t, r, n, o, a, i) {\n    void 0 === i && (i = !0), this.variableNames = [\"updates\", \"indices\", \"defaultValue\"], this.outputShape = a;\n    var s = getCoordsDataType(o.length),\n        u = getCoordsDataType(a.length),\n        l = \"\";\n    1 === r ? l = \"i\" : 2 === r && (l = \"i, j\");\n    var c = \"getIndices(\" + l + \")\",\n        p = \"\";\n    1 === n ? p = \"i\" : 2 === n && (p = \"i, coords[1]\");\n    var d = \"getUpdates(\" + p + \")\",\n        h = t > 1 ? \"strides[j]\" : \"strides\";\n    this.userCode = \"\\n        \" + s + \" strides = \" + s + \"(\" + o + \");\\n\\n        void main() {\\n          \" + u + \" coords = getOutputCoords();\\n          float sum = 0.0;\\n          bool found = false;\\n          for (int i = 0; i < \" + e + \"; i++) {\\n            int flattenedIndex = 0;\\n            for (int j = 0; j < \" + t + \"; j++) {\\n              int index = round(\" + c + \");\\n              flattenedIndex += index * \" + h + \";\\n            }\\n            if (flattenedIndex == coords[0]) {\\n              sum += \" + d + \";\\n              found = true;\\n            }\\n          }\\n          setOutput(mix(getDefaultValue(), sum, float(found)));\\n        }\\n      \";\n  };\n}(),\n    SegmentOpProgram = function () {\n  return function (e, t) {\n    this.variableNames = [\"x\", \"segmentIds\"];\n    var r = e.windowSize,\n        n = e.batchSize,\n        o = e.inSize,\n        a = e.numSegments,\n        i = a * Math.ceil(o / r);\n    this.outputShape = [n, i];\n    var s = 4 * Math.floor(r / 4),\n        u = r % 4,\n        l = \"\\n        sumValue += dot(values, filter);\\n    \",\n        c = \"\";\n    o % r > 0 && (c = \"\\n        if (inIdx < 0 || inIdx >= \" + o + \") {\\n          return initializationValue;\\n        }\\n      \");\n    var p = \"\";\n    o % r > 0 && (p = \"\\n        if (inIdx < 0 || inIdx >= \" + o + \") {\\n          return -1.0;\\n        }\\n      \"), this.userCode = \"\\n      const float initializationValue = 0.0;\\n\\n      float getValue(int batch, int inIdx) {\\n        \" + c + \"\\n        return getX(batch, inIdx);\\n      }\\n\\n      float getSegmentIdAtIndex(int inIdx) {\\n        \" + p + \"\\n        return getSegmentIds(inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = int(floor(float(outIdx) / float(\\n          \" + a + \")) * float(\" + r + \"));\\n        int currentSeg = int(mod(float(outIdx), float(\" + a + \")));\\n\\n        float sumValue = 0.0;\\n\\n        for (int i = 0; i < \" + s + \"; i += 4) {\\n          int inIdx = inOffset + i;\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          vec4 filter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\\n          );\\n\\n          \" + l + \"\\n        }\\n\\n        int inIdx = inOffset + \" + s + \";\\n        if (\" + (1 === u) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            initializationValue,\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\\n\\n          vec4 filter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            0,\\n            0,\\n            0\\n          );\\n\\n          \" + l + \"\\n        } else if (\" + (2 === u) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          vec4 filter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n              0,\\n              0\\n          );\\n\\n          \" + l + \"\\n        } else if (\" + (3 === u) + \") {\\n          vec4 values = vec4(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            initializationValue\\n          );\\n\\n          vec4 filter = vec4(\\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\\n            0\\n          );\\n\\n          \" + l + \"\\n        }\\n        setOutput(sumValue);\\n      }\\n    \";\n  };\n}(),\n    SelectProgram = function () {\n  return function (e, t, r) {\n    var n, o;\n    if (this.variableNames = [\"c\", \"a\", \"b\"], this.outputShape = t, r > 4) throw Error(\"Where for rank \" + r + \" is not yet supported\");\n    if (1 === r) o = \"resRC\", n = \"resRC\";else {\n      for (var a = [\"resRC.x\", \"resRC.y\", \"resRC.z\", \"resRC.w\"], i = [], s = [], u = 0; u < t.length; u++) {\n        s.push(\"\" + a[u]), u < e && i.push(\"\" + a[u]);\n      }\n\n      n = i.join(), o = s.join();\n    }\n    var l = getCoordsDataType(r);\n    this.userCode = \"\\n      void main() {\\n        \" + l + \" resRC = getOutputCoords();\\n        float cVal = getC(\" + n + \");\\n        if (cVal >= 1.0) {\\n          setOutput(getA(\" + o + \"));\\n        } else {\\n          setOutput(getB(\" + o + \"));\\n        }\\n      }\\n    \";\n  };\n}(),\n    SliceProgram = function () {\n  function e(e) {\n    this.variableNames = [\"source\"], this.outputShape = e, this.rank = e.length;\n    var t = getCoordsDataType(this.rank),\n        r = getCoords$1(this.rank);\n    this.userCode = \"\\n      uniform \" + t + \" start;\\n\\n      void main() {\\n        \" + t + \" sourceLoc = start + getOutputCoords();\\n        setOutput(getSource(\" + r + \"));\\n      }\\n    \";\n  }\n\n  return e.prototype.getCustomSetupFunc = function (e) {\n    var t = this;\n    if (e.length !== this.rank) throw Error(\"The rank (\" + this.rank + \") of the program must match the length of start (\" + e.length + \")\");\n    return function (r, n) {\n      if (null != t.startLoc || (t.startLoc = r.getUniformLocationNoThrow(n, \"start\"), null != t.startLoc)) if (1 === t.rank) r.gl.uniform1i(t.startLoc, e[0]);else if (2 === t.rank) r.gl.uniform2i(t.startLoc, e[0], e[1]);else if (3 === t.rank) r.gl.uniform3i(t.startLoc, e[0], e[1], e[2]);else {\n        if (4 !== t.rank) throw Error(\"Slicing for rank \" + t.rank + \" is not yet supported\");\n        r.gl.uniform4i(t.startLoc, e[0], e[1], e[2], e[3]);\n      }\n    };\n  }, e;\n}();\n\nfunction getCoords$1(e) {\n  if (1 === e) return \"sourceLoc\";\n  if (2 === e) return \"sourceLoc.x, sourceLoc.y\";\n  if (3 === e) return \"sourceLoc.x, sourceLoc.y, sourceLoc.z\";\n  if (4 === e) return \"sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w\";\n  throw Error(\"Slicing for rank \" + e + \" is not yet supported\");\n}\n\nvar StridedSliceProgram = function () {\n  return function (e, t, r, n) {\n    this.variableNames = [\"x\"];\n    var o = r.filter(function (e, t) {\n      return -1 === n.indexOf(t);\n    });\n    this.outputShape = o;\n    var a = r.length,\n        i = getCoordsDataType(r.length),\n        s = getCoordsDataType(o.length),\n        u = \"\";\n    if (1 === a) u = \"coords * strides + begin\";else {\n      var l = 0;\n      u = r.map(function (e, t) {\n        return -1 === n.indexOf(t) ? (l++, 1 === o.length ? \"coords * strides[\" + t + \"] + begin[\" + t + \"]\" : \"coords[\" + (l - 1) + \"] * strides[\" + t + \"] + begin[\" + t + \"]\") : \"begin[\" + t + \"]\";\n      }).join(\",\");\n    }\n    this.userCode = \"\\n      \" + i + \" begin = \" + i + \"(\" + e + \");\\n      \" + i + \" strides = \" + i + \"(\" + t + \");\\n\\n      void main() {\\n        \" + s + \" coords = getOutputCoords();\\n        setOutput(getX(\" + u + \"));\\n      }\\n    \";\n  };\n}(),\n    TextureManager = function () {\n  function e(e) {\n    this.gpgpu = e, this.numUsedTextures = 0, this.numFreeTextures = 0, this.freeTextures = {}, this.logEnabled = !1, this.usedTextures = {};\n  }\n\n  return e.prototype.acquireTexture = function (e, t, r) {\n    var n,\n        o = getPhysicalFromLogicalTextureType(t, r),\n        a = getKeyFromTextureShape(e, o, r);\n\n    if (a in this.freeTextures || (this.freeTextures[a] = []), a in this.usedTextures || (this.usedTextures[a] = []), this.freeTextures[a].length > 0) {\n      this.numFreeTextures--, this.numUsedTextures++, this.log();\n      var i = this.freeTextures[a].shift();\n      return this.usedTextures[a].push(i), i;\n    }\n\n    return this.numUsedTextures++, this.log(), o === PhysicalTextureType.PACKED_2X2_FLOAT32 ? n = this.gpgpu.createPackedMatrixTexture(e[0], e[1]) : o === PhysicalTextureType.PACKED_2X2_FLOAT16 ? n = this.gpgpu.createFloat16PackedMatrixTexture(e[0], e[1]) : o === PhysicalTextureType.UNPACKED_FLOAT32 ? n = this.gpgpu.createFloat32MatrixTexture(e[0], e[1]) : o === PhysicalTextureType.UNPACKED_FLOAT16 ? n = this.gpgpu.createFloat16MatrixTexture(e[0], e[1]) : o === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE && (n = this.gpgpu.createUnsignedBytesMatrixTexture(e[0], e[1])), this.usedTextures[a].push(n), n;\n  }, e.prototype.releaseTexture = function (e, t, r, n) {\n    if (null != this.freeTextures) {\n      var o = getKeyFromTextureShape(t, getPhysicalFromLogicalTextureType(r, n), n);\n      o in this.freeTextures || (this.freeTextures[o] = []), this.freeTextures[o].push(e), this.numFreeTextures++, this.numUsedTextures--;\n      var a = this.usedTextures[o],\n          i = a.indexOf(e);\n      if (i < 0) throw new Error(\"Cannot release a texture that was never provided by this texture manager\");\n      a.splice(i, 1), this.log();\n    }\n  }, e.prototype.log = function () {\n    if (this.logEnabled) {\n      var e = this.numFreeTextures + this.numUsedTextures;\n      console.log(\"Free/Used\", this.numFreeTextures + \" / \" + this.numUsedTextures, \"(\" + e + \")\");\n    }\n  }, e.prototype.getNumUsedTextures = function () {\n    return this.numUsedTextures;\n  }, e.prototype.getNumFreeTextures = function () {\n    return this.numFreeTextures;\n  }, e.prototype.dispose = function () {\n    var e = this;\n\n    if (null != this.freeTextures) {\n      for (var t in this.freeTextures) {\n        this.freeTextures[t].forEach(function (t) {\n          e.gpgpu.deleteMatrixTexture(t);\n        });\n      }\n\n      for (var t in this.usedTextures) {\n        this.usedTextures[t].forEach(function (t) {\n          e.gpgpu.deleteMatrixTexture(t);\n        });\n      }\n\n      this.freeTextures = null, this.usedTextures = null, this.numUsedTextures = 0, this.numFreeTextures = 0;\n    }\n  }, e;\n}();\n\nfunction getPhysicalFromLogicalTextureType(e, t) {\n  if (e === TextureUsage.UPLOAD) return t ? PhysicalTextureType.PACKED_2X2_FLOAT32 : PhysicalTextureType.UNPACKED_FLOAT32;\n  if (e === TextureUsage.RENDER || null == e) return t ? ENV.get(\"WEBGL_RENDER_FLOAT32_ENABLED\") ? PhysicalTextureType.PACKED_2X2_FLOAT32 : PhysicalTextureType.PACKED_2X2_FLOAT16 : ENV.get(\"WEBGL_RENDER_FLOAT32_ENABLED\") ? PhysicalTextureType.UNPACKED_FLOAT32 : PhysicalTextureType.UNPACKED_FLOAT16;\n  if (e === TextureUsage.DOWNLOAD || e === TextureUsage.PIXELS) return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n  throw new Error(\"Unknown logical texture type \" + e);\n}\n\nfunction getKeyFromTextureShape(e, t, r) {\n  return e[0] + \"_\" + e[1] + \"_\" + t + \"_\" + r;\n}\n\nvar TileProgram = function () {\n  return function (e, t) {\n    this.variableNames = [\"A\"];\n\n    for (var r = new Array(e.length), n = 0; n < r.length; n++) {\n      r[n] = e[n] * t[n];\n    }\n\n    this.outputShape = r, this.rank = r.length;\n    var o = getCoordsDataType(this.rank),\n        a = getSourceCoords$2(e);\n    this.userCode = \"\\n      void main() {\\n        \" + o + \" resRC = getOutputCoords();\\n        setOutput(getA(\" + a + \"));\\n      }\\n    \";\n  };\n}();\n\nfunction getSourceCoords$2(e) {\n  var t = e.length;\n  if (t > 5) throw Error(\"Tile for rank \" + t + \" is not yet supported\");\n  if (1 === t) return \"imod(resRC, \" + e[0] + \")\";\n\n  for (var r = [\"resRC.x\", \"resRC.y\", \"resRC.z\", \"resRC.w\", \"resRC.u\"], n = [], o = 0; o < e.length; o++) {\n    n.push(\"imod(\" + r[o] + \", \" + e[o] + \")\");\n  }\n\n  return n.join();\n}\n\nvar TransposeProgram = function () {\n  return function (e, t) {\n    this.variableNames = [\"A\"];\n\n    for (var r = new Array(e.length), n = 0; n < r.length; n++) {\n      r[n] = e[t[n]];\n    }\n\n    this.outputShape = r, this.rank = r.length;\n    var o = getCoordsDataType(this.rank),\n        a = getSwitchedCoords(t);\n    this.userCode = \"\\n    void main() {\\n      \" + o + \" resRC = getOutputCoords();\\n      setOutput(getA(\" + a + \"));\\n    }\\n    \";\n  };\n}();\n\nfunction getSwitchedCoords(e) {\n  var t = e.length;\n  if (t > 6) throw Error(\"Transpose for rank \" + t + \" is not yet supported\");\n\n  for (var r = [\"resRC.x\", \"resRC.y\", \"resRC.z\", \"resRC.w\", \"resRC.u\", \"resRC.v\"], n = new Array(t), o = 0; o < e.length; o++) {\n    n[e[o]] = r[o];\n  }\n\n  return n.join();\n}\n\nvar ERF_P = .3275911,\n    ERF_A1 = .254829592,\n    ERF_A2 = -.284496736,\n    ERF_A3 = 1.421413741,\n    ERF_A4 = -1.453152027,\n    ERF_A5 = 1.061405429,\n    SELU_SCALEALPHA = 1.7580993408473768,\n    SELU_SCALE = 1.0507009873554805,\n    UnaryOpProgram = function () {\n  function e(e, t) {\n    this.variableNames = [\"A\"], this.outputShape = e, this.userCode = \"\\n      uniform float NAN;\\n      float unaryOperation(float x) {\\n        \" + t + \"\\n      }\\n\\n      void main() {\\n        float x = getAAtOutCoords();\\n        float y = unaryOperation(x);\\n\\n        setOutput(y);\\n      }\\n    \";\n  }\n\n  return e.prototype.getCustomSetupFunc = function () {\n    var e = this;\n    return function (t, r) {\n      null == e.startLoc && (e.startLoc = t.getUniformLocationNoThrow(r, \"NAN\"), null == e.startLoc) || t.gl.uniform1f(e.startLoc, NaN);\n    };\n  }, e;\n}(),\n    CHECK_NAN_SNIPPET$1 = \"if (isNaN(x)) return x;\",\n    ABS = \"return abs(x);\",\n    RELU = CHECK_NAN_SNIPPET$1 + \"\\n  return (x < 0.0) ? 0.0 : x;\\n\",\n    ELU = \"return (x >= 0.0) ? x : (exp(x) - 1.0);\",\n    SELU = \"\\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\\n  // see: https://arxiv.org/abs/1706.02515\\n  float scaleAlpha = \" + SELU_SCALEALPHA + \";\\n  float scale = \" + SELU_SCALE + \";\\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\\n\";\n\nfunction STEP(e) {\n  return void 0 === e && (e = 0), CHECK_NAN_SNIPPET$1 + \"\\n    return x > 0.0 ? 1.0 : float(\" + e + \");\\n  \";\n}\n\nvar NEG = \"return -x;\",\n    CEIL = \"return ceil(x);\",\n    FLOOR = \"return floor(x);\",\n    SIGN = \"\\n  if (isNaN(x)) { return 0.0; }\\n  return sign(x);\\n\",\n    ROUND = \"\\n  // OpenGL ES does not support round function.\\n  // The algorithm is based on banker's rounding.\\n  float base = floor(x);\\n  if ((x - base) < 0.5) {\\n    return floor(x);\\n  } else if ((x - base) > 0.5) {\\n    return ceil(x);\\n  } else {\\n    if (mod(base, 2.0) == 0.0) {\\n      return base;\\n    } else {\\n      return base + 1.0;\\n    }\\n  }\\n\",\n    EXP = \"return exp(x);\",\n    EXPM1 = \"return exp(x) - 1.0;\",\n    LOG = \"if (x < 0.0) return NAN;\\n  return log(x);\",\n    LOG1P = \"return log(1.0 + x);\",\n    SQRT = \"return sqrt(x);\",\n    RSQRT = \"return inversesqrt(x);\",\n    SIGMOID = \"return 1.0 / (1.0 + exp(-1.0 * x));\",\n    SOFTPLUS = \"\\n  float epsilon = 1.1920928955078125e-7;\\n  float threshold = log(epsilon) + 2.0;\\n\\n  bool too_large = x > -threshold;\\n  bool too_small = x < threshold;\\n\\n  float result;\\n  float exp_x = exp(x);\\n\\n  if (too_large){\\n    result = x;\\n  }\\n  else if (too_small){\\n    result = exp_x;\\n  }\\n  else{\\n    result = log(exp_x + 1.0);\\n  }\\n  return result;\\n\",\n    SIN = CHECK_NAN_SNIPPET$1 + \"\\n  return sin(x);\\n\",\n    COS = CHECK_NAN_SNIPPET$1 + \"\\n  return cos(x);\\n\",\n    TAN = \"return tan(x);\",\n    ASIN = \"return asin(x);\",\n    ACOS = \"return acos(x);\",\n    ATAN = CHECK_NAN_SNIPPET$1 + \"\\n  return atan(x);\\n\",\n    SINH = \"\\n  float e2x = exp(x);\\n  return (e2x - 1.0 / e2x) / 2.0;\\n\",\n    COSH = \"\\n  float e2x = exp(-x);\\n  return (e2x + 1.0 / e2x) / 2.0;\\n\",\n    TANH = \"\\n  float e2x = exp(-2.0 * abs(x));\\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\\n\",\n    ASINH = \"return log(x + sqrt(x * x + 1.0));\",\n    ACOSH = CHECK_NAN_SNIPPET$1 + \"\\n  if (x < 1.0) return NAN;\\n  return log(x + sqrt(x * x - 1.0));\",\n    ATANH = CHECK_NAN_SNIPPET$1 + \"\\n  if ((x < -1.0) || (x > 1.0)) return NAN;\\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;\",\n    ERF = '\\n  // Error function is calculated approximately with elementary function.\\n  // See \"Handbook of Mathematical Functions with Formulas,\\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\\n  float p = ' + ERF_P + \";\\n  float a1 = \" + ERF_A1 + \";\\n  float a2 = \" + ERF_A2 + \";\\n  float a3 = \" + ERF_A3 + \";\\n  float a4 = \" + ERF_A4 + \";\\n  float a5 = \" + ERF_A5 + \";\\n\\n  float t = 1.0 / (1.0 + p * x);\\n  return 1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x);\\n\",\n    SQUARE = \"return x * x;\",\n    RECIPROCAL = \"return 1.0 / x;\",\n    LOGICAL_NOT = \"return float(!(x >= 1.0));\",\n    TO_INT = \"return float(int(x));\",\n    UnpackProgram = function () {\n  return function (e) {\n    this.variableNames = [\"A\"], this.usesPackedTextures = !0, this.outputShape = e;\n    var t = e.length,\n        r = getChannels(\"rc\", t),\n        n = getCoordsDataType(t),\n        o = getSourceCoords$1(t, r),\n        a = r.slice(-2),\n        i = 1 === t ? \"rc\" : \"vec2(\" + a.join(\",\") + \")\";\n    this.userCode = \"\\n      void main() {\\n        \" + n + \" rc = getOutputCoords();\\n        vec4 packedInput = getA(\" + o + \");\\n\\n        setOutput(getChannel(packedInput, \" + i + \"));\\n      }\\n    \";\n  };\n}();\n\nfunction concat1d_(e) {\n  return concat(e, 0);\n}\n\nfunction concat2d_(e, t) {\n  return concat(e, t);\n}\n\nfunction concat3d_(e, t) {\n  return concat(e, t);\n}\n\nfunction concat4d_(e, t) {\n  return concat(e, t);\n}\n\nfunction concat_(e, t) {\n  void 0 === t && (t = 0), assert(e.length >= 1, \"Pass at least one tensor to concat\");\n  var r = convertToTensorArray(e, \"tensors\", \"concat\");\n  t = parseAxisParam(t, r[0].shape)[0];\n  var n = computeOutShape(r.map(function (e) {\n    return e.shape;\n  }), t);\n  if (0 === sizeFromShape(n)) return tensor([], n);\n  if (1 === (r = r.filter(function (e) {\n    return e.size > 0;\n  })).length) return r[0];\n  var o = r.map(function (e) {\n    return e.shape;\n  });\n  assertParamsConsistent(o, t);\n  var a = r;\n  return ENV.engine.runKernel(function (e) {\n    return e.concat(r, t);\n  }, a, function (e) {\n    var r = o.map(function (e) {\n      return e[t];\n    });\n    return split$1(e, r, t).map(function (e) {\n      return function () {\n        return e;\n      };\n    });\n  });\n}\n\nfunction split_(e, t, r) {\n  void 0 === r && (r = 0);\n  var n,\n      o = convertToTensor(e, \"x\", \"split\");\n  r = parseAxisParam(r, o.shape)[0], \"number\" == typeof t ? (assert(o.shape[r] % t == 0, \"Number of splits must evenly divide the axis.\"), n = Array(t).fill(o.shape[r] / t)) : (assert(o.shape[r] === t.reduce(function (e, t) {\n    return e + t;\n  }), \"The sum of sizes must match the size of the axis dimension.\"), n = t);\n  return ENV.engine.runKernel(function (e) {\n    return e.split(o, n, r);\n  }, {\n    $x: o\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return concat(e, r);\n      }\n    };\n  });\n}\n\nvar concat = op({\n  concat_: concat_\n}),\n    concat1d = op({\n  concat1d_: concat1d_\n}),\n    concat2d = op({\n  concat2d_: concat2d_\n}),\n    concat3d = op({\n  concat3d_: concat3d_\n}),\n    concat4d = op({\n  concat4d_: concat4d_\n}),\n    split$1 = op({\n  split_: split_\n}),\n    commonjsGlobal = \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {};\n\nfunction createCommonjsModule(e, t) {\n  return e(t = {\n    exports: {}\n  }, t.exports), t.exports;\n}\n\nvar alea = createCommonjsModule(function (e) {\n  !function (e, t, r) {\n    function n(e, t) {\n      return t.c = e.c, t.s0 = e.s0, t.s1 = e.s1, t.s2 = e.s2, t;\n    }\n\n    function o(e, t) {\n      var r = new function (e) {\n        var t,\n            r = this,\n            n = (t = 4022871197, function (e) {\n          e = e.toString();\n\n          for (var r = 0; r < e.length; r++) {\n            var n = .02519603282416938 * (t += e.charCodeAt(r));\n            n -= t = n >>> 0, t = (n *= t) >>> 0, t += 4294967296 * (n -= t);\n          }\n\n          return 2.3283064365386963e-10 * (t >>> 0);\n        });\n        r.next = function () {\n          var e = 2091639 * r.s0 + 2.3283064365386963e-10 * r.c;\n          return r.s0 = r.s1, r.s1 = r.s2, r.s2 = e - (r.c = 0 | e);\n        }, r.c = 1, r.s0 = n(\" \"), r.s1 = n(\" \"), r.s2 = n(\" \"), r.s0 -= n(e), r.s0 < 0 && (r.s0 += 1), r.s1 -= n(e), r.s1 < 0 && (r.s1 += 1), r.s2 -= n(e), r.s2 < 0 && (r.s2 += 1), n = null;\n      }(e),\n          o = t && t.state,\n          a = r.next;\n      return a.int32 = function () {\n        return 4294967296 * r.next() | 0;\n      }, a.double = function () {\n        return a() + 1.1102230246251565e-16 * (2097152 * a() | 0);\n      }, a.quick = a, o && (\"object\" == typeof o && n(o, r), a.state = function () {\n        return n(r, {});\n      }), a;\n    }\n\n    t && t.exports ? t.exports = o : r && r.amd ? r(function () {\n      return o;\n    }) : this.alea = o;\n  }(0, e, !1);\n}),\n    xor128 = createCommonjsModule(function (e) {\n  !function (e, t, r) {\n    function n(e, t) {\n      return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t;\n    }\n\n    function o(e, t) {\n      var r = new function (e) {\n        var t = this,\n            r = \"\";\n        t.x = 0, t.y = 0, t.z = 0, t.w = 0, t.next = function () {\n          var e = t.x ^ t.x << 11;\n          return t.x = t.y, t.y = t.z, t.z = t.w, t.w ^= t.w >>> 19 ^ e ^ e >>> 8;\n        }, e === (0 | e) ? t.x = e : r += e;\n\n        for (var n = 0; n < r.length + 64; n++) {\n          t.x ^= 0 | r.charCodeAt(n), t.next();\n        }\n      }(e),\n          o = t && t.state,\n          a = function a() {\n        return (r.next() >>> 0) / 4294967296;\n      };\n\n      return a.double = function () {\n        do {\n          var e = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21);\n        } while (0 === e);\n\n        return e;\n      }, a.int32 = r.next, a.quick = a, o && (\"object\" == typeof o && n(o, r), a.state = function () {\n        return n(r, {});\n      }), a;\n    }\n\n    t && t.exports ? t.exports = o : r && r.amd ? r(function () {\n      return o;\n    }) : this.xor128 = o;\n  }(0, e, !1);\n}),\n    xorwow = createCommonjsModule(function (e) {\n  !function (e, t, r) {\n    function n(e, t) {\n      return t.x = e.x, t.y = e.y, t.z = e.z, t.w = e.w, t.v = e.v, t.d = e.d, t;\n    }\n\n    function o(e, t) {\n      var r = new function (e) {\n        var t = this,\n            r = \"\";\n        t.next = function () {\n          var e = t.x ^ t.x >>> 2;\n          return t.x = t.y, t.y = t.z, t.z = t.w, t.w = t.v, (t.d = t.d + 362437 | 0) + (t.v = t.v ^ t.v << 4 ^ e ^ e << 1) | 0;\n        }, t.x = 0, t.y = 0, t.z = 0, t.w = 0, t.v = 0, e === (0 | e) ? t.x = e : r += e;\n\n        for (var n = 0; n < r.length + 64; n++) {\n          t.x ^= 0 | r.charCodeAt(n), n == r.length && (t.d = t.x << 10 ^ t.x >>> 4), t.next();\n        }\n      }(e),\n          o = t && t.state,\n          a = function a() {\n        return (r.next() >>> 0) / 4294967296;\n      };\n\n      return a.double = function () {\n        do {\n          var e = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21);\n        } while (0 === e);\n\n        return e;\n      }, a.int32 = r.next, a.quick = a, o && (\"object\" == typeof o && n(o, r), a.state = function () {\n        return n(r, {});\n      }), a;\n    }\n\n    t && t.exports ? t.exports = o : r && r.amd ? r(function () {\n      return o;\n    }) : this.xorwow = o;\n  }(0, e, !1);\n}),\n    xorshift7 = createCommonjsModule(function (e) {\n  !function (e, t, r) {\n    function n(e, t) {\n      return t.x = e.x.slice(), t.i = e.i, t;\n    }\n\n    function o(e, t) {\n      null == e && (e = +new Date());\n\n      var r = new function (e) {\n        var t = this;\n        t.next = function () {\n          var e,\n              r,\n              n = t.x,\n              o = t.i;\n          return e = n[o], r = (e ^= e >>> 7) ^ e << 24, r ^= (e = n[o + 1 & 7]) ^ e >>> 10, r ^= (e = n[o + 3 & 7]) ^ e >>> 3, r ^= (e = n[o + 4 & 7]) ^ e << 7, e = n[o + 7 & 7], r ^= (e ^= e << 13) ^ e << 9, n[o] = r, t.i = o + 1 & 7, r;\n        }, function (e, t) {\n          var r,\n              n = [];\n          if (t === (0 | t)) n[0] = t;else for (t = \"\" + t, r = 0; r < t.length; ++r) {\n            n[7 & r] = n[7 & r] << 15 ^ t.charCodeAt(r) + n[r + 1 & 7] << 13;\n          }\n\n          for (; n.length < 8;) {\n            n.push(0);\n          }\n\n          for (r = 0; r < 8 && 0 === n[r]; ++r) {\n            ;\n          }\n\n          for (8 == r ? n[7] = -1 : n[r], e.x = n, e.i = 0, r = 256; r > 0; --r) {\n            e.next();\n          }\n        }(t, e);\n      }(e),\n          o = t && t.state,\n          a = function a() {\n        return (r.next() >>> 0) / 4294967296;\n      };\n\n      return a.double = function () {\n        do {\n          var e = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21);\n        } while (0 === e);\n\n        return e;\n      }, a.int32 = r.next, a.quick = a, o && (o.x && n(o, r), a.state = function () {\n        return n(r, {});\n      }), a;\n    }\n\n    t && t.exports ? t.exports = o : r && r.amd ? r(function () {\n      return o;\n    }) : this.xorshift7 = o;\n  }(0, e, !1);\n}),\n    xor4096 = createCommonjsModule(function (e) {\n  !function (e, t, r) {\n    function n(e, t) {\n      return t.i = e.i, t.w = e.w, t.X = e.X.slice(), t;\n    }\n\n    function o(e, t) {\n      null == e && (e = +new Date());\n\n      var r = new function (e) {\n        var t = this;\n        t.next = function () {\n          var e,\n              r,\n              n = t.w,\n              o = t.X,\n              a = t.i;\n          return t.w = n = n + 1640531527 | 0, r = o[a + 34 & 127], e = o[a = a + 1 & 127], r ^= r << 13, e ^= e << 17, r ^= r >>> 15, e ^= e >>> 12, r = o[a] = r ^ e, t.i = a, r + (n ^ n >>> 16) | 0;\n        }, function (e, t) {\n          var r,\n              n,\n              o,\n              a,\n              i,\n              s = [],\n              u = 128;\n\n          for (t === (0 | t) ? (n = t, t = null) : (t += \"\\0\", n = 0, u = Math.max(u, t.length)), o = 0, a = -32; a < u; ++a) {\n            t && (n ^= t.charCodeAt((a + 32) % t.length)), 0 === a && (i = n), n ^= n << 10, n ^= n >>> 15, n ^= n << 4, n ^= n >>> 13, a >= 0 && (i = i + 1640531527 | 0, o = 0 == (r = s[127 & a] ^= n + i) ? o + 1 : 0);\n          }\n\n          for (o >= 128 && (s[127 & (t && t.length || 0)] = -1), o = 127, a = 512; a > 0; --a) {\n            n = s[o + 34 & 127], r = s[o = o + 1 & 127], n ^= n << 13, r ^= r << 17, n ^= n >>> 15, r ^= r >>> 12, s[o] = n ^ r;\n          }\n\n          e.w = i, e.X = s, e.i = o;\n        }(t, e);\n      }(e),\n          o = t && t.state,\n          a = function a() {\n        return (r.next() >>> 0) / 4294967296;\n      };\n\n      return a.double = function () {\n        do {\n          var e = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21);\n        } while (0 === e);\n\n        return e;\n      }, a.int32 = r.next, a.quick = a, o && (o.X && n(o, r), a.state = function () {\n        return n(r, {});\n      }), a;\n    }\n\n    t && t.exports ? t.exports = o : r && r.amd ? r(function () {\n      return o;\n    }) : this.xor4096 = o;\n  }(0, e, !1);\n}),\n    tychei = createCommonjsModule(function (e) {\n  !function (e, t, r) {\n    function n(e, t) {\n      return t.a = e.a, t.b = e.b, t.c = e.c, t.d = e.d, t;\n    }\n\n    function o(e, t) {\n      var r = new function (e) {\n        var t = this,\n            r = \"\";\n        t.next = function () {\n          var e = t.b,\n              r = t.c,\n              n = t.d,\n              o = t.a;\n          return e = e << 25 ^ e >>> 7 ^ r, r = r - n | 0, n = n << 24 ^ n >>> 8 ^ o, o = o - e | 0, t.b = e = e << 20 ^ e >>> 12 ^ r, t.c = r = r - n | 0, t.d = n << 16 ^ r >>> 16 ^ o, t.a = o - e | 0;\n        }, t.a = 0, t.b = 0, t.c = -1640531527, t.d = 1367130551, e === Math.floor(e) ? (t.a = e / 4294967296 | 0, t.b = 0 | e) : r += e;\n\n        for (var n = 0; n < r.length + 20; n++) {\n          t.b ^= 0 | r.charCodeAt(n), t.next();\n        }\n      }(e),\n          o = t && t.state,\n          a = function a() {\n        return (r.next() >>> 0) / 4294967296;\n      };\n\n      return a.double = function () {\n        do {\n          var e = ((r.next() >>> 11) + (r.next() >>> 0) / 4294967296) / (1 << 21);\n        } while (0 === e);\n\n        return e;\n      }, a.int32 = r.next, a.quick = a, o && (\"object\" == typeof o && n(o, r), a.state = function () {\n        return n(r, {});\n      }), a;\n    }\n\n    t && t.exports ? t.exports = o : r && r.amd ? r(function () {\n      return o;\n    }) : this.tychei = o;\n  }(0, e, !1);\n}),\n    seedrandom = createCommonjsModule(function (e) {\n  !function (t, r) {\n    var n,\n        o = this,\n        a = 256,\n        i = 6,\n        s = \"random\",\n        u = r.pow(a, i),\n        l = r.pow(2, 52),\n        c = 2 * l,\n        p = a - 1;\n\n    function d(e, d, g) {\n      var v = [],\n          y = f(function e(t, r) {\n        var n,\n            o = [],\n            a = typeof t;\n        if (r && \"object\" == a) for (n in t) {\n          try {\n            o.push(e(t[n], r - 1));\n          } catch (e) {}\n        }\n        return o.length ? o : \"string\" == a ? t : t + \"\\0\";\n      }((d = 1 == d ? {\n        entropy: !0\n      } : d || {}).entropy ? [e, m(t)] : null == e ? function () {\n        try {\n          var e;\n          return n && (e = n.randomBytes) ? e = e(a) : (e = new Uint8Array(a), (o.crypto || o.msCrypto).getRandomValues(e)), m(e);\n        } catch (e) {\n          var r = o.navigator,\n              i = r && r.plugins;\n          return [+new Date(), o, i, o.screen, m(t)];\n        }\n      }() : e, 3), v),\n          x = new function (e) {\n        var t,\n            r = e.length,\n            n = this,\n            o = 0,\n            i = n.i = n.j = 0,\n            s = n.S = [];\n        r || (e = [r++]);\n\n        for (; o < a;) {\n          s[o] = o++;\n        }\n\n        for (o = 0; o < a; o++) {\n          s[o] = s[i = p & i + e[o % r] + (t = s[o])], s[i] = t;\n        }\n\n        (n.g = function (e) {\n          for (var t, r = 0, o = n.i, i = n.j, s = n.S; e--;) {\n            t = s[o = p & o + 1], r = r * a + s[p & (s[o] = s[i = p & i + t]) + (s[i] = t)];\n          }\n\n          return n.i = o, n.j = i, r;\n        })(a);\n      }(v),\n          T = function T() {\n        for (var e = x.g(i), t = u, r = 0; e < l;) {\n          e = (e + r) * a, t *= a, r = x.g(1);\n        }\n\n        for (; e >= c;) {\n          e /= 2, t /= 2, r >>>= 1;\n        }\n\n        return (e + r) / t;\n      };\n\n      return T.int32 = function () {\n        return 0 | x.g(4);\n      }, T.quick = function () {\n        return x.g(4) / 4294967296;\n      }, T.double = T, f(m(x.S), t), (d.pass || g || function (e, t, n, o) {\n        return o && (o.S && h(o, x), e.state = function () {\n          return h(x, {});\n        }), n ? (r[s] = e, t) : e;\n      })(T, y, \"global\" in d ? d.global : this == r, d.state);\n    }\n\n    function h(e, t) {\n      return t.i = e.i, t.j = e.j, t.S = e.S.slice(), t;\n    }\n\n    function f(e, t) {\n      for (var r, n = e + \"\", o = 0; o < n.length;) {\n        t[p & o] = p & (r ^= 19 * t[p & o]) + n.charCodeAt(o++);\n      }\n\n      return m(t);\n    }\n\n    function m(e) {\n      return String.fromCharCode.apply(0, e);\n    }\n\n    if (r[\"seed\" + s] = d, f(r.random(), t), e.exports) {\n      e.exports = d;\n\n      try {\n        n = require(\"crypto\");\n      } catch (e) {}\n    } else 0;\n  }([], Math);\n});\nseedrandom.alea = alea, seedrandom.xor128 = xor128, seedrandom.xorwow = xorwow, seedrandom.xorshift7 = xorshift7, seedrandom.xor4096 = xor4096, seedrandom.tychei = tychei;\n\nvar seedrandom$1 = seedrandom,\n    seedrandom_1 = seedrandom$1.alea,\n    MPRandGauss = function () {\n  function e(e, t, r, n, o) {\n    this.mean = e, this.stdDev = t, this.dtype = r, this.nextVal = NaN, this.truncated = n, this.truncated && (this.upper = this.mean + 2 * this.stdDev, this.lower = this.mean - 2 * this.stdDev);\n    var a = o || Math.random();\n    this.random = seedrandom_1(a.toString());\n  }\n\n  return e.prototype.nextValue = function () {\n    if (!isNaN(this.nextVal)) {\n      var e = this.nextVal;\n      return this.nextVal = NaN, e;\n    }\n\n    for (var t, r, n = !1; !n;) {\n      var o = void 0,\n          a = void 0,\n          i = void 0;\n\n      do {\n        i = (o = 2 * this.random() - 1) * o + (a = 2 * this.random() - 1) * a;\n      } while (i >= 1 || 0 === i);\n\n      var s = Math.sqrt(-2 * Math.log(i) / i);\n      t = this.mean + this.stdDev * o * s, r = this.mean + this.stdDev * a * s, this.truncated && !this.isValidTruncated(t) || (n = !0);\n    }\n\n    return this.truncated && !this.isValidTruncated(r) || (this.nextVal = this.convertValue(r)), this.convertValue(t);\n  }, e.prototype.convertValue = function (e) {\n    return null == this.dtype || \"float32\" === this.dtype ? e : Math.round(e);\n  }, e.prototype.isValidTruncated = function (e) {\n    return e <= this.upper && e >= this.lower;\n  }, e;\n}();\n\nfunction clone_(e) {\n  var t = convertToTensor(e, \"x\", \"clone\", null);\n  return ENV.engine.runKernel(function (e) {\n    return Tensor.make(t.shape, {\n      dataId: t.dataId\n    }, t.dtype);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.toFloat();\n      }\n    };\n  });\n}\n\nfunction eye_(e, t, r, n) {\n  void 0 === n && (n = \"float32\"), null == t && (t = e);\n\n  for (var o = buffer([e, t], n), a = e <= t ? e : t, i = 0; i < a; ++i) {\n    o.set(1, i, i);\n  }\n\n  var s = o.toTensor().as2D(e, t);\n  if (null == r) return s;\n  if (1 === r.length) return tile(expandDims(s, 0), [r[0], 1, 1]);\n  if (2 === r.length) return tile(expandDims(expandDims(s, 0), 0), [r[0], r[1], 1, 1]);\n  if (3 === r.length) return tile(expandDims(expandDims(expandDims(s, 0), 0), 0), [r[0], r[1], r[2], 1, 1]);\n  throw new Error(\"eye() currently supports only 1D and 2D batchShapes, but received \" + r.length + \"D.\");\n}\n\nfunction randomNormal_(e, t, r, n, o) {\n  if (void 0 === t && (t = 0), void 0 === r && (r = 1), null != n && \"bool\" === n) throw new Error(\"Unsupported data type \" + n);\n\n  for (var a = new MPRandGauss(t, r, n, !1, o), i = buffer(e, n), s = 0; s < i.values.length; s++) {\n    i.values[s] = a.nextValue();\n  }\n\n  return i.toTensor();\n}\n\nfunction truncatedNormal_(e, t, r, n, o) {\n  if (void 0 === t && (t = 0), void 0 === r && (r = 1), null != n && \"bool\" === n) throw new Error(\"Unsupported data type \" + n);\n\n  for (var a = new MPRandGauss(t, r, n, !0, o), i = buffer(e, n), s = 0; s < i.values.length; s++) {\n    i.values[s] = a.nextValue();\n  }\n\n  return i.toTensor();\n}\n\nfunction randomUniform_(e, t, r, n) {\n  void 0 === t && (t = 0), void 0 === r && (r = 1), void 0 === n && (n = \"float32\");\n\n  for (var o = buffer(e, n), a = 0; a < o.values.length; a++) {\n    o.values[a] = randUniform(t, r);\n  }\n\n  return o.toTensor();\n}\n\nfunction rand_(e, t, r) {\n  var n = sizeFromShape(e),\n      o = null;\n  if (null == r || \"float32\" === r) o = new Float32Array(n);else if (\"int32\" === r) o = new Int32Array(n);else {\n    if (\"bool\" !== r) throw new Error(\"Unknown data type \" + r);\n    o = new Uint8Array(n);\n  }\n\n  for (var a = 0; a < n; a++) {\n    o[a] = t();\n  }\n\n  return Tensor.make(e, {\n    values: o\n  }, r);\n}\n\nfunction multinomial_(e, t, r, n) {\n  void 0 === n && (n = !1);\n  var o = convertToTensor(e, \"logits\", \"multinomial\"),\n      a = o.size,\n      i = o.rank;\n  if (a < 2) throw new Error(\"Error in multinomial: you need at least 2 outcomes, but got \" + a + \".\");\n  if (i > 2) throw new Error(\"Rank of probabilities must be 1 or 2, but is \" + i);\n  r = r || Math.random();\n  var s = 1 === i ? o.as2D(1, -1) : o,\n      u = ENV.engine.runKernel(function (e) {\n    return e.multinomial(s, n, t, r);\n  }, {\n    logits2D: s\n  });\n  return 1 === i ? u.as1D() : u;\n}\n\nfunction oneHot_(e, t, r, n) {\n  void 0 === r && (r = 1), void 0 === n && (n = 0);\n  var o = convertToTensor(e, \"indices\", \"oneHot\", \"int32\");\n  if (t < 2) throw new Error(\"Error in oneHot: depth must be >=2, but it is \" + t);\n  return ENV.engine.runKernel(function (e) {\n    return e.oneHot(o, t, r, n);\n  }, {\n    $indices: o\n  }, function (e) {\n    return {\n      $indices: function $indices() {\n        return zeros(o.shape, \"float32\");\n      }\n    };\n  });\n}\n\nfunction fromPixels_(e, t) {\n  if (void 0 === t && (t = 3), t > 4) throw new Error(\"Cannot construct Tensor with more than 4 channels from pixels.\");\n  return ENV.engine.fromPixels(e, t);\n}\n\nfunction toPixels(e, t) {\n  return __awaiter(this, void 0, void 0, function () {\n    var r, n, o, a, i, s, u, l, c, p, d, h, f, m, g, v, y, x, T, E;\n    return __generator(this, function (w) {\n      switch (w.label) {\n        case 0:\n          if (r = convertToTensor(e, \"img\", \"toPixels\"), e instanceof Tensor || (r = r.toInt()), 2 !== r.rank && 3 !== r.rank) throw new Error(\"toPixels only supports rank 2 or 3 tensors, got rank \" + r.rank + \".\");\n          if (n = r.shape.slice(0, 2), o = n[0], a = n[1], (i = 2 === r.rank ? 1 : r.shape[2]) > 4 || 2 === i) throw new Error(\"toPixels only supports depth of size 1, 3 or 4 but got \" + i);\n          return s = r.min(), u = r.max(), [4, s.data()];\n\n        case 1:\n          return l = w.sent()[0], [4, u.data()];\n\n        case 2:\n          if (c = w.sent()[0], s.dispose(), u.dispose(), \"float32\" === r.dtype) {\n            if (l < 0 || c > 1) throw new Error(\"Tensor values for a float32 Tensor must be in the range [0 - 1] but got range [\" + l + \" - \" + c + \"].\");\n          } else {\n            if (\"int32\" !== r.dtype) throw new Error(\"Unsupported type for toPixels: \" + r.dtype + \". Please use float32 or int32 tensors.\");\n            if (l < 0 || c > 255) throw new Error(\"Tensor values for a int32 Tensor must be in the range [0 - 255] but got range [\" + l + \" - \" + c + \"].\");\n          }\n\n          return [4, r.data()];\n\n        case 3:\n          for (p = w.sent(), d = \"float32\" === r.dtype ? 255 : 1, h = new Uint8ClampedArray(a * o * 4), f = 0; f < o * a; ++f) {\n            m = void 0, g = void 0, v = void 0, y = void 0, 1 === i ? (m = p[f] * d, g = p[f] * d, v = p[f] * d, y = 255) : 3 === i ? (m = p[3 * f] * d, g = p[3 * f + 1] * d, v = p[3 * f + 2] * d, y = 255) : 4 === i && (m = p[4 * f] * d, g = p[4 * f + 1] * d, v = p[4 * f + 2] * d, y = p[4 * f + 3] * d), h[(x = 4 * f) + 0] = Math.round(m), h[x + 1] = Math.round(g), h[x + 2] = Math.round(v), h[x + 3] = Math.round(y);\n          }\n\n          return null != t && (t.width = a, t.height = o, T = t.getContext(\"2d\"), E = new ImageData(h, a, o), T.putImageData(E, 0, 0)), r !== e && r.dispose(), [2, h];\n      }\n    });\n  });\n}\n\nfunction reshape_(e, t) {\n  var r = convertToTensor(e, \"x\", \"reshape\", null);\n  t = inferFromImplicitShape(t, r.size), assert(r.size === sizeFromShape(t), \"new shape and old shape must have the same number of elements.\");\n  return ENV.engine.runKernel(function (e) {\n    return e.reshape(r, t);\n  }, {\n    $x: r\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.reshape(r.shape);\n      }\n    };\n  });\n}\n\nfunction squeeze_(e, t) {\n  var r = convertToTensor(e, \"x\", \"squeeze\");\n  return reshape(r, squeezeShape(r.shape, t).newShape);\n}\n\nfunction cast_(e, t) {\n  var r = convertToTensor(e, \"x\", \"cast\");\n  return ENV.engine.runKernel(function (e) {\n    return e.cast(r, t);\n  }, {\n    $x: r\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.clone();\n      }\n    };\n  });\n}\n\nfunction tile_(e, t) {\n  var r = convertToTensor(e, \"x\", \"tile\");\n  assert(r.rank === t.length, \"Error in transpose: rank of input \" + r.rank + \" must match length of reps \" + t + \".\");\n  return ENV.engine.runKernel(function (e) {\n    return e.tile(r, t);\n  }, {\n    $x: r\n  }, function (e) {\n    return {\n      $x: function $x() {\n        var n = zerosLike(r);\n        if (1 === r.rank) for (var o = 0; o < t[0]; ++o) {\n          n = n.add(e.slice([o * r.shape[0]], [r.shape[0]]));\n        } else if (2 === r.rank) for (o = 0; o < t[0]; ++o) {\n          for (var a = 0; a < t[1]; ++a) {\n            n = n.add(e.slice([o * r.shape[0], a * r.shape[1]], [r.shape[0], r.shape[1]]));\n          }\n        } else if (3 === r.rank) for (o = 0; o < t[0]; ++o) {\n          for (a = 0; a < t[1]; ++a) {\n            for (var i = 0; i < t[2]; ++i) {\n              n = n.add(e.slice([o * r.shape[0], a * r.shape[1], i * r.shape[2]], [r.shape[0], r.shape[1], r.shape[2]]));\n            }\n          }\n        } else {\n          if (4 !== r.rank) throw new Error(\"Gradient for tile operation is not implemented for rank-\" + r.rank + \" tensors yet.\");\n\n          for (o = 0; o < t[0]; ++o) {\n            for (a = 0; a < t[1]; ++a) {\n              for (i = 0; i < t[2]; ++i) {\n                for (var s = 0; s < t[3]; ++s) {\n                  n = n.add(e.slice([o * r.shape[0], a * r.shape[1], i * r.shape[2], s * r.shape[3]], [r.shape[0], r.shape[1], r.shape[2], r.shape[3]]));\n                }\n              }\n            }\n          }\n        }\n        return n;\n      }\n    };\n  });\n}\n\nfunction pad1d_(e, t, r) {\n  return void 0 === r && (r = 0), assert(2 === t.length, \"Invalid number of paddings. Must be length of 2.\"), pad(e, [t], r);\n}\n\nfunction pad2d_(e, t, r) {\n  return void 0 === r && (r = 0), assert(2 === t.length && 2 === t[0].length && 2 === t[1].length, \"Invalid number of paddings. Must be length of 2 each.\"), pad(e, t, r);\n}\n\nfunction pad3d_(e, t, r) {\n  return void 0 === r && (r = 0), assert(3 === t.length && 2 === t[0].length && 2 === t[1].length && 2 === t[2].length, \"Invalid number of paddings. Must be length of 2 each.\"), pad(e, t, r);\n}\n\nfunction pad4d_(e, t, r) {\n  return void 0 === r && (r = 0), assert(4 === t.length && 2 === t[0].length && 2 === t[1].length && 2 === t[2].length && 2 === t[3].length, \"Invalid number of paddings. Must be length of 2 each.\"), pad(e, t, r);\n}\n\nfunction pad_(e, t, r) {\n  void 0 === r && (r = 0);\n  var n = convertToTensor(e, \"x\", \"pad\");\n  if (0 === n.rank) throw new Error(\"pad(scalar) is not defined. Pass non-scalar to pad\");\n  var o = t.map(function (e) {\n    return e[0];\n  });\n  return ENV.engine.runKernel(function (e) {\n    return e.pad(n, t, r);\n  }, {\n    $x: n\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.slice(o, n.shape);\n      }\n    };\n  });\n}\n\nfunction stack_(e, t) {\n  void 0 === t && (t = 0);\n  var r = convertToTensorArray(e, \"tensors\", \"stack\");\n  if (assert(r.length >= 1, \"Pass at least one tensor to tf.stack\"), 1 === r.length) return r[0].expandDims(t);\n  var n = r[0].rank,\n      o = r[0].shape,\n      a = r[0].dtype;\n  assert(t <= n, \"Axis must be <= rank of the tensor\"), r.forEach(function (e) {\n    assertShapesMatch(o, e.shape, \"All tensors passed to stack must have matching shapes\");\n  }), r.forEach(function (e) {\n    assert(a === e.dtype, \"All tensors passed to stack must have matching dtypes\");\n  });\n  var i = r.map(function (e) {\n    return e.expandDims(t);\n  });\n  return concat(i, t);\n}\n\nfunction batchToSpaceND_(e, t, r) {\n  var n = convertToTensor(e, \"x\", \"batchToSpaceND\"),\n      o = t.reduce(function (e, t) {\n    return e * t;\n  });\n  assert(n.rank >= 1 + t.length, \"input rank is \" + n.rank + \" but should be > than blockShape.length \" + t.length), assert(r.length === t.length, \"crops.length is \" + r.length + \" but should be equal to blockShape.length  \" + t.length), assert(n.shape[0] % o == 0, \"input tensor batch is \" + n.shape[0] + \" but is not divisible by the product of the elements of blockShape \" + t.join(\" * \") + \" === \" + o);\n  return ENV.engine.runKernel(function (e) {\n    return e.batchToSpaceND(n, t, r);\n  }, {\n    $x: n\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.spaceToBatchND(t, r);\n      }\n    };\n  });\n}\n\nfunction spaceToBatchND_(e, t, r) {\n  var n = convertToTensor(e, \"x\", \"spaceToBatchND\");\n  assert(n.rank >= 1 + t.length, \"input rank \" + n.rank + \" should be > than [blockShape] \" + t.length), assert(r.length === t.length, \"paddings.shape[0] \" + r.length + \" must be equal to [blockShape] \" + t.length), assert(n.shape.reduce(function (e, n, o) {\n    return o > 0 && o <= t.length ? e && (n + r[o - 1][0] + r[o - 1][1]) % t[o - 1] == 0 : e;\n  }, !0), \"input spatial dimensions \" + n.shape.slice(1) + \" with paddings \" + r.toString() + \" must be divisible by blockShapes \" + t.toString());\n  return ENV.engine.runKernel(function (e) {\n    return e.spaceToBatchND(n, t, r);\n  }, {\n    $x: n\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.batchToSpaceND(t, r);\n      }\n    };\n  });\n}\n\nfunction unstack_(e, t) {\n  void 0 === t && (t = 0);\n\n  for (var r, n = convertToTensor(e, \"x\", \"unstack\"), o = n.shape[t], a = Array(n.rank - 1).fill(0), i = 0, s = 0; s < n.rank; s++) {\n    s !== t && (a[i] = n.shape[s], i++);\n  }\n\n  r = Array(o).fill(1);\n  var u = Array(n.rank).fill(0),\n      l = n.shape.slice();\n  return r.map(function (e) {\n    l[t] = e;\n    var r = n.slice(u, l);\n    return u[t] += e, r.reshape(a);\n  });\n}\n\nfunction cumsum_(e, t, r, n) {\n  void 0 === t && (t = 0), void 0 === r && (r = !1), void 0 === n && (n = !1);\n  var o = convertToTensor(e, \"x\", \"cumsum\"),\n      a = getAxesPermutation([t |= 0], o.rank),\n      i = o;\n  null != a && (i = o.transpose(a));\n  var s = getInnerMostAxes(1, o.rank)[0],\n      u = ENV.engine.runKernel(function (e) {\n    return e.cumsum(i, s, r, n);\n  }, {\n    permutedX: i\n  }, function (e) {\n    return {\n      permutedX: function permutedX() {\n        return e.cumsum(t, r, !n);\n      }\n    };\n  });\n  return null != a && (u = u.transpose(a)), u;\n}\n\nfunction expandDims_(e, t) {\n  void 0 === t && (t = 0);\n  var r = convertToTensor(e, \"x\", \"expandDims\");\n  assert(t <= r.rank, \"Axis must be <= rank of the tensor\");\n  var n = r.shape.slice();\n  return t < 0 && (assert(-(r.rank + 1) <= t, \"Axis must be in the interval [\" + -(r.rank + 1) + \", \" + r.rank + \"]\"), t = r.rank + t + 1), n.splice(t, 0, 1), reshape(r, n);\n}\n\nfunction depthToSpace_(e, t, r) {\n  void 0 === r && (r = \"NHWC\");\n  var n = convertToTensor(e, \"x\", \"depthToSpace\"),\n      o = \"NHWC\" === r ? n.shape[1] : n.shape[2],\n      a = \"NHWC\" === r ? n.shape[2] : n.shape[3],\n      i = \"NHWC\" === r ? n.shape[3] : n.shape[1];\n  return assert(o * t >= 0, \"Negative dimension size caused by overflow when multiplying\\n      \" + o + \" and \" + t + \"  for depthToSpace with input shape\\n      \" + n.shape), assert(a * t >= 0, \"Negative dimension size caused by overflow when multiplying\\n      \" + a + \" and \" + t + \" for depthToSpace with input shape\\n          \" + n.shape), assert(i % (t * t) == 0, \"Dimension size must be evenly divisible by \" + t * t + \" but is \" + i + \" for depthToSpace with input shape \" + n.shape), ENV.engine.runKernel(function (e) {\n    return e.depthToSpace(n, t, r);\n  }, {\n    $x: n\n  });\n}\n\nfunction setdiff1dAsync_(e, t) {\n  return __awaiter(this, void 0, void 0, function () {\n    var r, n, o, a, i, s, u, l, c, p;\n    return __generator(this, function (d) {\n      switch (d.label) {\n        case 0:\n          return r = convertToTensor(e, \"x\", \"setdiff1d\"), n = convertToTensor(t, \"y\", \"setdiff1d\"), assert(r.dtype === n.dtype, \"x and y should have the same dtype, but got x (\" + r.dtype + \") and y (\" + n.dtype + \").\"), assert(1 === r.rank, \"x should be 1D tensor, but got x (\" + r.shape + \").\"), assert(1 === n.rank, \"y should be 1D tensor, but got y (\" + n.shape + \").\"), [4, r.data()];\n\n        case 1:\n          return o = d.sent(), [4, n.data()];\n\n        case 2:\n          for (a = d.sent(), i = new Set(a), s = 0, c = 0; c < o.length; c++) {\n            i.has(o[c]) || s++;\n          }\n\n          for (u = new TensorBuffer([s], r.dtype), l = new TensorBuffer([s], \"int32\"), c = 0, p = 0; c < o.length; c++) {\n            i.has(o[c]) || (u.values[p] = o[c], l.values[p] = c, p++);\n          }\n\n          return [2, [u.toTensor(), l.toTensor()]];\n      }\n    });\n  });\n}\n\nfunction buffer(e, t, r) {\n  return void 0 === t && (t = \"float32\"), new TensorBuffer(e, t = t || \"float32\", r);\n}\n\nfunction print(e, t) {\n  void 0 === t && (t = !1), console.log(e.toString(t));\n}\n\nvar batchToSpaceND = op({\n  batchToSpaceND_: batchToSpaceND_\n}),\n    cast = op({\n  cast_: cast_\n}),\n    clone = op({\n  clone_: clone_\n}),\n    cumsum = op({\n  cumsum_: cumsum_\n}),\n    depthToSpace = op({\n  depthToSpace_: depthToSpace_\n}),\n    expandDims = op({\n  expandDims_: expandDims_\n}),\n    eye = op({\n  eye_: eye_\n}),\n    fromPixels = op({\n  fromPixels_: fromPixels_\n}),\n    multinomial = op({\n  multinomial_: multinomial_\n}),\n    oneHot = op({\n  oneHot_: oneHot_\n}),\n    pad = op({\n  pad_: pad_\n}),\n    pad1d = op({\n  pad1d_: pad1d_\n}),\n    pad2d = op({\n  pad2d_: pad2d_\n}),\n    pad3d = op({\n  pad3d_: pad3d_\n}),\n    pad4d = op({\n  pad4d_: pad4d_\n}),\n    rand = op({\n  rand_: rand_\n}),\n    randomNormal = op({\n  randomNormal_: randomNormal_\n}),\n    randomUniform = op({\n  randomUniform_: randomUniform_\n}),\n    reshape = op({\n  reshape_: reshape_\n}),\n    spaceToBatchND = op({\n  spaceToBatchND_: spaceToBatchND_\n}),\n    squeeze = op({\n  squeeze_: squeeze_\n}),\n    stack = op({\n  stack_: stack_\n}),\n    tile = op({\n  tile_: tile_\n}),\n    truncatedNormal = op({\n  truncatedNormal_: truncatedNormal_\n}),\n    unstack = op({\n  unstack_: unstack_\n}),\n    setdiff1dAsync = setdiff1dAsync_;\n\nfunction whereImpl(e, t) {\n  for (var r = [], n = 0; n < t.length; n++) {\n    t[n] && r.push(n);\n  }\n\n  var o = buffer(e, \"int32\"),\n      a = buffer([r.length, e.length], \"int32\");\n\n  for (n = 0; n < r.length; n++) {\n    var i = o.indexToLoc(r[n]),\n        s = n * e.length;\n    a.values.set(i, s);\n  }\n\n  return a.toTensor();\n}\n\nvar CPU_HANDOFF_SIZE_THRESHOLD = 10,\n    BEFORE_PAGING_CONSTANT = 300,\n    MATMUL_SHARED_DIM_THRESHOLD = 1e3,\n    MathBackendWebGL = function () {\n  function e(e, t) {\n    if (void 0 === t && (t = !0), this.gpgpu = e, this.delayedStorage = t, this.pendingRead = new WeakMap(), this.pendingDisposal = new WeakSet(), this.lruDataGPU = [], this.numBytesInGPU = 0, this.uploadWaitMs = 0, this.downloadWaitMs = 0, this.binaryCache = {}, this.disposed = !1, ENV.get(\"WEBGL_VERSION\") < 1) throw new Error(\"WebGL is not supported on this device\");\n\n    if (null == e) {\n      var r = getWebGLContext(ENV.get(\"WEBGL_VERSION\"));\n      this.gpgpu = new GPGPUContext(r), this.canvas = r.canvas, this.gpgpuCreatedLocally = !0;\n    } else this.gpgpuCreatedLocally = !1, this.canvas = e.gl.canvas;\n\n    ENV.get(\"WEBGL_PAGING_ENABLED\") && (this.NUM_BYTES_BEFORE_PAGING = window.screen.height * window.screen.width * window.devicePixelRatio * BEFORE_PAGING_CONSTANT), this.textureManager = new TextureManager(this.gpgpu);\n  }\n\n  return e.prototype.register = function (e, t, r) {\n    if (this.texData.has(e)) throw new Error(\"Data buffer is already registered\");\n    this.texData.set(e, {\n      shape: t,\n      dtype: r\n    });\n  }, e.prototype.setDataMover = function (e) {\n    this.texData = new DataStorage(e);\n  }, e.prototype.fromPixels = function (e, t) {\n    if (null == e) throw new Error(\"pixels passed to tf.fromPixels() can not be null\");\n    var r = [e.height, e.width],\n        n = [e.height, e.width, t];\n    if (!(e instanceof HTMLVideoElement || e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof ImageData)) throw new Error(\"pixels passed to tf.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or ImageData, but was \" + e.constructor.name);\n\n    if (e instanceof HTMLVideoElement) {\n      if (null == this.fromPixels2DContext) {\n        if (!ENV.get(\"IS_BROWSER\")) throw new Error(\"Can't read pixels from HTMLImageElement outside the browser.\");\n        if (\"complete\" !== document.readyState) throw new Error(\"The DOM is not ready yet. Please call tf.fromPixels() once the DOM is ready. One way to do that is to add an event listener for `DOMContentLoaded` on the document object\");\n        this.fromPixels2DContext = document.createElement(\"canvas\").getContext(\"2d\");\n      }\n\n      this.fromPixels2DContext.canvas.width = e.width, this.fromPixels2DContext.canvas.height = e.height, this.fromPixels2DContext.drawImage(e, 0, 0, e.width, e.height), e = this.fromPixels2DContext.canvas;\n    }\n\n    var o = this.makeTensorHandle(r, \"int32\");\n    this.texData.get(o.dataId).usage = TextureUsage.PIXELS, this.gpgpu.uploadPixelDataToTexture(this.getTexture(o.dataId), e);\n    var a = new FromPixelsProgram(n),\n        i = this.compileAndRun(a, [o]);\n    return this.disposeData(o.dataId), i;\n  }, e.prototype.makeTensorHandle = function (e, t) {\n    var r = {};\n    return this.register(r, e, t), {\n      dataId: r,\n      shape: e,\n      dtype: t\n    };\n  }, e.prototype.write = function (e, t) {\n    if (null == t) throw new Error(\"MathBackendWebGL.write(): values can not be null\");\n    var r = this.texData.get(e),\n        n = r.texture,\n        o = r.texShape,\n        a = r.usage,\n        i = r.dtype,\n        s = r.isPacked;\n    if (\"complex64\" === i) throw new Error(\"Cannot write to a complex64 dtype. Please use tf.complex(real, imag).\");\n    null != n && (this.releaseTexture(e, n, o, a, s), r.texture = null, r.texShape = null), r.usage = TextureUsage.UPLOAD, r.values = t, this.delayedStorage || this.uploadToGPU(e);\n  }, e.prototype.readSync = function (e) {\n    var t = this.texData.get(e),\n        r = t.values,\n        n = t.dtype,\n        o = t.complexTensors;\n    if (null != r) return this.convertAndCacheOnCPU(e);\n    if (\"string\" === n) return r;\n    var a,\n        i,\n        s = null != this.activeTimers;\n    (s && (a = performance.now()), \"complex64\" === n) ? i = mergeRealAndImagArrays(o.real.dataSync(), o.imag.dataSync()) : i = this.getValuesFromTexture(e);\n    return s && (this.downloadWaitMs += performance.now() - a), this.convertAndCacheOnCPU(e, i);\n  }, e.prototype.read = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t, r, n, o, a, i, s, u, l;\n      return __generator(this, function (c) {\n        switch (c.label) {\n          case 0:\n            if (this.pendingRead.has(e)) return t = this.pendingRead.get(e), [2, new Promise(function (e) {\n              return t.push(e);\n            })];\n            if (r = this.texData.get(e), n = r.texture, o = r.values, a = r.texShape, null != o) return [2, this.convertAndCacheOnCPU(e)];\n            if (this.pendingRead.set(e, []), !ENV.get(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\") && 2 === ENV.get(\"WEBGL_VERSION\")) throw new Error(\"tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.\");\n            return i = this.gpgpu.maybeCreateBufferFromTexture(n, a[0], a[1]), [4, this.gpgpu.createAndWaitForFence()];\n\n          case 1:\n            return c.sent(), s = i instanceof WebGLTexture ? this.getValuesFromTexture(e) : this.gpgpu.downloadFloat32MatrixFromBuffer(i, a[0], a[1]), u = this.convertAndCacheOnCPU(e, s), l = this.pendingRead.get(e), this.pendingRead.delete(e), l.forEach(function (e) {\n              return e(u);\n            }), this.pendingDisposal.has(e) && (this.pendingDisposal.delete(e), this.disposeData(e)), [2, u];\n        }\n      });\n    });\n  }, e.prototype.getValuesFromTexture = function (e) {\n    var t = this.texData.get(e),\n        r = t.shape,\n        n = t.dtype,\n        o = t.texture,\n        a = t.texShape;\n\n    if (ENV.get(\"WEBGL_DOWNLOAD_FLOAT_ENABLED\")) {\n      if (this.texData.get(e).isPacked) {\n        var i = sizeFromShape(r.slice(0, r.length - 2)),\n            s = r.length > 1 ? r[r.length - 2] : 1,\n            u = r[r.length - 1];\n        return this.gpgpu.downloadMatrixFromPackedTexture(o, i, s, u, a[0], a[1]);\n      }\n\n      return this.gpgpu.downloadFloat32MatrixFromOutputTexture(o, a[0], a[1]);\n    }\n\n    var l = this.makeTensorHandle(r, \"float32\");\n    l.size = sizeFromShape(r), this.texData.get(l.dataId).usage = TextureUsage.DOWNLOAD;\n    var c = new EncodeFloatProgram(r);\n    this.compileAndRun(c, [{\n      shape: r,\n      dtype: n,\n      dataId: e\n    }], l, null, !1);\n    var p = this.texData.get(l.dataId),\n        d = this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture, p.texShape[0], p.texShape[1]);\n    return this.disposeData(l.dataId), d;\n  }, e.prototype.time = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t, r, n, o, a, i, s;\n      return __generator(this, function (u) {\n        switch (u.label) {\n          case 0:\n            return t = this.activeTimers, r = [], n = !1, null == this.programTimersStack ? (this.programTimersStack = r, n = !0) : this.activeTimers.push(r), this.activeTimers = r, e(), o = flatten(this.activeTimers.map(function (e) {\n              return e.query;\n            })).filter(function (e) {\n              return null != e;\n            }), a = flatten(this.activeTimers.map(function (e) {\n              return e.name;\n            })).filter(function (e) {\n              return null != e;\n            }), this.activeTimers = t, n && (this.programTimersStack = null), [4, Promise.all(o)];\n\n          case 1:\n            return i = u.sent(), s = {\n              uploadWaitMs: this.uploadWaitMs,\n              downloadWaitMs: this.downloadWaitMs,\n              kernelMs: sum(i),\n              getExtraProfileInfo: function getExtraProfileInfo() {\n                return i.map(function (e, t) {\n                  return {\n                    name: a[t],\n                    ms: e\n                  };\n                }).map(function (e) {\n                  return e.name + \": \" + e.ms;\n                }).join(\", \");\n              },\n              wallMs: null\n            }, this.uploadWaitMs = 0, this.downloadWaitMs = 0, [2, s];\n        }\n      });\n    });\n  }, e.prototype.memory = function () {\n    return {\n      unreliable: !1,\n      numBytesInGPU: this.numBytesInGPU\n    };\n  }, e.prototype.startTimer = function () {\n    return ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") > 0 ? this.gpgpu.beginQuery() : {\n      startMs: performance.now(),\n      endMs: null\n    };\n  }, e.prototype.endTimer = function (e) {\n    return ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") > 0 ? (this.gpgpu.endQuery(), e) : (e.endMs = performance.now(), e);\n  }, e.prototype.getQueryTime = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t;\n      return __generator(this, function (r) {\n        return ENV.get(\"WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION\") > 0 ? [2, this.gpgpu.waitForQueryAndGetTime(e)] : [2, (t = e).endMs - t.startMs];\n      });\n    });\n  }, e.prototype.disposeData = function (e) {\n    if (!this.pendingDisposal.has(e)) if (this.pendingRead.has(e)) this.pendingDisposal.add(e);else if (this.texData.has(e)) {\n      var t = this.texData.get(e),\n          r = t.texture,\n          n = t.texShape,\n          o = t.usage,\n          a = t.complexTensors,\n          i = t.isPacked;\n      null != r && this.releaseTexture(e, r, n, o, i), null != a && (a.real.dispose(), a.imag.dispose()), this.texData.delete(e);\n    }\n  }, e.prototype.getTexture = function (e) {\n    return this.uploadToGPU(e), this.texData.get(e).texture;\n  }, e.prototype.getCPUBackend = function () {\n    return ENV.get(\"WEBGL_CPU_FORWARD\") ? (null == this.cpuBackend && (this.cpuBackend = ENV.findBackend(\"cpu\")), this.cpuBackend) : null;\n  }, e.prototype.shouldExecuteOnCPU = function (e, t) {\n    var r = this;\n    return void 0 === t && (t = CPU_HANDOFF_SIZE_THRESHOLD), null != this.getCPUBackend() && e.every(function (e) {\n      return null == r.texData.get(e.dataId).texture && e.size < t;\n    });\n  }, e.prototype.getGPGPUContext = function () {\n    return this.gpgpu;\n  }, e.prototype.getCanvas = function () {\n    return this.canvas;\n  }, e.prototype.complex = function (e, t) {\n    var r = this.makeOutputArray(e.shape, \"complex64\");\n    return this.texData.get(r.dataId).complexTensors = {\n      real: ENV.engine.keep(e.clone()),\n      imag: ENV.engine.keep(t.clone())\n    }, r;\n  }, e.prototype.real = function (e) {\n    return this.texData.get(e.dataId).complexTensors.real.clone();\n  }, e.prototype.imag = function (e) {\n    return this.texData.get(e.dataId).complexTensors.imag.clone();\n  }, e.prototype.slice = function (e, t, r) {\n    if (this.shouldExecuteOnCPU([e])) return this.cpuBackend.slice(e, t, r);\n    var n = new SliceProgram(r),\n        o = n.getCustomSetupFunc(t);\n    return this.compileAndRun(n, [e], null, o);\n  }, e.prototype.stridedSlice = function (e, t, r, n, o, a, i, s, u) {\n    if (this.shouldExecuteOnCPU([e])) return this.cpuBackend.stridedSlice(e, t, r, n, o, a, i, s, u);\n    var l = getStridedSlicedInfo(e.shape, t, r, n, o, a, i, s, u),\n        c = l[0],\n        p = l[1],\n        d = l[2],\n        h = p.filter(function (e, t) {\n      return -1 === d.indexOf(t);\n    });\n    if (h.some(function (e) {\n      return 0 === e;\n    })) return tensor([], h);\n    var f = new StridedSliceProgram(c, n, p, d);\n    return this.compileAndRun(f, [e]);\n  }, e.prototype.reverse = function (e, t) {\n    var r = new ReverseProgram(e.shape, t);\n    return this.compileAndRun(r, [e]);\n  }, e.prototype.concat2Tensors = function (e, t, r) {\n    var n = computeOutShape([e.shape, t.shape], r),\n        o = e.as2D(-1, sizeFromShape(e.shape.slice(r))),\n        a = t.as2D(-1, sizeFromShape(t.shape.slice(r))),\n        i = new ConcatProgram(o.shape, a.shape);\n    return this.compileAndRun(i, [o, a]).reshape(n);\n  }, e.prototype.concat = function (e, t) {\n    if (this.shouldExecuteOnCPU(e)) return this.cpuBackend.concat(e, t);\n    if (1 === e.length) return e[0];\n\n    for (var r = e[0], n = 1; n < e.length; ++n) {\n      r = this.concat2Tensors(r, e[n], t);\n    }\n\n    return r;\n  }, e.prototype.neg = function (e) {\n    var t = new UnaryOpProgram(e.shape, NEG);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.batchMatMul = function (e, t, r, n) {\n    var o = r ? e.shape[2] : e.shape[1],\n        a = n ? t.shape[1] : t.shape[2],\n        i = r ? e.shape[1] : e.shape[2],\n        s = e.shape[0];\n\n    if ((1 === o || 1 === a) && i > MATMUL_SHARED_DIM_THRESHOLD) {\n      r && (e = e.transpose([0, 2, 1])), n && (t = t.transpose([0, 2, 1]));\n      var u = 1 === a ? e : e.as3D(s, i, 1),\n          l = 1 === a ? 2 : 1,\n          c = 1 === a ? t.as3D(s, 1, i) : t;\n      return this.multiply(u, c).sum(l, !0);\n    }\n\n    if (1 === s) {\n      var p = e.as2D(e.shape[1], e.shape[2]),\n          d = t.as2D(t.shape[1], t.shape[2]),\n          h = new MatMulPackedProgram(p.shape, d.shape, [o, a], r, n),\n          f = this.compileAndRun(h, [p, d]);\n      return f.reshape([1, f.shape[0], f.shape[1]]);\n    }\n\n    return this.compileAndRun(new MatMulProgram(e.shape, t.shape, r, n), [e, t]);\n  }, e.prototype.multiply = function (e, t) {\n    if (\"complex64\" === e.dtype) {\n      var r = this.texData.get(e.dataId),\n          n = this.texData.get(t.dataId),\n          o = new BinaryOpComplexProgram(COMPLEX_MULTIPLY.REAL, e.shape, t.shape),\n          a = new BinaryOpComplexProgram(COMPLEX_MULTIPLY.IMAG, e.shape, t.shape),\n          i = [this.makeComplexComponentTensorHandle(e, r.complexTensors.real), this.makeComplexComponentTensorHandle(e, r.complexTensors.imag), this.makeComplexComponentTensorHandle(t, n.complexTensors.real), this.makeComplexComponentTensorHandle(t, n.complexTensors.imag)],\n          s = this.compileAndRun(o, i),\n          u = this.compileAndRun(a, i),\n          l = this.complex(s, u);\n      return s.dispose(), u.dispose(), l;\n    }\n\n    if (this.shouldExecuteOnCPU([e, t])) return this.cpuBackend.multiply(e, t);\n    var c = new BinaryOpProgram(MUL, e.shape, t.shape),\n        p = this.makeOutputArray(c.outputShape, e.dtype);\n    return this.compileAndRun(c, [e, t], p);\n  }, e.prototype.batchNormalization = function (e, t, r, n, o, a) {\n    var i = [e, t, r],\n        s = null;\n    null != a && (s = a.shape, i.push(a));\n    var u = null;\n\n    if (null != o && (u = o.shape, i.push(o)), ENV.get(\"WEBGL_PACK_BATCHNORMALIZATION\")) {\n      var l = new BatchNormPackedProgram(e.shape, t.shape, r.shape, s, u, n);\n      return this.compileAndRun(l, i);\n    }\n\n    var c = new BatchNormProgram(e.shape, t.shape, r.shape, s, u, n);\n    return this.compileAndRun(c, i);\n  }, e.prototype.localResponseNormalization4D = function (e, t, r, n, o) {\n    var a = new LRNProgram(e.shape, t, r, n, o);\n    return this.compileAndRun(a, [e]);\n  }, e.prototype.LRNGrad = function (e, t, r, n, o, a, i) {\n    var s = new LRNGradProgram(t.shape, n, o, a, i);\n    return this.compileAndRun(s, [t, r, e]);\n  }, e.prototype.tile = function (e, t) {\n    var r = new TileProgram(e.shape, t);\n    return this.compileAndRun(r, [e]);\n  }, e.prototype.pad = function (e, t, r) {\n    var n = new PadProgram(e.shape, t, r);\n    return this.compileAndRun(n, [e]);\n  }, e.prototype.transpose = function (e, t) {\n    var r = new TransposeProgram(e.shape, t);\n    return this.compileAndRun(r, [e]);\n  }, e.prototype.gather = function (e, t, r) {\n    var n = new GatherProgram(e.shape, t.size, r);\n    return this.compileAndRun(n, [e, t]);\n  }, e.prototype.batchToSpaceND = function (e, t, r) {\n    assert(e.rank <= 4, \"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet\");\n    var n = t.reduce(function (e, t) {\n      return e * t;\n    }),\n        o = getReshaped(e.shape, t, n),\n        a = getPermuted(o.length, t.length),\n        i = getReshapedPermuted(e.shape, t, n),\n        s = getSliceBeginCoords(r, t.length),\n        u = getSliceSize(i, r, t.length);\n    return e.reshape(o).transpose(a).reshape(i).slice(s, u);\n  }, e.prototype.spaceToBatchND = function (e, t, r) {\n    assert(e.rank <= 4, \"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet\");\n    var n = t.reduce(function (e, t) {\n      return e * t;\n    }),\n        o = [[0, 0]];\n    o.push.apply(o, r);\n\n    for (var a = 1 + t.length; a < e.shape.length; ++a) {\n      o.push([0, 0]);\n    }\n\n    var i = e.pad(o),\n        s = getReshaped(i.shape, t, n, !1),\n        u = getPermuted(s.length, t.length, !1),\n        l = getReshapedPermuted(i.shape, t, n, !1);\n    return i.reshape(s).transpose(u).reshape(l);\n  }, e.prototype.reduce = function (e, t, r) {\n    var n = e.shape[0],\n        o = e.shape[1],\n        a = computeOptimalWindowSize(o),\n        i = new ReduceProgram({\n      windowSize: a,\n      inSize: o,\n      batchSize: n\n    }, t),\n        s = i.outputShape,\n        u = s[0],\n        l = s[1],\n        c = this.makeOutputArray([u, l], r);\n    return this.compileAndRun(i, [e], c), 1 === c.shape[1] ? c : this.reduce(c, t, r);\n  }, e.prototype.argReduce = function (e, t, r) {\n    void 0 === r && (r = null);\n    var n = e.shape[0],\n        o = e.shape[1];\n    null != r && (n = r.shape[0], o = r.shape[1]);\n    var a = computeOptimalWindowSize(o),\n        i = new ArgMinMaxProgram({\n      windowSize: a,\n      inSize: o,\n      batchSize: n\n    }, t, null == r),\n        s = i.outputShape,\n        u = s[0],\n        l = s[1],\n        c = this.makeOutputArray([u, l], \"int32\"),\n        p = [e];\n    return null != r && p.push(r), this.compileAndRun(i, p, c), 1 === c.shape[1] ? c : this.argReduce(e, t, c);\n  }, e.prototype.sum = function (e, t) {\n    assertAxesAreInnerMostDims(\"sum\", t, e.rank);\n    var r = computeOutAndReduceShapes(e.shape, t),\n        n = r[0],\n        o = sizeFromShape(r[1]),\n        a = e.as2D(-1, o),\n        i = sumOutType(e.dtype);\n    return this.reduce(a, \"sum\", i).reshape(n);\n  }, e.prototype.prod = function (e, t) {\n    var r = computeOutAndReduceShapes(e.shape, t),\n        n = r[0],\n        o = sizeFromShape(r[1]),\n        a = e.as2D(-1, o),\n        i = sumOutType(e.dtype);\n    return this.reduce(a, \"prod\", i).reshape(n);\n  }, e.prototype.unsortedSegmentSum = function (e, t, r) {\n    var n = 0,\n        o = getAxesPermutation([n], e.rank),\n        a = e;\n    null != o && (a = e.transpose(o), n = getInnerMostAxes(1, e.rank)[0]);\n    var i = computeOutShape$1(a.shape, n, r),\n        s = sizeFromShape([a.shape[n]]),\n        u = a.as2D(-1, s),\n        l = sumOutType(e.dtype),\n        c = this.segOpCompute(u, \"unsortedSegmentSum\", t, l, r).reshape(i);\n    return null != o && (c = c.transpose(getUndoAxesPermutation(o))), c;\n  }, e.prototype.segOpCompute = function (e, t, r, n, o) {\n    var a = e.shape[0],\n        i = e.shape[1],\n        s = segOpComputeOptimalWindowSize(i, o),\n        u = new SegmentOpProgram({\n      windowSize: s,\n      inSize: i,\n      batchSize: a,\n      numSegments: o\n    }, t),\n        l = u.outputShape,\n        c = l[0],\n        p = l[1],\n        d = this.makeOutputArray([c, p], n);\n    return this.compileAndRun(u, [e, r], d), d.shape[1] === o ? d : (r = range(0, o).tile([i / s]), this.segOpCompute(d, t, r, n, o));\n  }, e.prototype.argMin = function (e, t) {\n    var r = [t];\n    assertAxesAreInnerMostDims(\"argMin\", r, e.rank);\n    var n = computeOutAndReduceShapes(e.shape, r),\n        o = n[0],\n        a = sizeFromShape(n[1]),\n        i = e.as2D(-1, a);\n    return this.argReduce(i, \"min\").reshape(o);\n  }, e.prototype.argMax = function (e, t) {\n    var r = [t];\n    assertAxesAreInnerMostDims(\"argMax\", r, e.rank);\n    var n = computeOutAndReduceShapes(e.shape, r),\n        o = n[0],\n        a = sizeFromShape(n[1]),\n        i = e.as2D(-1, a);\n    return this.argReduce(i, \"max\").reshape(o);\n  }, e.prototype.cumsum = function (e, t, r, n) {\n    if (t !== e.rank - 1) throw new Error(\"WebGL cumsum shader expects an inner-most axis=\" + (e.rank - 1) + \" but got axis=\" + t);\n    var o = new CumSumProgram(e.shape, r, n);\n    return this.compileAndRun(o, [e]);\n  }, e.prototype.equal = function (e, t) {\n    var r = new BinaryOpProgram(EQUAL, e.shape, t.shape),\n        n = this.makeOutputArray(r.outputShape, \"bool\");\n    return this.compileAndRun(r, [e, t], n);\n  }, e.prototype.notEqual = function (e, t) {\n    var r = new BinaryOpProgram(NOT_EQUAL, e.shape, t.shape),\n        n = this.makeOutputArray(r.outputShape, \"bool\");\n    return this.compileAndRun(r, [e, t], n);\n  }, e.prototype.less = function (e, t) {\n    if (this.shouldExecuteOnCPU([e, t])) return this.cpuBackend.less(e, t);\n    var r = new BinaryOpProgram(LESS, e.shape, t.shape),\n        n = this.makeOutputArray(r.outputShape, \"bool\");\n    return this.compileAndRun(r, [e, t], n);\n  }, e.prototype.lessEqual = function (e, t) {\n    var r = new BinaryOpProgram(LESS_EQUAL, e.shape, t.shape),\n        n = this.makeOutputArray(r.outputShape, \"bool\");\n    return this.compileAndRun(r, [e, t], n);\n  }, e.prototype.greater = function (e, t) {\n    if (this.shouldExecuteOnCPU([e, t])) return this.cpuBackend.greater(e, t);\n    var r = new BinaryOpProgram(GREATER, e.shape, t.shape),\n        n = this.makeOutputArray(r.outputShape, \"bool\");\n    return this.compileAndRun(r, [e, t], n);\n  }, e.prototype.greaterEqual = function (e, t) {\n    var r = new BinaryOpProgram(GREATER_EQUAL, e.shape, t.shape),\n        n = this.makeOutputArray(r.outputShape, \"bool\");\n    return this.compileAndRun(r, [e, t], n);\n  }, e.prototype.logicalNot = function (e) {\n    var t = new UnaryOpProgram(e.shape, LOGICAL_NOT);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.logicalAnd = function (e, t) {\n    var r = new BinaryOpProgram(LOGICAL_AND, e.shape, t.shape),\n        n = this.makeOutputArray(r.outputShape, \"bool\");\n    return this.compileAndRun(r, [e, t], n);\n  }, e.prototype.logicalOr = function (e, t) {\n    var r = new BinaryOpProgram(LOGICAL_OR, e.shape, t.shape),\n        n = this.makeOutputArray(r.outputShape, \"bool\");\n    return this.compileAndRun(r, [e, t], n);\n  }, e.prototype.select = function (e, t, r) {\n    var n = new SelectProgram(e.rank, t.shape, t.rank),\n        o = this.makeOutputArray(n.outputShape, upcastType(t.dtype, r.dtype));\n    return this.compileAndRun(n, [e, t, r], o);\n  }, e.prototype.where = function (e) {\n    warn(\"tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead\");\n    var t = e.dataSync();\n    return whereImpl(e.shape, t);\n  }, e.prototype.topk = function (e, t, r) {\n    return topkImpl(e.dataSync(), e.shape, e.dtype, t, r);\n  }, e.prototype.min = function (e, t) {\n    assertAxesAreInnerMostDims(\"min\", t, e.rank);\n    var r = computeOutAndReduceShapes(e.shape, t),\n        n = r[0],\n        o = sizeFromShape(r[1]),\n        a = e.as2D(-1, o);\n    return this.reduce(a, \"min\", a.dtype).reshape(n);\n  }, e.prototype.minimum = function (e, t) {\n    if (this.shouldExecuteOnCPU([e, t])) return this.cpuBackend.minimum(e, t);\n    var r = new BinaryOpProgram(MIN, e.shape, t.shape);\n    return this.compileAndRun(r, [e, t]);\n  }, e.prototype.mod = function (e, t) {\n    var r = new BinaryOpProgram(MOD, e.shape, t.shape),\n        n = r.getCustomSetupFunc();\n    return this.compileAndRun(r, [e, t], null, n);\n  }, e.prototype.max = function (e, t) {\n    assertAxesAreInnerMostDims(\"max\", t, e.rank);\n    var r = computeOutAndReduceShapes(e.shape, t),\n        n = r[0],\n        o = sizeFromShape(r[1]),\n        a = e.as2D(-1, o);\n    return this.reduce(a, \"max\", a.dtype).reshape(n);\n  }, e.prototype.maximum = function (e, t) {\n    if (this.shouldExecuteOnCPU([e, t])) return this.cpuBackend.maximum(e, t);\n    var r = new BinaryOpProgram(MAX, e.shape, t.shape);\n    return this.compileAndRun(r, [e, t]);\n  }, e.prototype.all = function (e, t) {\n    assertAxesAreInnerMostDims(\"all\", t, e.rank);\n    var r = computeOutAndReduceShapes(e.shape, t),\n        n = r[0],\n        o = sizeFromShape(r[1]),\n        a = e.as2D(-1, o);\n    return this.reduce(a, \"all\", a.dtype).reshape(n);\n  }, e.prototype.any = function (e, t) {\n    assertAxesAreInnerMostDims(\"any\", t, e.rank);\n    var r = computeOutAndReduceShapes(e.shape, t),\n        n = r[0],\n        o = sizeFromShape(r[1]),\n        a = e.as2D(-1, o);\n    return this.reduce(a, \"any\", a.dtype).reshape(n);\n  }, e.prototype.squaredDifference = function (e, t) {\n    var r = new BinaryOpProgram(SQUARED_DIFFERENCE, e.shape, t.shape);\n    return this.compileAndRun(r, [e, t]);\n  }, e.prototype.realDivide = function (e, t) {\n    var r = new BinaryOpProgram(DIV, e.shape, t.shape),\n        n = this.makeOutputArray(r.outputShape, \"float32\");\n    return this.compileAndRun(r, [e, t], n);\n  }, e.prototype.floorDiv = function (e, t) {\n    var r = new BinaryOpProgram(INT_DIV, e.shape, t.shape),\n        n = this.makeOutputArray(r.outputShape, \"int32\");\n    return this.compileAndRun(r, [e, t], n);\n  }, e.prototype.add = function (e, t) {\n    if (\"complex64\" === e.dtype && \"complex64\" === t.dtype) return this.complexSeparableBinaryOp(e, t, ADD);\n    var r = new BinaryOpProgram(ADD, e.shape, t.shape),\n        n = this.makeOutputArray(r.outputShape, upcastType(e.dtype, t.dtype));\n    return this.compileAndRun(r, [e, t], n);\n  }, e.prototype.complexSeparableBinaryOp = function (e, t, r) {\n    var n = this,\n        o = this.texData.get(e.dataId),\n        a = this.texData.get(t.dataId),\n        i = [[o.complexTensors.real, a.complexTensors.real], [o.complexTensors.imag, a.complexTensors.imag]].map(function (o) {\n      var a = o[0],\n          i = o[1],\n          s = new BinaryOpProgram(r, e.shape, t.shape),\n          u = n.makeOutputArray(s.outputShape, upcastType(a.dtype, i.dtype)),\n          l = n.makeComplexComponentTensorHandle(e, a),\n          c = n.makeComplexComponentTensorHandle(t, i);\n      return n.compileAndRun(s, [l, c], u);\n    }),\n        s = i[0],\n        u = i[1],\n        l = this.complex(s, u);\n    return s.dispose(), u.dispose(), l;\n  }, e.prototype.makeComplexComponentTensorHandle = function (e, t) {\n    return {\n      dataId: t.dataId,\n      dtype: t.dtype,\n      shape: e.shape\n    };\n  }, e.prototype.addN = function (e) {\n    for (var t = e[0], r = 1; r < e.length; r++) {\n      t = this.add(t, e[r]);\n    }\n\n    return t;\n  }, e.prototype.subtract = function (e, t) {\n    if (\"complex64\" === e.dtype && \"complex64\" === t.dtype) return this.complexSeparableBinaryOp(e, t, SUB);\n    if (this.shouldExecuteOnCPU([e, t])) return this.cpuBackend.subtract(e, t);\n    var r = new BinaryOpProgram(SUB, e.shape, t.shape),\n        n = this.makeOutputArray(r.outputShape, upcastType(e.dtype, t.dtype));\n    return this.compileAndRun(r, [e, t], n);\n  }, e.prototype.pow = function (e, t) {\n    var r = new BinaryOpProgram(POW, e.shape, t.shape),\n        n = r.getCustomSetupFunc(),\n        o = this.makeOutputArray(r.outputShape, upcastType(e.dtype, t.dtype));\n    return this.compileAndRun(r, [e, t], o, n);\n  }, e.prototype.ceil = function (e) {\n    var t = new UnaryOpProgram(e.shape, CEIL);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.floor = function (e) {\n    var t = new UnaryOpProgram(e.shape, FLOOR);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.sign = function (e) {\n    var t = new UnaryOpProgram(e.shape, SIGN);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.round = function (e) {\n    var t = new UnaryOpProgram(e.shape, ROUND);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.exp = function (e) {\n    var t = new UnaryOpProgram(e.shape, EXP);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.expm1 = function (e) {\n    var t = new UnaryOpProgram(e.shape, EXPM1);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.log = function (e) {\n    var t = new UnaryOpProgram(e.shape, LOG),\n        r = t.getCustomSetupFunc();\n    return this.compileAndRun(t, [e], null, r);\n  }, e.prototype.log1p = function (e) {\n    var t = new UnaryOpProgram(e.shape, LOG1P);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.sqrt = function (e) {\n    var t = new UnaryOpProgram(e.shape, SQRT);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.rsqrt = function (e) {\n    var t = new UnaryOpProgram(e.shape, RSQRT);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.square = function (e) {\n    var t = new UnaryOpProgram(e.shape, SQUARE);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.reciprocal = function (e) {\n    var t = new UnaryOpProgram(e.shape, RECIPROCAL);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.relu = function (e) {\n    var t = new UnaryOpProgram(e.shape, RELU);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.elu = function (e) {\n    var t = new UnaryOpProgram(e.shape, ELU);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.eluDer = function (e, t) {\n    var r = new BinaryOpProgram(ELU_DER, e.shape, t.shape);\n    return this.compileAndRun(r, [e, t]);\n  }, e.prototype.selu = function (e) {\n    var t = new UnaryOpProgram(e.shape, SELU);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.int = function (e) {\n    var t = new UnaryOpProgram(e.shape, TO_INT),\n        r = this.makeOutputArray(t.outputShape, \"int32\");\n    return this.compileAndRun(t, [e], r);\n  }, e.prototype.clip = function (e, t, r) {\n    var n = new ClipProgram(e.shape, t, r);\n    return this.compileAndRun(n, [e]);\n  }, e.prototype.abs = function (e) {\n    var t = new UnaryOpProgram(e.shape, ABS);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.complexAbs = function (e) {\n    var t = this.texData.get(e.dataId),\n        r = new ComplexAbsProgram(e.shape),\n        n = [this.makeComplexComponentTensorHandle(e, t.complexTensors.real), this.makeComplexComponentTensorHandle(e, t.complexTensors.imag)];\n    return this.compileAndRun(r, n);\n  }, e.prototype.sigmoid = function (e) {\n    var t = new UnaryOpProgram(e.shape, SIGMOID);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.softplus = function (e) {\n    var t = new UnaryOpProgram(e.shape, SOFTPLUS);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.sin = function (e) {\n    var t = new UnaryOpProgram(e.shape, SIN);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.cos = function (e) {\n    var t = new UnaryOpProgram(e.shape, COS);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.tan = function (e) {\n    var t = new UnaryOpProgram(e.shape, TAN);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.asin = function (e) {\n    var t = new UnaryOpProgram(e.shape, ASIN);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.acos = function (e) {\n    var t = new UnaryOpProgram(e.shape, ACOS);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.atan = function (e) {\n    var t = new UnaryOpProgram(e.shape, ATAN);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.atan2 = function (e, t) {\n    var r = new BinaryOpProgram(ATAN2, e.shape, t.shape);\n    return this.compileAndRun(r, [e, t]);\n  }, e.prototype.sinh = function (e) {\n    var t = new UnaryOpProgram(e.shape, SINH);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.cosh = function (e) {\n    var t = new UnaryOpProgram(e.shape, COSH);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.tanh = function (e) {\n    var t = new UnaryOpProgram(e.shape, TANH);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.asinh = function (e) {\n    var t = new UnaryOpProgram(e.shape, ASINH);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.acosh = function (e) {\n    var t = new UnaryOpProgram(e.shape, ACOSH),\n        r = t.getCustomSetupFunc();\n    return this.compileAndRun(t, [e], null, r);\n  }, e.prototype.atanh = function (e) {\n    var t = new UnaryOpProgram(e.shape, ATANH),\n        r = t.getCustomSetupFunc();\n    return this.compileAndRun(t, [e], null, r);\n  }, e.prototype.erf = function (e) {\n    var t = new UnaryOpProgram(e.shape, ERF);\n    return this.compileAndRun(t, [e]);\n  }, e.prototype.step = function (e, t) {\n    var r = new UnaryOpProgram(e.shape, STEP(t));\n    return this.compileAndRun(r, [e]);\n  }, e.prototype.conv2dWithIm2Row = function (e, t, r) {\n    var n = r.filterWidth,\n        o = r.filterHeight,\n        a = r.inChannels,\n        i = r.outWidth,\n        s = r.outHeight,\n        u = n * o * a,\n        l = s * i,\n        c = [u, l],\n        p = e.squeeze([0]),\n        d = t.reshape([u, -1]),\n        h = new Im2ColProgram(c, p.shape, r),\n        f = this.compileAndRun(h, [p]),\n        m = new MatMulPackedProgram(f.shape, d.shape, [l, r.outChannels], !0, !1);\n    return this.compileAndRun(m, [f, d]).reshape([1, s, i, r.outChannels]);\n  }, e.prototype.conv2d = function (e, t, r) {\n    if (ENV.get(\"WEBGL_CONV_IM2COL\") && 1 === e.shape[0]) return this.conv2dWithIm2Row(e, t, r);\n    var n = new Conv2DProgram(r);\n    return this.compileAndRun(n, [e, t]);\n  }, e.prototype.conv2dDerInput = function (e, t, r) {\n    var n = new Conv2DDerInputProgram(r);\n    return this.compileAndRun(n, [e, t]);\n  }, e.prototype.conv2dDerFilter = function (e, t, r) {\n    var n = new Conv2DDerFilterProgram(r);\n    return this.compileAndRun(n, [e, t]);\n  }, e.prototype.depthwiseConv2D = function (e, t, r) {\n    var n = new DepthwiseConv2DProgram(r);\n    return this.compileAndRun(n, [e, t]);\n  }, e.prototype.depthwiseConv2DDerInput = function (e, t, r) {\n    var n = new DepthwiseConv2DDerInputProgram(r);\n    return this.compileAndRun(n, [e, t]);\n  }, e.prototype.depthwiseConv2DDerFilter = function (e, t, r) {\n    var n = new DepthwiseConv2DDerFilterProgram(r);\n    return this.compileAndRun(n, [e, t]);\n  }, e.prototype.maxPool = function (e, t) {\n    var r = new Pool2DProgram(t, \"max\", !1),\n        n = this.makeOutputArray(r.outputShape, e.dtype);\n    return this.compileAndRun(r, [e], n);\n  }, e.prototype.avgPool = function (e, t) {\n    var r = new Pool2DProgram(t, \"avg\", !1),\n        n = this.makeOutputArray(r.outputShape, \"float32\");\n    return this.compileAndRun(r, [e], n);\n  }, e.prototype.maxPoolBackprop = function (e, t, r, n) {\n    var o = new Pool2DProgram(n, \"max\", !0),\n        a = this.compileAndRun(o, [t]),\n        i = new MaxPool2DBackpropProgram(n),\n        s = this.makeOutputArray(i.outputShape, t.dtype),\n        u = this.compileAndRun(i, [e, a], s);\n    return a.dispose(), u;\n  }, e.prototype.avgPoolBackprop = function (e, t, r) {\n    var n = new AvgPool2DBackpropProgram(r),\n        o = this.makeOutputArray(n.outputShape, t.dtype);\n    return this.compileAndRun(n, [e], o);\n  }, e.prototype.cast = function (e, t) {\n    return castTensor(e, t, this);\n  }, e.prototype.reshape = function (e, t) {\n    return this.texData.get(e.dataId).isPacked && !isReshapeFree(e.shape, t) ? this.packedReshape(e, t) : reshapeTensor(e, t);\n  }, e.prototype.resizeBilinear = function (e, t, r, n) {\n    var o = new ResizeBilinearProgram(e.shape, t, r, n);\n    return this.compileAndRun(o, [e]);\n  }, e.prototype.resizeBilinearBackprop = function (e, t, r) {\n    var n = new ResizeBilinearBackpropProgram(e, t, r);\n    return this.compileAndRun(n, [e]);\n  }, e.prototype.resizeNearestNeighbor = function (e, t, r, n) {\n    var o = new ResizeNearestNeighborProgram(e.shape, t, r, n);\n    return this.compileAndRun(o, [e]);\n  }, e.prototype.resizeNearestNeighborBackprop = function (e, t, r) {\n    var n = new ResizeNearestNeigborBackpropProgram(e, t, r);\n    return this.compileAndRun(n, [e]);\n  }, e.prototype.multinomial = function (e, t, r, n) {\n    var o = t ? e : softmax(e),\n        a = o.shape[0],\n        i = o.shape[1],\n        s = new MultinomialProgram(a, i, r),\n        u = this.makeOutputArray(s.outputShape, \"int32\"),\n        l = s.getCustomSetupFunc(n);\n    return this.compileAndRun(s, [o], u, l);\n  }, e.prototype.oneHot = function (e, t, r, n) {\n    var o = new OneHotProgram(e.size, t, r, n);\n    return this.compileAndRun(o, [e]);\n  }, e.prototype.nonMaxSuppression = function (e, t, r, n, o) {\n    return warn(\"tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead\"), nonMaxSuppressionImpl(e.dataSync(), t.dataSync(), r, n, o);\n  }, e.prototype.cropAndResize = function (e, t, r, n, o, a) {\n    var i = new CropAndResizeProgram(e.shape, t.shape, n, o, a);\n    return this.compileAndRun(i, [e, t, r]);\n  }, e.prototype.depthToSpace = function (e, t, r) {\n    assert(t > 1, \"blockSize should be > 1 for depthToSpace, but was: \" + t);\n    var n = e.shape[0],\n        o = (\"NHWC\" === r ? e.shape[1] : e.shape[2]) * t,\n        a = (\"NHWC\" === r ? e.shape[2] : e.shape[3]) * t,\n        i = (\"NHWC\" === r ? e.shape[3] : e.shape[1]) / (t * t),\n        s = new DepthToSpaceProgram(\"NHWC\" === r ? [n, o, a, i] : [n, i, o, a], t, r);\n    return this.compileAndRun(s, [e]);\n  }, e.prototype.split = function (e, t, r) {\n    return split(e, t, r);\n  }, e.prototype.scatterND = function (e, t, r) {\n    var n = calculateShapes(t, e, r),\n        o = n.sliceRank,\n        a = n.numUpdates,\n        i = n.sliceSize,\n        s = n.strides,\n        u = n.outputSize,\n        l = [u / i, i],\n        c = e.reshape([a, o]),\n        p = t.reshape([a, i]);\n    if (0 === u) return reshapeTensor(tensor([]), r);\n    var d = scalar(0),\n        h = new ScatterProgram(a, o, c.rank, p.rank, s, l);\n    return this.compileAndRun(h, [p, c, d]).reshape(r);\n  }, e.prototype.sparseToDense = function (e, t, r, n) {\n    var o = calculateShapes(t, e, r),\n        a = o.sliceRank,\n        i = o.numUpdates,\n        s = o.strides,\n        u = o.outputSize,\n        l = new ScatterProgram(i, a, e.rank, t.rank, s, [u, 1], !1);\n    return this.compileAndRun(l, [t, e, n]).reshape(r);\n  }, e.prototype.fft = function (e) {\n    return this.fftImpl(e, !1);\n  }, e.prototype.ifft = function (e) {\n    return this.fftImpl(e, !0);\n  }, e.prototype.fftImpl = function (e, t) {\n    var r = this.texData.get(e.dataId),\n        n = new FFTProgram(COMPLEX_FFT.REAL, e.shape, t),\n        o = new FFTProgram(COMPLEX_FFT.IMAG, e.shape, t),\n        a = [this.makeComplexComponentTensorHandle(e, r.complexTensors.real), this.makeComplexComponentTensorHandle(e, r.complexTensors.imag)],\n        i = this.compileAndRun(n, a),\n        s = this.compileAndRun(o, a),\n        u = this.complex(i, s).as2D(e.shape[0], e.shape[1]);\n    return i.dispose(), s.dispose(), u;\n  }, e.prototype.gatherND = function (e, t) {\n    var r = t.shape,\n        n = r[r.length - 1],\n        o = prepareAndValidate(e, t),\n        a = o[0],\n        i = o[1],\n        s = o[2],\n        u = o[3],\n        l = t.reshape([i, n]),\n        c = e.reshape([e.size / s, s]),\n        p = new GatherNDProgram(n, u, [i, s]);\n    return this.compileAndRun(p, [c, l]).reshape(a);\n  }, e.prototype.makeOutputArray = function (e, t) {\n    return Tensor.make(e, {}, t);\n  }, e.prototype.makePackedTensor = function (e) {\n    var t = Tensor.make(e, {});\n    return this.texData.get(t.dataId).isPacked = !0, t;\n  }, e.prototype.unpackTensor = function (e) {\n    var t = new UnpackProgram(e.shape);\n    return this.compileAndRun(t, [e], Tensor.make(t.outputShape, {}));\n  }, e.prototype.getBatchDim = function (e, t) {\n    return void 0 === t && (t = 2), sizeFromShape(e.slice(0, e.length - t));\n  }, e.prototype.getRowsCols = function (e) {\n    if (0 === e.length) throw Error(\"Cannot get rows and columns of an empty shape array.\");\n    return [e.length > 1 ? e[e.length - 2] : 1, e[e.length - 1]];\n  }, e.prototype.packedReshape = function (e, t) {\n    var r = e.reshape([this.getBatchDim(e.shape)].concat(this.getRowsCols(e.shape))),\n        n = [this.getBatchDim(t)].concat(this.getRowsCols(t)),\n        o = new ReshapePackedProgram(n, r.shape);\n    return this.compileAndRun(o, [r]).reshape(t);\n  }, e.prototype.compileAndRun = function (e, t, r, n, o) {\n    var a = this;\n    if (void 0 === o && (o = !0), null == r && (r = e.usesPackedTextures ? this.makePackedTensor(e.outputShape) : this.makeOutputArray(e.outputShape, t[0].dtype)), 0 === r.size) return this.texData.get(r.dataId).values = getTypedArrayFromDType(r.dtype, 0), r;\n    var i = t.map(function (t) {\n      if (\"complex64\" === t.dtype) throw new Error(\"GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.\");\n      var r = a.texData.get(t.dataId);\n      if (null == r.texture && (r.isPacked || !e.usesPackedTextures) && sizeFromShape(t.shape) <= ENV.get(\"WEBGL_SIZE_UPLOAD_UNIFORM\")) return {\n        shape: t.shape,\n        texData: null,\n        isUniform: !0,\n        uniformValues: a.readSync(t.dataId)\n      };\n\n      if (!!r.isPacked != !!e.usesPackedTextures) {\n        var n = void 0,\n            o = void 0;\n        r.isPacked ? (n = new UnpackProgram(t.shape), o = a.compileAndRun(n, [t], Tensor.make(n.outputShape, {}))) : (n = new PackProgram(t.shape), o = a.compileAndRun(n, [t], a.makePackedTensor(t.shape))), r = a.texData.get(o.dataId), t = o;\n      } else if (r.isPacked && !isReshapeFree(r.shape, t.shape)) {\n        a.delayedStorage = !1;\n        var i = t.dataSync();\n        a.delayedStorage = !0, t = Tensor.make(t.shape, {\n          values: i\n        }, t.dtype), (r = a.texData.get(t.dataId)).isPacked = !0;\n      }\n\n      return a.uploadToGPU(t.dataId), {\n        shape: t.shape,\n        texData: r,\n        isUniform: !1\n      };\n    });\n    this.uploadToGPU(r.dataId);\n    var s,\n        u = {\n      shape: r.shape,\n      texData: this.texData.get(r.dataId),\n      isUniform: !1\n    },\n        l = makeShaderKey(e, i, u),\n        c = this.getAndSaveBinary(l, function () {\n      return compileProgram(a.gpgpu, e, i, u);\n    }),\n        p = null != this.activeTimers;\n    if (p && (s = this.startTimer()), runProgram(c, i, u, n), ENV.get(\"WEBGL_PAGING_ENABLED\") && o && this.numBytesInGPU > this.NUM_BYTES_BEFORE_PAGING) for (var d = this.numBytesInGPU - this.NUM_BYTES_BEFORE_PAGING; d > 0 && this.lruDataGPU.length > 0;) {\n      var h = this.lruDataGPU.shift(),\n          f = this.texData.get(h),\n          m = f.shape,\n          g = f.dtype;\n      d -= this.computeBytes(m, g), this.read(h);\n    }\n    return p && (s = this.endTimer(s), this.activeTimers.push({\n      name: e.constructor.name,\n      query: this.getQueryTime(s)\n    })), ENV.get(\"WEBGL_LAZILY_UNPACK\") || !this.texData.get(r.dataId).isPacked || e.isPackShader ? r : this.unpackTensor(r);\n  }, e.prototype.getAndSaveBinary = function (e, t) {\n    return e in this.binaryCache || (this.binaryCache[e] = t()), this.binaryCache[e];\n  }, e.prototype.getTextureManager = function () {\n    return this.textureManager;\n  }, e.prototype.dispose = function () {\n    if (!this.disposed) {\n      for (var e in this.binaryCache) {\n        this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram);\n      }\n\n      this.textureManager.dispose(), this.canvas.remove(), null != this.fromPixels2DContext && this.fromPixels2DContext.canvas.remove(), this.gpgpuCreatedLocally && this.gpgpu.dispose(), this.disposed = !0;\n    }\n  }, e.prototype.floatPrecision = function () {\n    var e = this;\n    return tidy(function () {\n      return e.abs(scalar(1e-8)).get() > 0 ? 32 : 16;\n    });\n  }, e.prototype.uploadToGPU = function (e) {\n    var t,\n        r = this.texData.get(e),\n        n = r.shape,\n        o = r.values,\n        a = r.texture,\n        i = r.usage,\n        s = r.isPacked;\n\n    if (null == a) {\n      var u,\n          l = null != this.activeTimers;\n      l && (u = performance.now());\n      var c = getTextureShapeFromLogicalShape(n, s);\n      r.texShape = c;\n      var p = this.acquireTexture(e, c, i, s);\n\n      if (r.texture = p, null != o) {\n        if (s) {\n          var d = this.getBatchDim(n),\n              h = 1,\n              f = 1;\n          n.length && (h = (t = this.getRowsCols(n))[0], f = t[1]), this.gpgpu.uploadMatrixToPackedTexture(p, d, h, f, c[0], c[1], typedArrayToFloat32(o));\n        } else this.gpgpu.uploadMatrixToTexture(p, c[0], c[1], typedArrayToFloat32(o));\n\n        r.values = null, l && (this.uploadWaitMs += performance.now() - u);\n      }\n    } else {\n      ENV.get(\"WEBGL_PAGING_ENABLED\") && this.lruDataGPU.indexOf(e) >= 0 && (this.lruDataGPU.splice(this.lruDataGPU.indexOf(e), 1), this.lruDataGPU.push(e));\n    }\n  }, e.prototype.convertAndCacheOnCPU = function (e, t) {\n    var r = this.delayedStorage,\n        n = this.texData.get(e),\n        o = n.texture,\n        a = n.texShape,\n        i = n.dtype,\n        s = n.usage,\n        u = n.isPacked;\n    return r && null != o && (this.releaseTexture(e, o, a, s, u), n.texture = null, n.texShape = null), n.usage = TextureUsage.UPLOAD, null != t && (n.values = float32ToTypedArray(t, i)), n.values;\n  }, e.prototype.releaseTexture = function (e, t, r, n, o) {\n    var a = this.texData.get(e),\n        i = a.shape,\n        s = a.dtype;\n\n    if (ENV.get(\"WEBGL_PAGING_ENABLED\")) {\n      var u = this.lruDataGPU.indexOf(e);\n      u >= 0 && this.lruDataGPU.splice(u, 1);\n    }\n\n    this.numBytesInGPU -= this.computeBytes(i, s), this.textureManager.releaseTexture(t, r, n, o);\n  }, e.prototype.acquireTexture = function (e, t, r, n) {\n    var o = this.texData.get(e),\n        a = o.shape,\n        i = o.dtype;\n    return ENV.get(\"WEBGL_PAGING_ENABLED\") && this.lruDataGPU.push(e), this.numBytesInGPU += this.computeBytes(a, i), this.textureManager.acquireTexture(t, r, n);\n  }, e.prototype.computeBytes = function (e, t) {\n    return sizeFromShape(e) * bytesPerElement(t);\n  }, e;\n}();\n\nfunction float32ToTypedArray(e, t) {\n  if (\"float32\" === t || \"complex64\" === t) return e;\n\n  if (\"int32\" === t || \"bool\" === t) {\n    for (var r = \"int32\" === t ? new Int32Array(e.length) : new Uint8Array(e.length), n = 0; n < r.length; ++n) {\n      r[n] = Math.round(e[n]);\n    }\n\n    return r;\n  }\n\n  throw new Error(\"Unknown dtype \" + t);\n}\n\nfunction typedArrayToFloat32(e) {\n  return e instanceof Float32Array ? e : new Float32Array(e);\n}\n\nfunction neg_(e) {\n  var t = convertToTensor(e, \"x\", \"neg\");\n  return ENV.engine.runKernel(function (e) {\n    return e.neg(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.neg();\n      }\n    };\n  });\n}\n\nfunction ceil_(e) {\n  var t = convertToTensor(e, \"x\", \"ceil\");\n  return ENV.engine.runKernel(function (e) {\n    return e.ceil(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return zerosLike(e);\n      }\n    };\n  });\n}\n\nfunction floor_(e) {\n  var t = convertToTensor(e, \"x\", \"floor\");\n  return ENV.engine.runKernel(function (e) {\n    return e.floor(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return zerosLike(e);\n      }\n    };\n  });\n}\n\nfunction sign_(e) {\n  var t = convertToTensor(e, \"x\", \"sign\");\n  return ENV.engine.runKernel(function (e) {\n    return e.sign(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return zerosLike(e);\n      }\n    };\n  });\n}\n\nfunction round_(e) {\n  var t = convertToTensor(e, \"x\", \"round\");\n  return ENV.engine.runKernel(function (e) {\n    return e.round(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return zerosLike(e);\n      }\n    };\n  });\n}\n\nfunction exp_(e) {\n  var t = convertToTensor(e, \"x\", \"exp\");\n  return ENV.engine.runKernel(function (e, r) {\n    return r(e.exp(t));\n  }, {\n    $x: t\n  }, function (e, t) {\n    var r = t[0];\n    return {\n      $x: function $x() {\n        return e.mulStrict(r);\n      }\n    };\n  });\n}\n\nfunction expm1_(e) {\n  var t = convertToTensor(e, \"x\", \"expm1\");\n  return ENV.engine.runKernel(function (e) {\n    return e.expm1(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.mulStrict(t.exp());\n      }\n    };\n  });\n}\n\nfunction log_(e) {\n  var t = convertToTensor(e, \"x\", \"log\");\n  return ENV.engine.runKernel(function (e) {\n    return e.log(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.divStrict(t.toFloat());\n      }\n    };\n  });\n}\n\nfunction log1p_(e) {\n  var t = convertToTensor(e, \"x\", \"log1p\");\n  return ENV.engine.runKernel(function (e) {\n    return e.log1p(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.div(t.add(1));\n      }\n    };\n  });\n}\n\nfunction sqrt_(e) {\n  var t = convertToTensor(e, \"x\", \"sqrt\");\n  return ENV.engine.runKernel(function (e) {\n    return e.sqrt(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.div(t.toFloat().sqrt().mul(2));\n      }\n    };\n  });\n}\n\nfunction rsqrt_(e) {\n  var t = convertToTensor(e, \"x\", \"rsqrt\");\n  return ENV.engine.runKernel(function (e) {\n    return e.rsqrt(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.div(t.pow(1.5).mul(2)).neg();\n      }\n    };\n  });\n}\n\nfunction square_(e) {\n  var t = convertToTensor(e, \"x\", \"square\");\n  return ENV.engine.runKernel(function (e) {\n    return e.square(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.mul(t.toFloat().mul(2));\n      }\n    };\n  });\n}\n\nfunction reciprocal_(e) {\n  var t = convertToTensor(e, \"x\", \"reciprocal\");\n  return ENV.engine.runKernel(function (e) {\n    return e.reciprocal(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.divStrict(t.square().neg());\n      }\n    };\n  });\n}\n\nfunction abs_(e) {\n  var t = convertToTensor(e, \"x\", \"abs\");\n  if (\"complex64\" === t.dtype) return ENV.engine.runKernel(function (e) {\n    return e.complexAbs(t);\n  }, {\n    $x: t\n  });\n  return ENV.engine.runKernel(function (e) {\n    return e.abs(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.mulStrict(t.toFloat().step(-1));\n      }\n    };\n  });\n}\n\nfunction clipByValue_(e, t, r) {\n  var n = convertToTensor(e, \"x\", \"clipByValue\");\n  assert(t <= r, \"Error in clip: min (\" + t + \") must be less than or equal to max (\" + r + \").\");\n  return ENV.engine.runKernel(function (e) {\n    return e.clip(n, t, r);\n  }, {\n    $x: n\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.where(n.greaterEqual(t).logicalAnd(n.lessEqual(r)), zerosLike(e));\n      }\n    };\n  });\n}\n\nfunction sigmoid_(e) {\n  var t = convertToTensor(e, \"x\", \"sigmoid\");\n  return ENV.engine.runKernel(function (e, r) {\n    return r(e.sigmoid(t));\n  }, {\n    $x: t\n  }, function (e, t) {\n    var r = t[0];\n    return {\n      $x: function $x() {\n        return e.mul(r.mul(scalar(1).sub(r)));\n      }\n    };\n  });\n}\n\nfunction logSigmoid_(e) {\n  var t = convertToTensor(e, \"x\", \"logSigmoid\");\n  return ENV.engine.runKernel(function (e) {\n    return e.softplus(t.neg()).neg();\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.mulStrict(t.neg().sigmoid());\n      }\n    };\n  });\n}\n\nfunction softplus_(e) {\n  var t = convertToTensor(e, \"x\", \"softplus\");\n  return ENV.engine.runKernel(function (e) {\n    return e.softplus(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.mulStrict(t.sigmoid());\n      }\n    };\n  });\n}\n\nfunction sin_(e) {\n  var t = convertToTensor(e, \"x\", \"sin\");\n  return ENV.engine.runKernel(function (e) {\n    return e.sin(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return t.toFloat().cos().mulStrict(e);\n      }\n    };\n  });\n}\n\nfunction cos_(e) {\n  var t = convertToTensor(e, \"x\", \"cos\");\n  return ENV.engine.runKernel(function (e) {\n    return e.cos(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return t.toFloat().sin().neg().mulStrict(e);\n      }\n    };\n  });\n}\n\nfunction tan_(e) {\n  var t = convertToTensor(e, \"x\", \"tan\");\n  return ENV.engine.runKernel(function (e) {\n    return e.tan(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.divStrict(t.cos().square());\n      }\n    };\n  });\n}\n\nfunction asin_(e) {\n  var t = convertToTensor(e, \"x\", \"asin\");\n  return ENV.engine.runKernel(function (e) {\n    return e.asin(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.divStrict(scalar(1).sub(t.toFloat().square()).sqrt());\n      }\n    };\n  });\n}\n\nfunction acos_(e) {\n  var t = convertToTensor(e, \"x\", \"acos\");\n  return ENV.engine.runKernel(function (e) {\n    return e.acos(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.divStrict(scalar(1).sub(t.toFloat().square()).sqrt()).neg();\n      }\n    };\n  });\n}\n\nfunction atan_(e) {\n  var t = convertToTensor(e, \"x\", \"atan\");\n  return ENV.engine.runKernel(function (e) {\n    return e.atan(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.div(t.toFloat().square().add(1));\n      }\n    };\n  });\n}\n\nfunction sinh_(e) {\n  var t = convertToTensor(e, \"x\", \"sinh\");\n  return ENV.engine.runKernel(function (e) {\n    return e.sinh(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return t.toFloat().cosh().mulStrict(e);\n      }\n    };\n  });\n}\n\nfunction cosh_(e) {\n  var t = convertToTensor(e, \"x\", \"cosh\");\n  return ENV.engine.runKernel(function (e) {\n    return e.cosh(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return t.toFloat().sinh().mulStrict(e);\n      }\n    };\n  });\n}\n\nfunction tanh_(e) {\n  var t = convertToTensor(e, \"x\", \"tanh\");\n  return ENV.engine.runKernel(function (e, r) {\n    return r(e.tanh(t));\n  }, {\n    $x: t\n  }, function (e, t) {\n    var r = t[0];\n    return {\n      $x: function $x() {\n        return scalar(1).sub(r.square()).mulStrict(e);\n      }\n    };\n  });\n}\n\nfunction asinh_(e) {\n  var t = convertToTensor(e, \"x\", \"asinh\");\n  return ENV.engine.runKernel(function (e) {\n    return e.asinh(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.divStrict(scalar(1).add(t.toFloat().square()).sqrt());\n      }\n    };\n  });\n}\n\nfunction acosh_(e) {\n  var t = convertToTensor(e, \"x\", \"acosh\");\n  return ENV.engine.runKernel(function (e) {\n    return e.acosh(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.divStrict(t.toFloat().square().sub(1).sqrt());\n      }\n    };\n  });\n}\n\nfunction atanh_(e) {\n  var t = convertToTensor(e, \"x\", \"atanh\");\n  return ENV.engine.runKernel(function (e) {\n    return e.atanh(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.div(scalar(1).sub(t.toFloat().square()));\n      }\n    };\n  });\n}\n\nfunction erf_(e) {\n  var t = convertToTensor(e, \"x\", \"erf\");\n  assert(\"int32\" === t.dtype || \"float32\" === t.dtype, \"Input dtype must be `int32` or `float32`.\"), \"int32\" === t.dtype && (t = t.toFloat());\n  return ENV.engine.runKernel(function (e) {\n    return e.erf(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.mul(t.square().neg().exp().mul(2 / Math.sqrt(Math.PI)));\n      }\n    };\n  });\n}\n\nfunction step_(e, t) {\n  void 0 === t && (t = 0);\n  var r = convertToTensor(e, \"x\", \"step\");\n  return ENV.engine.runKernel(function (e) {\n    return e.step(r, t);\n  }, {\n    $x: r\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return zerosLike(e);\n      }\n    };\n  });\n}\n\nENV.get(\"IS_BROWSER\") && ENV.registerBackend(\"webgl\", function () {\n  return new MathBackendWebGL();\n}, 2, setTensorTracker);\nvar abs = op({\n  abs_: abs_\n}),\n    acos = op({\n  acos_: acos_\n}),\n    acosh = op({\n  acosh_: acosh_\n}),\n    asin = op({\n  asin_: asin_\n}),\n    asinh = op({\n  asinh_: asinh_\n}),\n    atan = op({\n  atan_: atan_\n}),\n    atanh = op({\n  atanh_: atanh_\n}),\n    ceil = op({\n  ceil_: ceil_\n}),\n    clipByValue = op({\n  clipByValue_: clipByValue_\n}),\n    cos = op({\n  cos_: cos_\n}),\n    cosh = op({\n  cosh_: cosh_\n}),\n    erf = op({\n  erf_: erf_\n}),\n    exp = op({\n  exp_: exp_\n}),\n    expm1 = op({\n  expm1_: expm1_\n}),\n    floor = op({\n  floor_: floor_\n}),\n    log$1 = op({\n  log_: log_\n}),\n    log1p = op({\n  log1p_: log1p_\n}),\n    logSigmoid = op({\n  logSigmoid_: logSigmoid_\n}),\n    neg = op({\n  neg_: neg_\n}),\n    reciprocal = op({\n  reciprocal_: reciprocal_\n}),\n    round = op({\n  round_: round_\n}),\n    rsqrt = op({\n  rsqrt_: rsqrt_\n}),\n    sigmoid = op({\n  sigmoid_: sigmoid_\n}),\n    sign = op({\n  sign_: sign_\n}),\n    sin = op({\n  sin_: sin_\n}),\n    sinh = op({\n  sinh_: sinh_\n}),\n    softplus = op({\n  softplus_: softplus_\n}),\n    sqrt = op({\n  sqrt_: sqrt_\n}),\n    square = op({\n  square_: square_\n}),\n    step = op({\n  step_: step_\n}),\n    tan = op({\n  tan_: tan_\n}),\n    tanh$1 = op({\n  tanh_: tanh_\n});\n\nfunction batchNormalization2d_(e, t, r, n, o, a) {\n  void 0 === n && (n = .001);\n  var i,\n      s,\n      u = convertToTensor(e, \"x\", \"batchNormalization\"),\n      l = convertToTensor(t, \"mean\", \"batchNormalization\"),\n      c = convertToTensor(r, \"variance\", \"batchNormalization\");\n  return null != o && (i = convertToTensor(o, \"scale\", \"batchNormalization\")), null != a && (s = convertToTensor(a, \"offset\", \"batchNormalization\")), assert(2 === u.rank, \"Error in batchNormalization3D: x must be rank 3 but got rank \" + u.rank + \".\"), assert(2 === l.rank || 1 === l.rank, \"Error in batchNormalization2D: mean must be rank 2 or rank 1 but got rank \" + l.rank + \".\"), assert(2 === c.rank || 1 === c.rank, \"Error in batchNormalization2D: variance must be rank 2 or rank 1 but got rank \" + c.rank + \".\"), null != i && assert(2 === i.rank || 1 === i.rank, \"Error in batchNormalization2D: scale must be rank 2 or rank 1 but got rank \" + i.rank + \".\"), null != s && assert(2 === s.rank || 1 === s.rank, \"Error in batchNormalization2D: offset must be rank 2 or rank 1 but got rank \" + s.rank + \".\"), batchNormalization(u, l, c, n, i, s);\n}\n\nfunction batchNormalization3d_(e, t, r, n, o, a) {\n  void 0 === n && (n = .001);\n  var i,\n      s,\n      u = convertToTensor(e, \"x\", \"batchNormalization\"),\n      l = convertToTensor(t, \"mean\", \"batchNormalization\"),\n      c = convertToTensor(r, \"variance\", \"batchNormalization\");\n  return null != o && (i = convertToTensor(o, \"scale\", \"batchNormalization\")), null != a && (s = convertToTensor(a, \"offset\", \"batchNormalization\")), assert(3 === u.rank, \"Error in batchNormalization3D: x must be rank 3 but got rank \" + u.rank + \".\"), assert(3 === l.rank || 1 === l.rank, \"Error in batchNormalization3D: mean must be rank 3 or rank 1 but got rank \" + l.rank + \".\"), assert(3 === c.rank || 1 === c.rank, \"Error in batchNormalization3D: variance must be rank 3 or rank 1 but got rank \" + c.rank + \".\"), null != i && assert(3 === i.rank || 1 === i.rank, \"Error in batchNormalization3D: scale must be rank 3 or rank 1 but got rank \" + i.rank + \".\"), null != s && assert(3 === s.rank || 1 === s.rank, \"Error in batchNormalization3D: offset must be rank 3 or rank 1 but got rank \" + s.rank + \".\"), batchNormalization(u, l, c, n, i, s);\n}\n\nfunction batchNormalization4d_(e, t, r, n, o, a) {\n  void 0 === n && (n = .001);\n  var i,\n      s,\n      u = convertToTensor(e, \"x\", \"batchNormalization\"),\n      l = convertToTensor(t, \"mean\", \"batchNormalization\"),\n      c = convertToTensor(r, \"variance\", \"batchNormalization\");\n  return null != o && (i = convertToTensor(o, \"scale\", \"batchNormalization\")), null != a && (s = convertToTensor(a, \"offset\", \"batchNormalization\")), assert(4 === u.rank, \"Error in batchNormalization4D: x must be rank 4 but got rank \" + u.rank + \".\"), assert(4 === l.rank || 1 === l.rank, \"Error in batchNormalization4D: mean must be rank 4 or rank 1 but got rank \" + l.rank + \".\"), assert(4 === c.rank || 1 === c.rank, \"Error in batchNormalization4D: variance must be rank 4 or rank 1 but got rank \" + c.rank + \".\"), null != i && assert(4 === i.rank || 1 === i.rank, \"Error in batchNormalization4D: scale must be rank 4 or rank 1 but got rank \" + i.rank + \".\"), null != s && assert(4 === s.rank || 1 === s.rank, \"Error in batchNormalization4D: offset must be rank 4 or rank 1 but got rank \" + s.rank + \".\"), batchNormalization(u, l, c, n, i, s);\n}\n\nfunction batchNormalization_(e, t, r, n, o, a) {\n  void 0 === n && (n = .001);\n  var i,\n      s,\n      u,\n      l = convertToTensor(e, \"x\", \"batchNormalization\"),\n      c = convertToTensor(t, \"mean\", \"batchNormalization\"),\n      p = convertToTensor(r, \"variance\", \"batchNormalization\");\n  null != o && (i = convertToTensor(o, \"scale\", \"batchNormalization\")), null != a && (s = convertToTensor(a, \"offset\", \"batchNormalization\")), assert(c.rank === p.rank, \"Batch normalization gradient requires mean and variance to have equal ranks.\"), assert(null == s || c.rank === s.rank, \"Batch normalization gradient requires mean and offset to have equal ranks.\"), assert(null == i || c.rank === i.rank, \"Batch normalization gradient requires mean and scale to have equal ranks.\"), u = 0 === l.rank || 1 === l.rank ? l.as4D(1, 1, 1, l.size) : 2 === l.rank ? l.as4D(1, 1, l.shape[0], l.shape[1]) : 3 === l.rank ? l.as4D(1, l.shape[0], l.shape[1], l.shape[2]) : l;\n  return ENV.engine.runKernel(function (e) {\n    return e.batchNormalization(u, batchnormReshape4D(c), batchnormReshape4D(p), n, batchnormReshape4D(i), batchnormReshape4D(s));\n  }, {\n    $x: l,\n    $mean: c,\n    $variance: p,\n    $scale: i,\n    $offset: s\n  }, function (e) {\n    var t = null == i ? scalar(1) : i,\n        r = getReductionAxes(c.shape, u.shape),\n        o = [];\n\n    if (1 === c.rank) {\n      for (var a = 0; a < u.shape.length - 1; ++a) {\n        o.push(u.shape[a]);\n      }\n\n      o.push(1);\n    }\n\n    var s = l.sub(c),\n        d = e.mul(t),\n        h = rsqrt(p.add(scalar(n))),\n        f = h.mul(h).mul(h).mul(scalar(-.5));\n    return {\n      $x: function $x() {\n        return 1 === c.rank ? e.mul(tile(h.as4D(1, 1, 1, c.shape[0]), o)).mul(t).reshape(l.shape) : e.mul(h).mul(t).reshape(l.shape);\n      },\n      $mean: function $mean() {\n        var e = h.mul(scalar(-1)).mul(d);\n        return 1 === c.rank && (e = e.sum(r)), e.reshape(c.shape);\n      },\n      $variance: function $variance() {\n        var e = f.mul(s).mul(d);\n        return 1 === c.rank && (e = e.sum(r)), e.reshape(c.shape);\n      },\n      $scale: function $scale() {\n        var t = s.mul(h),\n            n = e.mul(t);\n        return 1 === c.rank && (n = n.sum(r)), n.reshape(c.shape);\n      },\n      $offset: function $offset() {\n        var t = e;\n        return 1 === c.rank && (t = t.sum(r)), t.reshape(c.shape);\n      }\n    };\n  }).reshape(l.shape);\n}\n\nfunction batchnormReshape4D(e) {\n  return null == e ? null : 0 === e.rank ? e.as1D() : 1 === e.rank ? e : 2 === e.rank ? e.as4D(1, 1, e.shape[0], e.shape[1]) : 3 === e.rank ? e.as4D(1, e.shape[0], e.shape[1], e.shape[2]) : e;\n}\n\nvar batchNormalization2d = op({\n  batchNormalization2d_: batchNormalization2d_\n}),\n    batchNormalization3d = op({\n  batchNormalization3d_: batchNormalization3d_\n}),\n    batchNormalization4d = op({\n  batchNormalization4d_: batchNormalization4d_\n}),\n    batchNormalization = op({\n  batchNormalization_: batchNormalization_\n});\n\nfunction computePool2DInfo(e, t, r, n, o, a, i) {\n  void 0 === i && (i = \"channelsLast\");\n  var s,\n      u = parseTupleParam(t),\n      l = u[0],\n      c = u[1];\n  if (\"channelsLast\" === i) s = [l, c, e[3], e[3]];else {\n    if (\"channelsFirst\" !== i) throw new Error(\"Unknown dataFormat \" + i);\n    s = [l, c, e[1], e[1]];\n  }\n  return computeConv2DInfo(e, s, r, n, o, a, !1, i);\n}\n\nfunction computeConv2DInfo(e, t, r, n, o, a, i, s) {\n  void 0 === i && (i = !1), void 0 === s && (s = \"channelsLast\");\n  var u = [-1, -1, -1, -1],\n      l = u[0],\n      c = u[1],\n      p = u[2],\n      d = u[3];\n  if (\"channelsLast\" === s) l = e[0], c = e[1], p = e[2], d = e[3];else {\n    if (\"channelsFirst\" !== s) throw new Error(\"Unknown dataFormat \" + s);\n    l = e[0], d = e[1], c = e[2], p = e[3];\n  }\n  var h,\n      f = t[0],\n      m = t[1],\n      g = t[3],\n      v = parseTupleParam(r),\n      y = v[0],\n      x = v[1],\n      T = parseTupleParam(n),\n      E = T[0],\n      w = T[1],\n      S = getEffectiveFilterSize(f, E),\n      b = getEffectiveFilterSize(m, w),\n      C = getPadAndOutInfo(o, c, p, y, x, S, b, a),\n      A = C.padInfo,\n      _ = C.outHeight,\n      N = C.outWidth,\n      R = i ? g * d : g;\n  return \"channelsFirst\" === s ? h = [l, R, _, N] : \"channelsLast\" === s && (h = [l, _, N, R]), {\n    batchSize: l,\n    dataFormat: s,\n    inHeight: c,\n    inWidth: p,\n    inChannels: d,\n    outHeight: _,\n    outWidth: N,\n    outChannels: R,\n    padInfo: A,\n    strideHeight: y,\n    strideWidth: x,\n    filterHeight: f,\n    filterWidth: m,\n    effectiveFilterHeight: S,\n    effectiveFilterWidth: b,\n    dilationHeight: E,\n    dilationWidth: w,\n    inShape: e,\n    outShape: h,\n    filterShape: t\n  };\n}\n\nfunction computeOutputShape3D(e, t, r, n, o, a) {\n  null == o && (o = computeDefaultPad(e, t, n));\n  var i = e[0],\n      s = e[1],\n      u = conditionalRound((i - t + 2 * o) / n + 1, a);\n  assert(isInt(u), \"The output # of rows (\" + u + \") must be an integer. Change the stride and/or zero pad parameters\");\n  var l = conditionalRound((s - t + 2 * o) / n + 1, a);\n  return assert(isInt(l), \"The output # of columns (\" + l + \") must be an integer. Change the stride and/or zero pad parameters\"), [u, l, r];\n}\n\nfunction computeDefaultPad(e, t, r, n) {\n  void 0 === n && (n = 1);\n  var o = getEffectiveFilterSize(t, n);\n  return Math.floor((e[0] * (r - 1) - r + o) / 2);\n}\n\nfunction parseTupleParam(e) {\n  return \"number\" == typeof e ? [e, e] : e;\n}\n\nfunction getEffectiveFilterSize(e, t) {\n  return t <= 1 ? e : e + (e - 1) * (t - 1);\n}\n\nfunction getPadAndOutInfo(e, t, r, n, o, a, i, s) {\n  var u, l, c;\n\n  if (\"number\" == typeof e) {\n    u = {\n      top: e,\n      bottom: e,\n      left: e,\n      right: e,\n      type: 0 === e ? \"VALID\" : \"NUMBER\"\n    };\n    var p = computeOutputShape3D([t, r, 1], a, 1, n, e, s);\n    l = p[0], c = p[1];\n  } else if (\"same\" === e) {\n    var d = ((l = Math.ceil(t / n)) - 1) * n + a - t,\n        h = ((c = Math.ceil(r / o)) - 1) * o + i - r,\n        f = Math.floor(d / 2),\n        m = d - f,\n        g = Math.floor(h / 2);\n    u = {\n      top: f,\n      bottom: m,\n      left: g,\n      right: h - g,\n      type: \"SAME\"\n    };\n  } else {\n    if (\"valid\" !== e) throw Error(\"Unknown padding parameter: \" + e);\n    u = {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      type: \"VALID\"\n    }, l = Math.ceil((t - a + 1) / n), c = Math.ceil((r - i + 1) / o);\n  }\n\n  return {\n    padInfo: u,\n    outHeight: l,\n    outWidth: c\n  };\n}\n\nfunction conditionalRound(e, t) {\n  if (!t) return e;\n\n  switch (t) {\n    case \"round\":\n      return Math.round(e);\n\n    case \"ceil\":\n      return Math.ceil(e);\n\n    case \"floor\":\n      return Math.floor(e);\n\n    default:\n      throw new Error(\"Unknown roundingMode \" + t);\n  }\n}\n\nfunction tupleValuesAreOne(e) {\n  var t = parseTupleParam(e),\n      r = t[0],\n      n = t[1];\n  return 1 === r && 1 === n;\n}\n\nfunction eitherStridesOrDilationsAreOne(e, t) {\n  return tupleValuesAreOne(e) || tupleValuesAreOne(t);\n}\n\nfunction matMul_(e, t, r, n) {\n  void 0 === r && (r = !1), void 0 === n && (n = !1);\n  var o = convertToTensor(e, \"a\", \"matMul\"),\n      a = convertToTensor(t, \"b\", \"matMul\"),\n      i = r ? o.shape[o.rank - 2] : o.shape[o.rank - 1],\n      s = n ? a.shape[a.rank - 1] : a.shape[a.rank - 2],\n      u = r ? o.shape[o.rank - 1] : o.shape[o.rank - 2],\n      l = n ? a.shape[a.rank - 2] : a.shape[a.rank - 1],\n      c = o.shape.slice(0, -2),\n      p = a.shape.slice(0, -2),\n      d = sizeFromShape(c),\n      h = sizeFromShape(p);\n  assert(o.rank >= 2 && a.rank >= 2 && o.rank === a.rank, \"Error in matMul: inputs must have the same rank of at least 2, got ranks \" + o.rank + \" and \" + a.rank + \".\"), assert(arraysEqual(c, p), \"Error in matMul: outer dimensions (\" + c + \") and (\" + p + \") of Tensors with shapes \" + o.shape + \" and \" + a.shape + \" must match.\"), assert(i === s, \"Error in matMul: inner shapes (\" + i + \") and (\" + s + \") of Tensors with shapes \" + o.shape + \" and \" + a.shape + \" and transposeA=\" + r + \" and transposeB=\" + n + \" must match.\");\n  var f = o.shape.slice(0, -2).concat([u, l]),\n      m = r ? o.as3D(d, i, u) : o.as3D(d, u, i),\n      g = n ? a.as3D(h, l, s) : a.as3D(h, s, l);\n  return ENV.engine.runKernel(function (e) {\n    return e.batchMatMul(m, g, r, n);\n  }, {\n    $a: m,\n    $b: g\n  }, function (e) {\n    return r || n ? !r && n ? {\n      $a: function $a() {\n        return e.matMul(g.toFloat(), !1, !1);\n      },\n      $b: function $b() {\n        return e.matMul(m.toFloat(), !0, !1);\n      }\n    } : r && !n ? {\n      $a: function $a() {\n        return g.toFloat().matMul(e, !1, !0);\n      },\n      $b: function $b() {\n        return m.toFloat().matMul(e, !1, !1);\n      }\n    } : {\n      $a: function $a() {\n        return g.toFloat().matMul(e, !0, !0);\n      },\n      $b: function $b() {\n        return e.matMul(m.toFloat(), !0, !0);\n      }\n    } : {\n      $a: function $a() {\n        return e.matMul(g.toFloat(), !1, !0);\n      },\n      $b: function $b() {\n        return m.toFloat().matMul(e, !0, !1);\n      }\n    };\n  }).reshape(f);\n}\n\nfunction outerProduct_(e, t) {\n  var r = convertToTensor(e, \"v1\", \"outerProduct\"),\n      n = convertToTensor(t, \"v2\", \"outerProduct\");\n  return assert(1 === r.rank && 1 === n.rank, \"Error in outerProduct: inputs must be rank 1, but got ranks \" + r.rank + \" and \" + n.rank + \".\"), r.as2D(-1, 1).matMul(n.as2D(1, -1));\n}\n\nfunction dot_(e, t) {\n  var r = convertToTensor(e, \"t1\", \"dot\"),\n      n = convertToTensor(t, \"t2\", \"dot\");\n  assert(!(1 !== r.rank && 2 !== r.rank || 1 !== n.rank && 2 !== n.rank), \"Error in dot: inputs must all be rank 1 or 2, but got ranks \" + r.rank + \" and \" + n.rank + \".\");\n  var o = 1 === r.rank ? r.size : r.shape[1],\n      a = 1 === n.rank ? n.size : n.shape[0];\n  return assert(o === a, \"Error in dot: inner dimensions of inputs must match, but got \" + o + \" and \" + a + \".\"), 1 === r.rank && 1 === n.rank ? r.as2D(1, -1).matMul(n.as2D(-1, 1)).asScalar() : 1 === r.rank && 2 === n.rank ? r.as2D(1, -1).matMul(n.as2D(n.shape[0], n.shape[1])).as1D() : 2 === r.rank && 1 === n.rank ? r.matMul(n.as2D(-1, 1)).as1D() : r.matMul(n.as2D(n.shape[0], n.shape[1]));\n}\n\nvar matMul = op({\n  matMul_: matMul_\n}),\n    dot = op({\n  dot_: dot_\n}),\n    outerProduct = op({\n  outerProduct_: outerProduct_\n});\n\nfunction conv1d_(e, t, r, n, o, a, i) {\n  void 0 === o && (o = \"NWC\"), void 0 === a && (a = 1);\n  var s = convertToTensor(e, \"x\", \"conv1d\"),\n      u = convertToTensor(t, \"filter\", \"conv1d\"),\n      l = s,\n      c = !1;\n  2 === s.rank && (c = !0, l = s.as3D(1, s.shape[0], s.shape[1])), assert(3 === l.rank, \"Error in conv1d: input must be rank 3, but got rank \" + l.rank + \".\"), assert(3 === u.rank, \"Error in conv1d: filter must be rank 3, but got rank \" + u.rank + \".\"), null != i && assert(isInt(n), \"Error in conv1d: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + n + \".\"), assert(l.shape[2] === u.shape[1], \"Error in conv1d: depth of input (\" + l.shape[2] + \") must match input depth for filter \" + u.shape[1] + \".\"), assert(eitherStridesOrDilationsAreOne(r, a), \"Error in conv1D: Either stride or dilation must be 1. Got stride \" + r + \" and dilation '\" + a + \"'\"), assert(\"NWC\" === o, \"Error in conv1d: got dataFormat of \" + o + \" but only NWC is currently supported.\");\n  var p = u.as4D(1, u.shape[0], u.shape[1], u.shape[2]),\n      d = l.as4D(l.shape[0], 1, l.shape[1], l.shape[2]),\n      h = conv2d(d, p, [1, r], n, \"NHWC\", [1, a], i);\n  return c ? h.as2D(h.shape[2], h.shape[3]) : h.as3D(h.shape[0], h.shape[2], h.shape[3]);\n}\n\nfunction conv2d_(e, t, r, n, o, a, i) {\n  void 0 === o && (o = \"NHWC\"), void 0 === a && (a = [1, 1]);\n  var s = convertToTensor(e, \"x\", \"conv2d\"),\n      u = convertToTensor(t, \"filter\", \"conv2d\"),\n      l = s,\n      c = !1;\n  3 === s.rank && (c = !0, l = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), assert(4 === l.rank, \"Error in conv2d: input must be rank 4, but got rank \" + l.rank + \".\"), assert(4 === u.rank, \"Error in conv2d: filter must be rank 4, but got rank \" + u.rank + \".\"), null != i && assert(isInt(n), \"Error in conv2d: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + n + \".\"), assert(l.shape[3] === u.shape[2], \"Error in conv2d: depth of input (\" + l.shape[3] + \") must match input depth for filter \" + u.shape[2] + \".\"), assert(eitherStridesOrDilationsAreOne(r, a), \"Error in conv2D: Either strides or dilations must be 1. Got strides \" + r + \" and dilations '\" + a + \"'\"), assert(\"NHWC\" === o, \"Error in conv2d: got dataFormat of \" + o + \" but only NHWC is currently supported.\");\n  var p,\n      d = computeConv2DInfo(l.shape, u.shape, r, a, n, i);\n\n  if (1 !== d.filterHeight || 1 !== d.filterWidth || 1 !== d.dilationHeight || 1 !== d.dilationWidth || 1 !== d.strideHeight || 1 !== d.strideWidth || \"SAME\" !== d.padInfo.type && \"VALID\" !== d.padInfo.type) {\n    p = ENV.engine.runKernel(function (e) {\n      return e.conv2d(l, u, d);\n    }, {\n      x: l,\n      $filter: u\n    }, function (e) {\n      return assert(tupleValuesAreOne(a), \"Error in gradient of conv2D: dilation rates greater than 1 are notyet supported in gradients. Got dilations '\" + a + \"'\"), {\n        x: function x() {\n          return conv2dDerInput_(l.shape, e, u, r, n);\n        },\n        $filter: function $filter() {\n          return conv2dDerFilter_(l, e, u.shape, r, n);\n        }\n      };\n    });\n  } else {\n    var h = l.reshape([-1, d.inChannels]),\n        f = u.reshape([d.inChannels, d.outChannels]);\n    p = matMul(h, f).reshape(d.outShape);\n  }\n\n  return c ? p.as3D(p.shape[1], p.shape[2], p.shape[3]) : p;\n}\n\nfunction conv2dDerInput_(e, t, r, n, o, a) {\n  assert(e.length === t.rank, \"Length of inShape (\" + e.length + \") and rank of dy (\" + t.rank + \") must match\");\n  var i = e,\n      s = t,\n      u = !1;\n  3 === t.rank && (u = !0, s = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]), i = [1, e[0], e[1], e[2]]);\n  var l = i[3],\n      c = s.shape[3];\n  assert(4 === i.length, \"Error in conv2dDerInput: inShape must be length 4, but got length \" + i.length + \".\"), assert(4 === s.rank, \"Error in conv2dDerInput: dy must be rank 4, but got rank \" + s.rank), assert(4 === r.rank, \"Error in conv2dDerInput: filter must be rank 4, but got rank \" + r.rank), assert(l === r.shape[2], \"Error in conv2dDerInput: depth of input (\" + l + \") must match input depth for filter \" + r.shape[2] + \".\"), assert(c === r.shape[3], \"Error in conv2dDerInput: depth of output (\" + c + \") must match output depth for filter \" + r.shape[3] + \".\"), null != a && assert(isInt(o), \"Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode \" + a + \" but got pad \" + o + \".\");\n  var p = computeConv2DInfo(i, r.shape, n, 1, o, a),\n      d = ENV.engine.runKernel(function (e) {\n    return e.conv2dDerInput(s, r, p);\n  }, {\n    dy4D: s,\n    filter: r\n  }, function (e) {\n    return {\n      dy4D: function dy4D() {\n        return conv2d(e, r, n, o, \"NHWC\", 1, a);\n      },\n      filter: function filter() {\n        return conv2dDerFilter(e, s, r.shape, n, o, a);\n      }\n    };\n  });\n  return u ? d.as3D(d.shape[1], d.shape[2], d.shape[3]) : d;\n}\n\nfunction conv2dDerFilter_(e, t, r, n, o, a) {\n  var i = e;\n  3 === e.rank && (i = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]));\n  var s = t;\n  3 === s.rank && (s = t.as4D(1, t.shape[0], t.shape[1], t.shape[2])), assert(4 === i.rank, \"Error in conv2dDerFilter: input must be rank 4, but got shape \" + i.shape + \".\"), assert(4 === s.rank, \"Error in conv2dDerFilter: dy must be rank 4, but got shape \" + s.shape + \".\"), assert(4 === r.length, \"Error in conv2dDerFilter: filterShape must be length 4, but got \" + r + \".\"), assert(i.shape[3] === r[2], \"Error in conv2dDerFilter: depth of input \" + i.shape[3] + \") must match input depth in filter (\" + r[2] + \".\"), assert(s.shape[3] === r[3], \"Error in conv2dDerFilter: depth of dy (\" + s.shape[3] + \") must match output depth for filter (\" + r[3] + \").\"), null != a && assert(isInt(o), \"Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode \" + a + \" but got pad \" + o + \".\");\n  var u = computeConv2DInfo(i.shape, r, n, 1, o, a);\n  return ENV.engine.runKernel(function (e) {\n    return e.conv2dDerFilter(i, s, u);\n  }, {\n    x4D: i,\n    dy4D: s\n  });\n}\n\nfunction conv2dTranspose_(e, t, r, n, o, a) {\n  return conv2dDerInput_(r, convertToTensor(e, \"x\", \"conv2dTranspose\"), convertToTensor(t, \"filter\", \"conv2dTranspose\"), n, o, a);\n}\n\nfunction depthwiseConv2d_(e, t, r, n, o, a, i) {\n  void 0 === o && (o = \"NHWC\"), void 0 === a && (a = [1, 1]);\n  var s = convertToTensor(e, \"x\", \"depthwiseConv2d\"),\n      u = convertToTensor(t, \"filter\", \"depthwiseConv2d\"),\n      l = s,\n      c = !1;\n  3 === s.rank && (c = !0, l = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), assert(4 === l.rank, \"Error in depthwiseConv2d: input must be rank 4, but got rank \" + l.rank + \".\"), assert(4 === u.rank, \"Error in depthwiseConv2d: filter must be rank 4, but got rank \" + u.rank + \".\"), assert(l.shape[3] === u.shape[2], \"Error in depthwiseConv2d: number of input channels (\" + l.shape[3] + \") must match the inChannels dimension in filter \" + u.shape[2] + \".\"), null == a && (a = [1, 1]), assert(eitherStridesOrDilationsAreOne(r, a), \"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides \" + r + \" and dilations '\" + a + \"'\"), null != i && assert(isInt(n), \"Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode \" + i + \" but got pad \" + n + \".\");\n  var p = computeConv2DInfo(l.shape, u.shape, r, a, n, i, !0),\n      d = ENV.engine.runKernel(function (e) {\n    return e.depthwiseConv2D(l, u, p);\n  }, {\n    x: l,\n    $filter: u\n  }, function (e) {\n    return assert(tupleValuesAreOne(a), \"Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '\" + a + \"'\"), {\n      x: function x() {\n        return depthwiseConv2dDerInput(l.shape, e, u, p);\n      },\n      $filter: function $filter() {\n        return depthwiseConv2dDerFilter(l, e, u.shape, p);\n      }\n    };\n  });\n  return c ? d.as3D(d.shape[1], d.shape[2], d.shape[3]) : d;\n}\n\nfunction separableConv2d_(e, t, r, n, o, a, i) {\n  void 0 === a && (a = [1, 1]), void 0 === i && (i = \"NHWC\");\n  var s = convertToTensor(e, \"x\", \"separableConv2d\"),\n      u = convertToTensor(t, \"depthwiseFilter\", \"separableConv2d\"),\n      l = convertToTensor(r, \"pointwiseFilter\", \"separableConv2d\"),\n      c = s,\n      p = !1;\n  if (3 === s.rank && (p = !0, c = s.as4D(1, s.shape[0], s.shape[1], s.shape[2])), \"NCHW\" === i) throw new Error(\"separableConv2d currently does not support dataFormat NCHW; only NHWC is supported\");\n  assert(4 === c.rank, \"Error in separableConv2d: input must be rank 4, but got rank \" + c.rank + \".\"), assert(4 === u.rank, \"Error in separableConv2d: depthwise filter must be rank 4, but got rank \" + u.rank + \".\"), assert(4 === l.rank, \"Error in separableConv2d: pointwise filter must be rank 4, but got rank \" + u.rank + \".\"), assert(1 === l.shape[0], \"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got \" + l.shape[0] + \".\"), assert(1 === l.shape[1], \"Error in separableConv2d: the second dimension of pointwise filter  must be 1, but got \" + l.shape[1] + \".\");\n  var d = u.shape[2],\n      h = u.shape[3];\n  assert(l.shape[2] === d * h, \"Error in separableConv2d: the third dimension of pointwise filter must be \" + d * h + \", but got \" + l.shape[2] + \".\");\n  var f = depthwiseConv2d(c, u, n, o, i, a),\n      m = conv2d(f, l, 1, \"valid\", i);\n  return p ? m.as3D(m.shape[1], m.shape[2], m.shape[3]) : m;\n}\n\nfunction depthwiseConv2dDerInput(e, t, r, n) {\n  var o = t,\n      a = !1;\n  3 === t.rank && (a = !0, o = t.as4D(1, t.shape[0], t.shape[1], t.shape[2]));\n  var i = ENV.engine.runKernel(function (e) {\n    return e.depthwiseConv2DDerInput(o, r, n);\n  }, {\n    dy4D: o\n  });\n  return a ? i.as3D(i.shape[1], i.shape[2], i.shape[3]) : i;\n}\n\nfunction depthwiseConv2dDerFilter(e, t, r, n) {\n  var o = e;\n  3 === e.rank && (o = e.as4D(1, e.shape[0], e.shape[1], e.shape[2]));\n  var a = t;\n  return 3 === a.rank && (a = t.as4D(1, t.shape[0], t.shape[1], t.shape[2])), ENV.engine.runKernel(function (e) {\n    return e.depthwiseConv2DDerFilter(o, a, n);\n  }, {\n    x4D: o,\n    dy4D: a\n  });\n}\n\nvar conv1d = op({\n  conv1d_: conv1d_\n}),\n    conv2d = op({\n  conv2d_: conv2d_\n}),\n    conv2dDerFilter = op({\n  conv2dDerFilter_: conv2dDerFilter_\n}),\n    depthwiseConv2d = op({\n  depthwiseConv2d_: depthwiseConv2d_\n}),\n    separableConv2d = op({\n  separableConv2d_: separableConv2d_\n}),\n    conv2dTranspose = op({\n  conv2dTranspose_: conv2dTranspose_\n});\n\nfunction reverse1d_(e) {\n  var t = convertToTensor(e, \"x\", \"reverse\");\n  return assert(1 === t.rank, \"Error in reverse1D: x must be rank 1 but got\\n             rank \" + t.rank + \".\"), reverse(t, 0);\n}\n\nfunction reverse2d_(e, t) {\n  var r = convertToTensor(e, \"x\", \"reverse\");\n  return assert(2 === r.rank, \"Error in reverse2D: x must be rank 2 but got\\n             rank \" + r.rank + \".\"), reverse(r, t);\n}\n\nfunction reverse3d_(e, t) {\n  var r = convertToTensor(e, \"x\", \"reverse\");\n  return assert(3 === r.rank, \"Error in reverse3D: x must be rank 3 but got\\n             rank \" + r.rank + \".\"), reverse(r, t);\n}\n\nfunction reverse4d_(e, t) {\n  var r = convertToTensor(e, \"x\", \"reverse\");\n  return assert(4 === r.rank, \"Error in reverse4D: x must be rank 4 but got\\n             rank \" + r.rank + \".\"), reverse(r, t);\n}\n\nfunction reverse_(e, t) {\n  var r = convertToTensor(e, \"x\", \"reverse\");\n  if (0 === r.rank) return r.clone();\n  var n = parseAxisParam(t, r.shape);\n  return ENV.engine.runKernel(function (e) {\n    return e.reverse(r, n);\n  }, {\n    $x: r\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return e.reverse(n);\n      }\n    };\n  }).reshapeAs(r);\n}\n\nvar reverse = op({\n  reverse_: reverse_\n}),\n    reverse1d = op({\n  reverse1d_: reverse1d_\n}),\n    reverse2d = op({\n  reverse2d_: reverse2d_\n}),\n    reverse3d = op({\n  reverse3d_: reverse3d_\n}),\n    reverse4d = op({\n  reverse4d_: reverse4d_\n});\n\nfunction maxPoolImpl_(e, t, r, n, o, a) {\n  var i = convertToTensor(e, \"x\", \"maxPool\"),\n      s = i,\n      u = !1;\n  3 === i.rank && (u = !0, s = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), null == n && (n = [1, 1]), assert(4 === s.rank, \"Error in maxPool: input must be rank 4 but got rank \" + s.rank + \".\"), assert(eitherStridesOrDilationsAreOne(r, n), \"Error in maxPool: Either strides or dilations must be 1. Got strides \" + r + \" and dilations '\" + n + \"'\"), null != a && assert(isInt(o), \"Error in maxPool: pad must be an integer when using, dimRoundingMode \" + a + \" but got pad \" + o + \".\");\n  var l = computePool2DInfo(s.shape, t, r, n, o, a),\n      c = ENV.engine.runKernel(function (e, t) {\n    return t(e.maxPool(s, l));\n  }, {\n    x: s\n  }, function (e, a) {\n    var i = a[0];\n    return {\n      x: function x() {\n        return maxPoolBackprop(e, s, i, t, r, n, o);\n      }\n    };\n  });\n  return u ? c.as3D(c.shape[1], c.shape[2], c.shape[3]) : c;\n}\n\nfunction maxPool_(e, t, r, n, o) {\n  return maxPoolImpl_(e, t, r, 1, n, o);\n}\n\nfunction avgPoolImpl_(e, t, r, n, o, a) {\n  var i = convertToTensor(e, \"x\", \"avgPool\", \"float32\");\n  null == n && (n = [1, 1]), assert(eitherStridesOrDilationsAreOne(r, n), \"Error in avgPool: Either strides or dilations must be 1. Got strides \" + r + \" and dilations '\" + n + \"'\");\n  var s = i,\n      u = !1;\n  3 === i.rank && (u = !0, s = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), assert(4 === s.rank, \"Error in avgPool: x must be rank 4 but got rank \" + s.rank + \".\"), null != a && assert(isInt(o), \"Error in avgPool: pad must be an integer when using, dimRoundingMode \" + a + \" but got pad \" + o + \".\");\n  var l = computePool2DInfo(s.shape, t, r, n, o),\n      c = ENV.engine.runKernel(function (e) {\n    return e.avgPool(s, l);\n  }, {\n    x: s\n  }, function (e) {\n    return {\n      x: function x() {\n        return avgPoolBackprop(e, s, t, r, n, o);\n      }\n    };\n  });\n  return c = c.cast(i.dtype), u ? c.as3D(c.shape[1], c.shape[2], c.shape[3]) : c;\n}\n\nfunction avgPool_(e, t, r, n, o) {\n  return avgPoolImpl_(e, t, r, 1, n, o);\n}\n\nfunction pool_(e, t, r, n, o, a) {\n  null == o && (o = [1, 1]), null == a && (a = 1), 0 === n && (n = \"valid\");\n  var i = convertToTensor(e, \"x\", \"maxPool\"),\n      s = i,\n      u = !1;\n  3 === i.rank && (u = !0, s = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), assert(eitherStridesOrDilationsAreOne(a, o), \"Error in pool: Either strides or dilations must be 1. Got strides \" + a + \" and dilations '\" + o + \"'\");\n  var l,\n      c = computePool2DInfo(s.shape, t, a, o, n),\n      p = [c.dilationHeight, c.dilationWidth];\n  l = \"same\" === n ? withSpaceToBatchBasePaddings([c.filterHeight, c.filterWidth], p) : [[0, 0], [0, 0]];\n  var d = 1 === p[0] && 1 === p[1],\n      h = requiredSpaceToBatchPaddings([c.inHeight, c.inWidth], p, l),\n      f = h[0],\n      m = h[1],\n      g = d ? n : \"valid\",\n      v = d ? s : spaceToBatchND(s, p, f),\n      y = (\"avg\" === r ? function () {\n    return avgPoolImpl_(v, t, a, 1, g);\n  } : function () {\n    return maxPoolImpl_(v, t, a, 1, g);\n  })(),\n      x = d ? y : batchToSpaceND(y, p, m);\n  return u ? x.as3D(x.shape[1], x.shape[2], x.shape[3]) : x;\n}\n\nfunction maxPoolBackprop(e, t, r, n, o, a, i, s) {\n  var u = convertToTensor(e, \"dy\", \"maxPoolBackprop\"),\n      l = convertToTensor(t, \"input\", \"maxPoolBackprop\"),\n      c = convertToTensor(r, \"output\", \"maxPoolBackprop\");\n  assert(l.rank === u.rank, \"Rank of input (\" + l.rank + \") does not match rank of dy (\" + u.rank + \")\"), null == a && (a = [1, 1]), assert(eitherStridesOrDilationsAreOne(o, a), \"Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides \" + o + \" and dilations '\" + a + \"'\"), assert(4 === u.rank, \"Error in maxPoolBackprop: dy must be rank 4 but got rank \" + u.rank + \".\"), assert(4 === l.rank, \"Error in maxPoolBackprop: input must be rank 4 but got rank \" + l.rank + \".\"), null != s && assert(isInt(i), \"Error in maxPoolBackprop: pad must be an integer when using, dimRoundingMode \" + s + \" but got pad \" + i + \".\");\n  var p = computePool2DInfo(l.shape, n, o, a, i, s);\n  return ENV.engine.runKernel(function (e) {\n    return e.maxPoolBackprop(u, l, c, p);\n  }, {\n    $dy: u,\n    $input: l\n  });\n}\n\nfunction avgPoolBackprop(e, t, r, n, o, a) {\n  var i = convertToTensor(e, \"dy\", \"avgPoolBackprop\"),\n      s = convertToTensor(t, \"input\", \"avgPoolBackprop\");\n  assert(s.rank === i.rank, \"Rank of input (\" + s.rank + \") does not match rank of dy (\" + i.rank + \")\"), null == o && (o = [1, 1]), assert(eitherStridesOrDilationsAreOne(n, o), \"Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides \" + n + \" and dilations '\" + o + \"'\");\n  var u = s,\n      l = i,\n      c = !1;\n  3 === s.rank && (c = !0, u = s.as4D(1, s.shape[0], s.shape[1], s.shape[2]), l = i.as4D(1, i.shape[0], i.shape[1], i.shape[2])), assert(4 === l.rank, \"Error in avgPoolBackprop: dy must be rank 4 but got rank \" + l.rank + \".\"), assert(4 === u.rank, \"Error in avgPoolBackprop: input must be rank 4 but got rank \" + u.rank + \".\");\n  var p = computePool2DInfo(u.shape, r, n, o, a),\n      d = ENV.engine.runKernel(function (e) {\n    return e.avgPoolBackprop(l, u, p);\n  }, {\n    dy4D: l,\n    input4D: u\n  });\n  return c ? d.as3D(d.shape[1], d.shape[2], d.shape[3]) : d;\n}\n\nfunction requiredSpaceToBatchPaddings(e, t, r) {\n  var n = r.map(function (e) {\n    return e[0];\n  }),\n      o = r.map(function (e) {\n    return e[1];\n  }),\n      a = e.concat(n, o),\n      i = t.map(function (e, t) {\n    return (e - a[t] % e) % e;\n  }),\n      s = o.map(function (e, t) {\n    return e + i[t];\n  });\n  return [t.map(function (e, t) {\n    return [n[t], s[t]];\n  }), t.map(function (e, t) {\n    return [0, i[t]];\n  })];\n}\n\nfunction withSpaceToBatchBasePaddings(e, t) {\n  var r = e.map(function (e, r) {\n    return e + (e - 1) * (t[r] - 1);\n  }).map(function (e) {\n    return e - 1;\n  }),\n      n = r.map(function (e) {\n    return Math.floor(e / 2);\n  }),\n      o = r.map(function (e, t) {\n    return e - n[t];\n  });\n  return r.map(function (e, t) {\n    return [n[t], o[t]];\n  });\n}\n\nvar maxPool = op({\n  maxPool_: maxPool_\n}),\n    avgPool = op({\n  avgPool_: avgPool_\n}),\n    pool = op({\n  pool_: pool_\n});\n\nfunction slice1d_(e, t, r) {\n  var n = convertToTensor(e, \"x\", \"slice1d\");\n  return assert(1 === n.rank, \"slice1d expects a rank-1 tensor, but got a rank-\" + n.rank + \" tensor\"), slice(n, [t], [r]);\n}\n\nfunction slice2d_(e, t, r) {\n  var n = convertToTensor(e, \"x\", \"slice2d\");\n  return assert(2 === n.rank, \"slice2d expects a rank-2 tensor, but got a rank-\" + n.rank + \" tensor\"), slice(n, t, r);\n}\n\nfunction slice3d_(e, t, r) {\n  var n = convertToTensor(e, \"x\", \"slice3d\");\n  return assert(3 === n.rank, \"slice3d expects a rank-3 tensor, but got a rank-\" + n.rank + \" tensor\"), slice(n, t, r);\n}\n\nfunction slice4d_(e, t, r) {\n  var n = convertToTensor(e, \"x\", \"slice4d\");\n  return assert(4 === n.rank, \"slice4d expects a rank-4 tensor, but got a rank-\" + n.rank + \" tensor\"), slice(n, t, r);\n}\n\nfunction slice_(e, t, r) {\n  var n,\n      o,\n      a = convertToTensor(e, \"x\", \"slice\");\n  if (0 === a.rank) throw new Error(\"Slicing scalar is not possible\");\n  n = \"number\" == typeof t ? [t].concat(new Array(a.rank - 1).fill(0)) : t.length < a.rank ? t.concat(new Array(a.rank - t.length).fill(0)) : t.slice(), o = (o = null == r ? new Array(a.rank).fill(-1) : \"number\" == typeof r ? [r].concat(new Array(a.rank - 1).fill(-1)) : r.length < a.rank ? r.concat(new Array(a.rank - r.length).fill(-1)) : r).map(function (e, t) {\n    return e >= 0 ? e : (assert(-1 === e, \"Bad value in size\"), a.shape[t] - n[t]);\n  }), assertParamsValid(a, n, o);\n  var i = a.shape;\n  return ENV.engine.runKernel(function (e) {\n    return e.slice(a, n, o);\n  }, {\n    $x: a\n  }, function (e) {\n    for (var t = [], r = 0; r < e.rank; r++) {\n      t.push([n[r], i[r] - n[r] - o[r]]);\n    }\n\n    return {\n      $x: function $x() {\n        return e.pad(t);\n      }\n    };\n  });\n}\n\nvar slice = op({\n  slice_: slice_\n}),\n    slice1d = op({\n  slice1d_: slice1d_\n}),\n    slice2d = op({\n  slice2d_: slice2d_\n}),\n    slice3d = op({\n  slice3d_: slice3d_\n}),\n    slice4d = op({\n  slice4d_: slice4d_\n});\n\nfunction logSumExp_(e, t, r) {\n  void 0 === t && (t = null), void 0 === r && (r = !1);\n  var n = convertToTensor(e, \"x\", \"logSumExp\"),\n      o = parseAxisParam(t, n.shape),\n      a = n.max(o, !0),\n      i = n.sub(a).exp().sum(o).log(),\n      s = a.reshape(i.shape).add(i);\n\n  if (r) {\n    var u = expandShapeToKeepDim(s.shape, o);\n    return s.reshape(u);\n  }\n\n  return s;\n}\n\nfunction sum_(e, t, r) {\n  void 0 === t && (t = null), void 0 === r && (r = !1);\n  var n = convertToTensor(e, \"x\", \"sum\");\n  \"bool\" === n.dtype && (n = n.toInt());\n  var o = parseAxisParam(t, n.shape);\n  return customGrad(function (e) {\n    var t = getAxesPermutation(o, e.rank),\n        n = o,\n        a = e;\n    null != t && (a = e.transpose(t), n = getInnerMostAxes(n.length, e.rank));\n    var i = ENV.engine.runKernel(function (e) {\n      return e.sum(a, n);\n    }, {\n      permutedX: a\n    });\n\n    if (r) {\n      var s = expandShapeToKeepDim(i.shape, o);\n      i = i.reshape(s);\n    }\n\n    return {\n      value: i,\n      gradFunc: function gradFunc(t) {\n        var r = e.shape.slice();\n        return o.forEach(function (e) {\n          r[e] = 1;\n        }), t.reshape(r).mul(ones$1(e.shape, \"float32\"));\n      }\n    };\n  })(n);\n}\n\nfunction prod_(e, t, r) {\n  void 0 === t && (t = null), void 0 === r && (r = !1);\n  var n = convertToTensor(e, \"x\", \"prod\");\n  \"bool\" === n.dtype && (n = n.toInt());\n  var o = parseAxisParam(t, n.shape),\n      a = getAxesPermutation(o, n.rank),\n      i = o,\n      s = n;\n  null != a && (s = n.transpose(a), i = getInnerMostAxes(i.length, n.rank));\n  var u = ENV.engine.runKernel(function (e) {\n    return e.prod(s, i);\n  }, {\n    permutedX: s\n  });\n\n  if (r) {\n    var l = expandShapeToKeepDim(u.shape, o);\n    u = u.reshape(l);\n  }\n\n  return u;\n}\n\nfunction mean_(e, t, r) {\n  void 0 === t && (t = null), void 0 === r && (r = !1);\n  var n = convertToTensor(e, \"x\", \"mean\"),\n      o = parseAxisParam(t, n.shape),\n      a = sizeFromShape(computeOutAndReduceShapes(n.shape, o)[1]);\n  return customGrad(function (e) {\n    var n = scalar(a);\n    return {\n      value: (n.dtype === e.dtype ? e : e.cast(n.dtype)).div(n).sum(t, r),\n      gradFunc: function gradFunc(t) {\n        var r = e.shape.slice();\n        return o.forEach(function (e) {\n          r[e] = 1;\n        }), t.reshape(r).mul(ones$1(e.shape, \"float32\")).div(n);\n      }\n    };\n  })(n);\n}\n\nfunction gradForMinAndMax(e, t, r, n, o) {\n  var a = t[0];\n  return a.rank < r.rank && (a = a.reshape(expandShapeToKeepDim(a.shape, n))), e.rank < r.rank && (e = e.reshape(expandShapeToKeepDim(e.shape, n))), {\n    $x: function $x() {\n      var t = e.mul(r.equal(a).cast(e.dtype));\n      return null == o ? t : t.transpose(o);\n    }\n  };\n}\n\nfunction min_(e, t, r) {\n  void 0 === t && (t = null), void 0 === r && (r = !1);\n  var n = convertToTensor(e, \"x\", \"min\"),\n      o = n,\n      a = parseAxisParam(t, n.shape),\n      i = a,\n      s = getAxesPermutation(i, n.rank);\n  null != s && (n = n.transpose(s), i = getInnerMostAxes(i.length, n.rank));\n  var u = ENV.engine.runKernel(function (e, t) {\n    return t(e.min(n, i));\n  }, {\n    $x: n\n  }, function (e, t) {\n    return gradForMinAndMax(e, t, o, a, s);\n  });\n\n  if (r) {\n    var l = expandShapeToKeepDim(u.shape, a);\n    u = u.reshape(l);\n  }\n\n  return u;\n}\n\nfunction max_(e, t, r) {\n  void 0 === t && (t = null), void 0 === r && (r = !1);\n  var n = convertToTensor(e, \"x\", \"max\"),\n      o = n,\n      a = parseAxisParam(t, n.shape),\n      i = a,\n      s = getAxesPermutation(i, n.rank);\n  null != s && (n = n.transpose(s), i = getInnerMostAxes(i.length, n.rank));\n  var u = ENV.engine.runKernel(function (e, t) {\n    return t(e.max(n, i));\n  }, {\n    $x: n\n  }, function (e, t) {\n    return gradForMinAndMax(e, t, o, a, s);\n  });\n\n  if (r) {\n    var l = expandShapeToKeepDim(u.shape, a);\n    u = u.reshape(l);\n  }\n\n  return u;\n}\n\nfunction argMin_(e, t) {\n  void 0 === t && (t = 0);\n  var r = convertToTensor(e, \"x\", \"argMin\");\n  null == t && (t = 0);\n  var n = parseAxisParam(t, r.shape),\n      o = getAxesPermutation(n, r.rank);\n  null != o && (r = r.transpose(o), n = getInnerMostAxes(n.length, r.rank));\n  return ENV.engine.runKernel(function (e) {\n    return e.argMin(r, n[0]);\n  }, {\n    $x: r\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return zerosLike(r);\n      }\n    };\n  });\n}\n\nfunction argMax_(e, t) {\n  void 0 === t && (t = 0);\n  var r = convertToTensor(e, \"x\", \"argMax\");\n  null == t && (t = 0);\n  var n = parseAxisParam(t, r.shape),\n      o = getAxesPermutation(n, r.rank);\n  null != o && (r = r.transpose(o), n = getInnerMostAxes(n.length, r.rank));\n  return ENV.engine.runKernel(function (e) {\n    return e.argMax(r, n[0]);\n  }, {\n    $x: r\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return zerosLike(r);\n      }\n    };\n  });\n}\n\nfunction all_(e, t, r) {\n  void 0 === t && (t = null), void 0 === r && (r = !1);\n  var n = convertToTensor(e, \"x\", \"all\", \"bool\"),\n      o = parseAxisParam(t, n.shape),\n      a = o,\n      i = getAxesPermutation(a, n.rank);\n  null != i && (n = n.transpose(i), a = getInnerMostAxes(a.length, n.rank));\n  var s = ENV.engine.runKernel(function (e) {\n    return e.all(n, a);\n  }, {\n    $x: n\n  });\n\n  if (r) {\n    var u = expandShapeToKeepDim(s.shape, o);\n    return s.reshape(u);\n  }\n\n  return s;\n}\n\nfunction any_(e, t, r) {\n  void 0 === t && (t = null), void 0 === r && (r = !1);\n  var n = convertToTensor(e, \"x\", \"any\", \"bool\"),\n      o = parseAxisParam(t, n.shape),\n      a = o,\n      i = getAxesPermutation(a, n.rank);\n  null != i && (n = n.transpose(i), a = getInnerMostAxes(a.length, n.rank));\n  var s = ENV.engine.runKernel(function (e) {\n    return e.any(n, a);\n  }, {\n    $x: n\n  });\n\n  if (r) {\n    var u = expandShapeToKeepDim(s.shape, o);\n    return s.reshape(u);\n  }\n\n  return s;\n}\n\nfunction moments_(e, t, r) {\n  void 0 === t && (t = null), void 0 === r && (r = !1);\n  var n = parseAxisParam(t, (e = convertToTensor(e, \"x\", \"moments\")).shape),\n      o = e.mean(n, r),\n      a = o.shape;\n  return r || (a = expandShapeToKeepDim(o.shape, n)), {\n    mean: o,\n    variance: e.toFloat().sub(o.reshape(a)).square().mean(n, r)\n  };\n}\n\nvar all = op({\n  all_: all_\n}),\n    any = op({\n  any_: any_\n}),\n    argMax = op({\n  argMax_: argMax_\n}),\n    argMin = op({\n  argMin_: argMin_\n}),\n    logSumExp = op({\n  logSumExp_: logSumExp_\n}),\n    max = op({\n  max_: max_\n}),\n    mean = op({\n  mean_: mean_\n}),\n    min = op({\n  min_: min_\n}),\n    moments = op({\n  moments_: moments_\n}),\n    sum$1 = op({\n  sum_: sum_\n}),\n    prod = op({\n  prod_: prod_\n});\n\nfunction notEqual_(e, t) {\n  var r = convertToTensor(e, \"a\", \"notEqual\"),\n      n = convertToTensor(t, \"b\", \"notEqual\");\n  return assertTypesMatch(r, n), assertAndGetBroadcastShape(r.shape, n.shape), ENV.engine.runKernel(function (e) {\n    return e.notEqual(r, n);\n  }, {\n    $a: r,\n    $b: n\n  });\n}\n\nfunction notEqualStrict_(e, t) {\n  var r = convertToTensor(e, \"a\", \"notEqualStrict\"),\n      n = convertToTensor(t, \"b\", \"notEqualStrict\");\n  return assertShapesMatch(r.shape, n.shape, \"Error in notEqualStrict: \"), r.notEqual(n);\n}\n\nfunction less_(e, t) {\n  var r = convertToTensor(e, \"a\", \"less\"),\n      n = convertToTensor(t, \"b\", \"less\");\n  return assertTypesMatch(r, n), assertAndGetBroadcastShape(r.shape, n.shape), ENV.engine.runKernel(function (e) {\n    return e.less(r, n);\n  }, {\n    $a: r,\n    $b: n\n  });\n}\n\nfunction lessStrict_(e, t) {\n  var r = convertToTensor(e, \"a\", \"lessStrict\"),\n      n = convertToTensor(t, \"b\", \"lessStrict\");\n  return assertShapesMatch(r.shape, n.shape, \"Error in lessStrict: \"), r.less(n);\n}\n\nfunction equal_(e, t) {\n  var r = convertToTensor(e, \"a\", \"equal\"),\n      n = convertToTensor(t, \"b\", \"equal\");\n  return assertTypesMatch(r, n), assertAndGetBroadcastShape(r.shape, n.shape), ENV.engine.runKernel(function (e) {\n    return e.equal(r, n);\n  }, {\n    $a: r,\n    $b: n\n  });\n}\n\nfunction equalStrict_(e, t) {\n  var r = convertToTensor(e, \"a\", \"equalStrict\"),\n      n = convertToTensor(t, \"b\", \"equalStrict\");\n  return assertShapesMatch(r.shape, n.shape, \"Error in equalStrict: \"), r.equal(n);\n}\n\nfunction lessEqual_(e, t) {\n  var r = convertToTensor(e, \"a\", \"lessEqual\"),\n      n = convertToTensor(t, \"b\", \"lessEqual\");\n  return assertTypesMatch(r, n), assertAndGetBroadcastShape(r.shape, n.shape), ENV.engine.runKernel(function (e) {\n    return e.lessEqual(r, n);\n  }, {\n    $a: r,\n    $b: n\n  });\n}\n\nfunction lessEqualStrict_(e, t) {\n  var r = convertToTensor(e, \"a\", \"lessEqualStrict\"),\n      n = convertToTensor(t, \"b\", \"lessEqualStrict\");\n  return assertShapesMatch(r.shape, n.shape, \"Error in lessEqualStrict: \"), r.lessEqual(n);\n}\n\nfunction greater_(e, t) {\n  var r = convertToTensor(e, \"a\", \"greater\"),\n      n = convertToTensor(t, \"b\", \"greater\");\n  return assertTypesMatch(r, n), assertAndGetBroadcastShape(r.shape, n.shape), ENV.engine.runKernel(function (e) {\n    return e.greater(r, n);\n  }, {\n    $a: r,\n    $b: n\n  });\n}\n\nfunction greaterStrict_(e, t) {\n  var r = convertToTensor(e, \"a\", \"greaterStrict\"),\n      n = convertToTensor(t, \"b\", \"greaterStrict\");\n  return assertShapesMatch(r.shape, n.shape, \"Error in greaterStrict: \"), r.greater(n);\n}\n\nfunction greaterEqual_(e, t) {\n  var r = convertToTensor(e, \"a\", \"greaterEqual\"),\n      n = convertToTensor(t, \"b\", \"greaterEqual\");\n  assertTypesMatch(r, n), assertAndGetBroadcastShape(r.shape, n.shape);\n  return ENV.engine.runKernel(function (e) {\n    return e.greaterEqual(r, n);\n  }, {\n    $a: r,\n    $b: n\n  }, function (e) {\n    return {\n      $a: function $a() {\n        return zerosLike(r);\n      },\n      $b: function $b() {\n        return zerosLike(n);\n      }\n    };\n  });\n}\n\nfunction greaterEqualStrict_(e, t) {\n  var r = convertToTensor(e, \"a\", \"greaterEqualStrict\"),\n      n = convertToTensor(t, \"b\", \"greaterEqualStrict\");\n  return assertShapesMatch(r.shape, n.shape, \"Error in greaterEqualStrict: \"), r.greaterEqual(n);\n}\n\nvar equal = op({\n  equal_: equal_\n}),\n    equalStrict = op({\n  equalStrict_: equalStrict_\n}),\n    greater = op({\n  greater_: greater_\n}),\n    greaterEqual = op({\n  greaterEqual_: greaterEqual_\n}),\n    greaterEqualStrict = op({\n  greaterEqualStrict_: greaterEqualStrict_\n}),\n    greaterStrict = op({\n  greaterStrict_: greaterStrict_\n}),\n    less = op({\n  less_: less_\n}),\n    lessEqual = op({\n  lessEqual_: lessEqual_\n}),\n    lessEqualStrict = op({\n  lessEqualStrict_: lessEqualStrict_\n}),\n    lessStrict = op({\n  lessStrict_: lessStrict_\n}),\n    notEqual = op({\n  notEqual_: notEqual_\n}),\n    notEqualStrict = op({\n  notEqualStrict_: notEqualStrict_\n});\n\nfunction add_(e, t) {\n  var r = convertToTensor(e, \"a\", \"add\"),\n      n = convertToTensor(t, \"b\", \"add\");\n  assertTypesMatch(r, n);\n  var o = assertAndGetBroadcastShape(r.shape, n.shape);\n  return ENV.engine.runKernel(function (e) {\n    return e.add(r, n);\n  }, {\n    $a: r,\n    $b: n\n  }, function (e) {\n    return {\n      $a: function $a() {\n        var t = e,\n            n = getReductionAxes(r.shape, o);\n        return n.length > 0 && (t = t.sum(n)), t.reshape(r.shape);\n      },\n      $b: function $b() {\n        var t = e,\n            r = getReductionAxes(n.shape, o);\n        return r.length > 0 && (t = t.sum(r)), t.reshape(n.shape);\n      }\n    };\n  });\n}\n\nfunction addN_(e) {\n  assert(Array.isArray(e), function () {\n    return \"The argument passed to tf.addN() must be a list of tensors\";\n  }), assert(e.length >= 1, function () {\n    return \"Must pass at least one tensor to tf.addN(), but got \" + e.length;\n  });\n  var t = e.map(function (e, t) {\n    return convertToTensor(e, \"tensors\" + t, \"addN\");\n  }),\n      r = t[0];\n  t.forEach(function (e) {\n    if (e.dtype !== r.dtype) throw new Error(\"All tensors passed to tf.addN() must have the same dtype\");\n  }), t.forEach(function (e) {\n    if (!arraysEqual(e.shape, r.shape)) throw new Error(\"All tensors passed to tf.addN() must have the same shape\");\n  });\n  var n = t;\n  return ENV.engine.runKernel(function (e) {\n    return e.addN(t);\n  }, n, function (e) {\n    var r = {};\n    return t.forEach(function (t, n) {\n      r[n] = function () {\n        return e.clone();\n      };\n    }), r;\n  });\n}\n\nfunction addStrict_(e, t) {\n  var r = convertToTensor(e, \"a\", \"addStrict\"),\n      n = convertToTensor(t, \"b\", \"addStrict\");\n  return assertShapesMatch(r.shape, n.shape, \"Error in addStrict: \"), r.add(n);\n}\n\nfunction sub_(e, t) {\n  var r = convertToTensor(e, \"a\", \"sub\"),\n      n = convertToTensor(t, \"b\", \"sub\");\n  assertTypesMatch(r, n);\n  var o = assertAndGetBroadcastShape(r.shape, n.shape);\n  return ENV.engine.runKernel(function (e) {\n    return e.subtract(r, n);\n  }, {\n    $a: r,\n    $b: n\n  }, function (e) {\n    return {\n      $a: function $a() {\n        var t = e,\n            n = getReductionAxes(r.shape, o);\n        return n.length > 0 && (t = t.sum(n)), t.reshape(r.shape);\n      },\n      $b: function $b() {\n        var t = e,\n            r = getReductionAxes(n.shape, o);\n        return r.length > 0 && (t = t.sum(r)), t.neg().reshape(n.shape);\n      }\n    };\n  });\n}\n\nfunction subStrict_(e, t) {\n  var r = convertToTensor(e, \"a\", \"subStrict\"),\n      n = convertToTensor(t, \"b\", \"subStrict\");\n  return assertShapesMatch(r.shape, n.shape, \"Error in subStrict: \"), r.sub(n);\n}\n\nfunction pow_(e, t) {\n  var r = convertToTensor(e, \"base\", \"pow\"),\n      n = convertToTensor(t, \"exp\", \"pow\"),\n      o = assertAndGetBroadcastShape(r.shape, n.shape);\n  e = r.cast(upcastType(r.dtype, n.dtype)), t = n.cast(upcastType(r.dtype, n.dtype));\n  return ENV.engine.runKernel(function (e, t) {\n    return t(e.pow(r, n));\n  }, {\n    $base: r,\n    $exp: n\n  }, function (e, t) {\n    var a = t[0];\n    return {\n      $base: function $base() {\n        var t = n.toFloat(),\n            a = e.mul(t.mul(r.pow(t.sub(scalar(1))))),\n            i = getReductionAxes(r.shape, o);\n        return i.length > 0 && (a = a.sum(i)), a.reshape(r.shape);\n      },\n      $exp: function $exp() {\n        var t = e.mul(a.mul(r.log()).toFloat()),\n            i = getReductionAxes(n.shape, o);\n        return i.length > 0 && (t = t.sum(i)), t.reshape(n.shape);\n      }\n    };\n  });\n}\n\nfunction powStrict_(e, t) {\n  return assertShapesMatch(e.shape, t.shape, \"Error in powStrict: \"), e.pow(t);\n}\n\nfunction mul_(e, t) {\n  var r = convertToTensor(e, \"a\", \"mul\"),\n      n = convertToTensor(t, \"b\", \"mul\");\n  assertTypesMatch(r, n);\n  var o = assertAndGetBroadcastShape(r.shape, n.shape);\n  return ENV.engine.runKernel(function (e) {\n    return e.multiply(r, n);\n  }, {\n    $a: r,\n    $b: n\n  }, function (e) {\n    return {\n      $a: function $a() {\n        var t = e.mul(n.toFloat()),\n            a = getReductionAxes(r.shape, o);\n        return a.length > 0 ? t.sum(a).reshape(r.shape) : t;\n      },\n      $b: function $b() {\n        var t = e.mul(r.toFloat()),\n            a = getReductionAxes(n.shape, o);\n        return a.length > 0 ? t.sum(a).reshape(n.shape) : t;\n      }\n    };\n  });\n}\n\nfunction mulStrict_(e, t) {\n  var r = convertToTensor(e, \"a\", \"mul\"),\n      n = convertToTensor(t, \"b\", \"mul\");\n  return assertShapesMatch(r.shape, n.shape, \"Error in multiplyStrict: \"), r.mul(n);\n}\n\nfunction div_(e, t) {\n  var r,\n      n = convertToTensor(e, \"a\", \"div\"),\n      o = convertToTensor(t, \"b\", \"div\");\n  if (assertTypesMatch(n, o), \"int32\" === n.dtype && \"int32\" === o.dtype) return floorDiv(n, o);\n\n  r = function r(e) {\n    return e.realDivide(n, o);\n  };\n\n  var a = assertAndGetBroadcastShape(n.shape, o.shape);\n  return ENV.engine.runKernel(r, {\n    $a: n,\n    $b: o\n  }, function (e) {\n    return {\n      $a: function $a() {\n        var t = e.div(o.toFloat()),\n            r = getReductionAxes(n.shape, a);\n        return r.length > 0 ? t.sum(r).reshape(n.shape) : t;\n      },\n      $b: function $b() {\n        var t = e.mul(n.toFloat()),\n            r = getReductionAxes(o.shape, a);\n        r.length > 0 && (t = t.sum(r).reshape(o.shape));\n        var i = o.square();\n        return t.div(i.toFloat()).neg();\n      }\n    };\n  });\n}\n\nfunction floorDiv_(e, t) {\n  var r = convertToTensor(e, \"a\", \"floorDiv\"),\n      n = convertToTensor(t, \"b\", \"floorDiv\");\n  assertTypesMatch(r, n);\n  var o = assertAndGetBroadcastShape(r.shape, n.shape);\n  return ENV.engine.runKernel(function (e) {\n    return e.floorDiv(r, n);\n  }, {\n    $a: r,\n    $b: n\n  }, function (e) {\n    return {\n      $a: function $a() {\n        var t = e.div(n.toFloat()),\n            a = getReductionAxes(r.shape, o);\n        return a.length > 0 ? t.sum(a).reshape(r.shape) : t;\n      },\n      $b: function $b() {\n        var t = e.mul(r.toFloat()),\n            a = getReductionAxes(n.shape, o);\n        a.length > 0 && (t = t.sum(a).reshape(n.shape));\n        var i = n.square();\n        return t.div(i.toFloat()).neg();\n      }\n    };\n  });\n}\n\nfunction divStrict_(e, t) {\n  var r = convertToTensor(e, \"a\", \"div\"),\n      n = convertToTensor(t, \"b\", \"div\");\n  return assertShapesMatch(r.shape, n.shape, \"Error in divideStrict: \"), r.div(n);\n}\n\nfunction mod_(e, t) {\n  var r = convertToTensor(e, \"a\", \"mod\"),\n      n = convertToTensor(t, \"b\", \"mod\");\n  assertTypesMatch(r, n);\n  var o = assertAndGetBroadcastShape(r.shape, n.shape);\n  return ENV.engine.runKernel(function (e) {\n    return e.mod(r, n);\n  }, {\n    $a: r,\n    $b: n\n  }, function (e) {\n    return {\n      $a: function $a() {\n        var t = getReductionAxes(r.shape, o);\n        return t.length > 0 ? e.sum(t).reshape(r.shape) : e;\n      },\n      $b: function $b() {\n        var t = e.mul(r.div(n).floor().neg()),\n            a = getReductionAxes(n.shape, o);\n        return a.length > 0 ? t.sum(a).reshape(n.shape) : t;\n      }\n    };\n  });\n}\n\nfunction modStrict_(e, t) {\n  var r = convertToTensor(e, \"a\", \"modStrict\"),\n      n = convertToTensor(t, \"b\", \"modStrict\");\n  return assertShapesMatch(r.shape, n.shape, \"Error in modStrict: \"), r.mod(n);\n}\n\nfunction minimum_(e, t) {\n  var r = convertToTensor(e, \"a\", \"minimum\"),\n      n = convertToTensor(t, \"b\", \"minimum\");\n  assertTypesMatch(r, n), \"bool\" === r.dtype && (r = r.toInt()), \"bool\" === n.dtype && (n = n.toInt()), assertAndGetBroadcastShape(r.shape, n.shape);\n  return ENV.engine.runKernel(function (e) {\n    return e.minimum(r, n);\n  }, {\n    $a: r,\n    $b: n\n  }, function (e) {\n    return {\n      $a: function $a() {\n        return e.mul(r.lessEqual(n).toFloat());\n      },\n      $b: function $b() {\n        return e.mul(r.greater(n).toFloat());\n      }\n    };\n  });\n}\n\nfunction minimumStrict_(e, t) {\n  var r = convertToTensor(e, \"a\", \"minimumStrict\"),\n      n = convertToTensor(t, \"b\", \"minimumStrict\");\n  return assertShapesMatch(r.shape, n.shape, \"Error in minimumStrict: \"), r.minimum(n);\n}\n\nfunction maximum_(e, t) {\n  var r = convertToTensor(e, \"a\", \"maximum\"),\n      n = convertToTensor(t, \"b\", \"maximum\");\n  assertTypesMatch(r, n), \"bool\" === r.dtype && (r = r.toInt()), \"bool\" === n.dtype && (n = n.toInt()), assertAndGetBroadcastShape(r.shape, n.shape);\n  return ENV.engine.runKernel(function (e) {\n    return e.maximum(r, n);\n  }, {\n    $a: r,\n    $b: n\n  }, function (e) {\n    return {\n      $a: function $a() {\n        return e.mul(r.greaterEqual(n).toFloat());\n      },\n      $b: function $b() {\n        return e.mul(r.less(n).toFloat());\n      }\n    };\n  });\n}\n\nfunction maximumStrict_(e, t) {\n  var r = convertToTensor(e, \"a\", \"maximumStrict\"),\n      n = convertToTensor(t, \"b\", \"maximumStrict\");\n  return assertShapesMatch(r.shape, n.shape, \"Error in maximumStrict: \"), r.maximum(n);\n}\n\nfunction squaredDifference_(e, t) {\n  var r = convertToTensor(e, \"a\", \"squaredDifference\"),\n      n = convertToTensor(t, \"b\", \"squaredDifference\");\n  assertTypesMatch(r, n), assertAndGetBroadcastShape(r.shape, n.shape);\n  return ENV.engine.runKernel(function (e) {\n    return e.squaredDifference(r, n);\n  }, {\n    $a: r,\n    $b: n\n  }, function (e) {\n    var t = scalar(2);\n    return {\n      $a: function $a() {\n        return e.mul(r.sub(n).mul(t));\n      },\n      $b: function $b() {\n        return e.mul(n.sub(r).mul(t));\n      }\n    };\n  });\n}\n\nfunction squaredDifferenceStrict_(e, t) {\n  var r = convertToTensor(e, \"a\", \"squaredDifferenceStrict\"),\n      n = convertToTensor(t, \"b\", \"squaredDifferenceStrict\");\n  return assertShapesMatch(r.shape, n.shape, \"Error in squaredDifferenceStrict: \"), r.squaredDifference(n);\n}\n\nfunction atan2_(e, t) {\n  var r = convertToTensor(e, \"a\", \"atan2\"),\n      n = convertToTensor(t, \"b\", \"atan2\");\n  assertTypesMatch(r, n);\n  var o = assertAndGetBroadcastShape(r.shape, n.shape);\n  return ENV.engine.runKernel(function (e) {\n    return e.atan2(r, n);\n  }, {\n    $a: r,\n    $b: n\n  }, function (e) {\n    return {\n      $a: function $a() {\n        var t = add(r.square(), n.square()),\n            a = e.mul(n.div(t)),\n            i = getReductionAxes(r.shape, o);\n        return i.length > 0 && (a = a.sum(i)), a.reshape(r.shape);\n      },\n      $b: function $b() {\n        var t = add(r.square(), n.square()),\n            a = neg(e.mul(r.div(t))),\n            i = getReductionAxes(n.shape, o);\n        return i.length > 0 && (a = a.sum(i)), a.reshape(n.shape);\n      }\n    };\n  });\n}\n\nvar add = op({\n  add_: add_\n}),\n    addN = op({\n  addN_: addN_\n}),\n    addStrict = op({\n  addStrict_: addStrict_\n}),\n    atan2 = op({\n  atan2_: atan2_\n}),\n    div = op({\n  div_: div_\n}),\n    divStrict = op({\n  divStrict_: divStrict_\n}),\n    floorDiv = op({\n  floorDiv_: floorDiv_\n}),\n    maximum = op({\n  maximum_: maximum_\n}),\n    maximumStrict = op({\n  maximumStrict_: maximumStrict_\n}),\n    minimum = op({\n  minimum_: minimum_\n}),\n    minimumStrict = op({\n  minimumStrict_: minimumStrict_\n}),\n    mod = op({\n  mod_: mod_\n}),\n    modStrict = op({\n  modStrict_: modStrict_\n}),\n    mul = op({\n  mul_: mul_\n}),\n    mulStrict = op({\n  mulStrict_: mulStrict_\n}),\n    pow = op({\n  pow_: pow_\n}),\n    powStrict = op({\n  powStrict_: powStrict_\n}),\n    squaredDifference = op({\n  squaredDifference_: squaredDifference_\n}),\n    squaredDifferenceStrict = op({\n  squaredDifferenceStrict_: squaredDifferenceStrict_\n}),\n    sub = op({\n  sub_: sub_\n}),\n    subStrict = op({\n  subStrict_: subStrict_\n});\n\nfunction logicalNot_(e) {\n  var t = convertToTensor(e, \"x\", \"logicalNot\", \"bool\");\n  return ENV.engine.runKernel(function (e) {\n    return e.logicalNot(t);\n  }, {\n    $x: t\n  });\n}\n\nfunction logicalAnd_(e, t) {\n  var r = convertToTensor(e, \"a\", \"logicalAnd\", \"bool\"),\n      n = convertToTensor(t, \"b\", \"logicalAnd\", \"bool\");\n  return assertAndGetBroadcastShape(r.shape, n.shape), ENV.engine.runKernel(function (e) {\n    return e.logicalAnd(r, n);\n  }, {\n    $a: r,\n    $b: n\n  });\n}\n\nfunction logicalOr_(e, t) {\n  var r = convertToTensor(e, \"a\", \"logicalOr\", \"bool\"),\n      n = convertToTensor(t, \"b\", \"logicalOr\", \"bool\");\n  return assertAndGetBroadcastShape(r.shape, n.shape), ENV.engine.runKernel(function (e) {\n    return e.logicalOr(r, n);\n  }, {\n    $a: r,\n    $b: n\n  });\n}\n\nfunction logicalXor_(e, t) {\n  var r = convertToTensor(e, \"a\", \"logicalXor\", \"bool\"),\n      n = convertToTensor(t, \"b\", \"logicalXor\", \"bool\");\n  return assertAndGetBroadcastShape(r.shape, n.shape), logicalOr(e, t).logicalAnd(logicalAnd(e, t).logicalNot());\n}\n\nfunction where_(e, t, r) {\n  var n = convertToTensor(t, \"a\", \"where\"),\n      o = convertToTensor(r, \"b\", \"where\"),\n      a = convertToTensor(e, \"condition\", \"where\", \"bool\");\n  assertShapesMatch(n.shape, o.shape, \"Error in where: \"), 1 === a.rank ? assert(a.shape[0] === n.shape[0], \"The first dimension of `a` must match the size of `condition`.\") : assertShapesMatch(a.shape, o.shape, \"Error in where: \");\n  return ENV.engine.runKernel(function (e) {\n    return e.select(a, n, o);\n  }, {\n    $condition: a,\n    $a: n,\n    $b: o\n  }, function (e) {\n    return {\n      $condition: function $condition() {\n        return zerosLike(a).toFloat();\n      },\n      $a: function $a() {\n        return e.mul(a.cast(e.dtype));\n      },\n      $b: function $b() {\n        return e.mul(a.logicalNot().cast(e.dtype));\n      }\n    };\n  });\n}\n\nfunction whereAsync_(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    var t, r, n;\n    return __generator(this, function (o) {\n      switch (o.label) {\n        case 0:\n          return [4, (t = convertToTensor(e, \"condition\", \"whereAsync\", \"bool\")).data()];\n\n        case 1:\n          return r = o.sent(), n = whereImpl(t.shape, r), e !== t && t.dispose(), [2, n];\n      }\n    });\n  });\n}\n\nvar logicalAnd = op({\n  logicalAnd_: logicalAnd_\n}),\n    logicalNot = op({\n  logicalNot_: logicalNot_\n}),\n    logicalOr = op({\n  logicalOr_: logicalOr_\n}),\n    logicalXor = op({\n  logicalXor_: logicalXor_\n}),\n    where = op({\n  where_: where_\n}),\n    whereAsync = whereAsync_;\n\nfunction relu_(e) {\n  var t = convertToTensor(e, \"x\", \"relu\");\n  if (\"bool\" === t.dtype) return t.toInt();\n  return ENV.engine.runKernel(function (e) {\n    return e.relu(t);\n  }, {\n    $x: t\n  }, function (e) {\n    var r = t.step();\n    return {\n      $x: function $x() {\n        return e.mulStrict(r.toFloat());\n      }\n    };\n  });\n}\n\nfunction elu_(e) {\n  var t = convertToTensor(e, \"x\", \"elu\");\n  return ENV.engine.runKernel(function (e, r) {\n    return r(e.elu(t));\n  }, {\n    $x: t\n  }, function (e, t) {\n    var r = t[0];\n    return {\n      $x: function $x() {\n        return ENV.engine.runKernel(function (t) {\n          return t.eluDer(e, r);\n        }, {\n          dy: e,\n          y: r\n        });\n      }\n    };\n  });\n}\n\nfunction selu_(e) {\n  var t = convertToTensor(e, \"x\", \"selu\");\n  return ENV.engine.runKernel(function (e) {\n    return e.selu(t);\n  }, {\n    $x: t\n  }, function (e) {\n    return {\n      $x: function $x() {\n        var r = t.greater(scalar(0)),\n            n = scalar(SELU_SCALEALPHA),\n            o = scalar(SELU_SCALE),\n            a = e.mul(o),\n            i = e.mul(n).mul(t.toFloat().exp());\n        return where(r, a, i);\n      }\n    };\n  });\n}\n\nfunction leakyRelu_(e, t) {\n  void 0 === t && (t = .2);\n  var r = convertToTensor(e, \"x\", \"leakyRelu\");\n  return maximum(scalar(t).mul(r), r);\n}\n\nfunction prelu_(e, t) {\n  var r = convertToTensor(e, \"x\", \"prelu\"),\n      n = convertToTensor(t, \"alpha\", \"prelu\"),\n      o = scalar(0);\n  return maximum(o, r).add(n.mul(minimum(o, r)));\n}\n\nvar elu = op({\n  elu_: elu_\n}),\n    leakyRelu = op({\n  leakyRelu_: leakyRelu_\n}),\n    prelu = op({\n  prelu_: prelu_\n}),\n    relu = op({\n  relu_: relu_\n}),\n    selu = op({\n  selu_: selu_\n});\n\nfunction transpose_(e, t) {\n  var r = convertToTensor(e, \"x\", \"transpose\");\n  if (null == t && (t = r.shape.map(function (e, t) {\n    return t;\n  }).reverse()), assert(r.rank === t.length, \"Error in transpose: rank of input \" + r.rank + \" must match length of perm \" + t + \".\"), t.forEach(function (e) {\n    assert(e >= 0 && e < r.rank, \"All entries in 'perm' must be between 0 and \" + (r.rank - 1) + \" but got \" + t);\n  }), r.rank <= 1) return r.clone();\n  return ENV.engine.runKernel(function (e) {\n    return e.transpose(r, t);\n  }, {\n    $x: r\n  }, function (e) {\n    var r = getUndoAxesPermutation(t);\n    return {\n      $x: function $x() {\n        return e.transpose(r);\n      }\n    };\n  });\n}\n\nvar transpose = op({\n  transpose_: transpose_\n});\n\nfunction localResponseNormalization_(e, t, r, n, o) {\n  void 0 === t && (t = 5), void 0 === r && (r = 1), void 0 === n && (n = 1), void 0 === o && (o = .5);\n  var a = convertToTensor(e, \"x\", \"localResponseNormalization\");\n  assert(4 === a.rank || 3 === a.rank, \"Error in localResponseNormalization: x must be rank 3 or 4 but got\\n               rank \" + a.rank + \".\"), assert(isInt(t), \"Error in localResponseNormalization: depthRadius must be an integer\\n                     but got depthRadius \" + t + \".\");\n  var i = a,\n      s = !1;\n  3 === a.rank && (s = !0, i = a.as4D(1, a.shape[0], a.shape[1], a.shape[2]));\n  var u = ENV.engine.runKernel(function (e, a) {\n    return a(e.localResponseNormalization4D(i, t, r, n, o));\n  }, {\n    x4D: i\n  }, function (e, a) {\n    var s = a[0];\n    return {\n      x4D: function x4D() {\n        return ENV.engine.runKernel(function (a) {\n          return a.LRNGrad(e, i, s, t, r, n, o);\n        }, {});\n      }\n    };\n  });\n  return s ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;\n}\n\nvar localResponseNormalization = op({\n  localResponseNormalization_: localResponseNormalization_\n});\n\nfunction norm_(e, t, r, n) {\n  void 0 === t && (t = \"euclidean\"), void 0 === r && (r = null), void 0 === n && (n = !1);\n  var o = normImpl(e = convertToTensor(e, \"x\", \"norm\"), t, r),\n      a = o.shape;\n\n  if (n) {\n    var i = parseAxisParam(r, e.shape);\n    a = expandShapeToKeepDim(o.shape, i);\n  }\n\n  return o.reshape(a);\n}\n\nfunction normImpl(e, t, r) {\n  if (void 0 === r && (r = null), 0 === e.rank) return e.abs();\n  if (1 !== e.rank && null === r) return normImpl(e.reshape([-1]), t, r);\n\n  if (1 === e.rank || \"number\" == typeof r || r instanceof Array && 1 === r.length) {\n    if (1 === t) return e.abs().sum(r);\n    if (t === 1 / 0) return e.abs().max(r);\n    if (t === -1 / 0) return e.abs().min(r);\n    if (\"euclidean\" === t || 2 === t) return e.abs().pow(scalar(2, \"int32\")).sum(r).sqrt();\n    throw new Error(\"Error in norm: invalid ord value: \" + t);\n  }\n\n  if (r instanceof Array && 2 === r.length) {\n    if (1 === t) return e.abs().sum(r[0]).max(r[1] - 1);\n    if (t === 1 / 0) return e.abs().sum(r[1]).max(r[0]);\n    if (t === -1 / 0) return e.abs().sum(r[1]).min(r[0]);\n    if (\"fro\" === t || \"euclidean\" === t) return e.square().sum(r).sqrt();\n    throw new Error(\"Error in norm: invalid ord value: \" + t);\n  }\n\n  throw new Error(\"Error in norm: invalid axis: \" + r);\n}\n\nvar norm = op({\n  norm_: norm_\n});\n\nfunction unsortedSegmentSum_(e, t, r) {\n  var n = convertToTensor(e, \"x\", \"unsortedSegmentSum\"),\n      o = convertToTensor(t, \"segmentIds\", \"unsortedSegmentSum\", \"int32\");\n  assert(isInt(r), \"numSegments must be of dtype int\");\n  return ENV.engine.runKernel(function (e) {\n    return e.unsortedSegmentSum(n, o, r);\n  }, {\n    $x: n\n  }, function (e) {\n    return {\n      $x: function $x() {\n        return gatherDropNegatives(e, o);\n      }\n    };\n  });\n}\n\nfunction gather_(e, t, r) {\n  void 0 === r && (r = 0);\n  var n = convertToTensor(e, \"x\", \"gather\"),\n      o = convertToTensor(t, \"indices\", \"gather\", \"int32\");\n  r = parseAxisParam(r, n.shape)[0];\n  return ENV.engine.runKernel(function (e) {\n    return e.gather(n, o, r);\n  }, {\n    $x: n\n  }, function (e) {\n    return {\n      $x: function $x() {\n        if (0 === r) return unsortedSegmentSum(e, o, n.shape[r]);\n        var t = n.shape,\n            a = o.size,\n            i = t.slice(0, r),\n            s = i.length,\n            u = t.slice(r, t.length).slice(1),\n            l = u.length,\n            c = arrayRange(0, s),\n            p = arrayRange(s + 1, s + 1 + l),\n            d = arrayConcat([i, [a], u]),\n            h = e.reshape(d),\n            f = o.reshape([a]),\n            m = arrayConcat([[s], c, p]),\n            g = h.transpose(m),\n            v = unsortedSegmentSum(g, f, n.shape[r]),\n            y = getUndoAxesPermutation(m);\n        return v = v.transpose(y);\n      }\n    };\n  });\n}\n\nfunction arrayRange(e, t) {\n  for (var r = [], n = e; n < t; ++n) {\n    r.push(n);\n  }\n\n  return r;\n}\n\nfunction arrayConcat(e) {\n  for (var t = [], r = 0; r < e.length; ++r) {\n    for (var n = 0; n < e[r].length; ++n) {\n      t.push(e[r][n]);\n    }\n  }\n\n  return t;\n}\n\nfunction gatherDropNegatives(e, t) {\n  for (var r = maximum(t, zerosLike(t)), n = gather(e, r), o = greaterEqual(t, scalar(0, \"int32\")), a = n.rank - o.rank, i = 0; i < a; ++i) {\n    o = expandDims(o, i + 1);\n  }\n\n  o = logicalAnd(o, ones$1(n.shape, \"bool\"));\n  var s = zerosLike(n);\n  return where(o, n, s);\n}\n\nvar gather = op({\n  gather_: gather_\n}),\n    unsortedSegmentSum = op({\n  unsortedSegmentSum_: unsortedSegmentSum_\n});\n\nfunction multiRNNCell_(e, t, r, n) {\n  for (var o = convertToTensor(t, \"data\", \"multiRNNCell\"), a = convertToTensorArray(r, \"c\", \"multiRNNCell\"), i = convertToTensorArray(n, \"h\", \"multiRNNCell\"), s = o, u = [], l = 0; l < e.length; l++) {\n    var c = e[l](s, a[l], i[l]);\n    u.push(c[0]), u.push(c[1]), s = c[1];\n  }\n\n  var p = [],\n      d = [];\n\n  for (l = 0; l < u.length; l += 2) {\n    p.push(u[l]), d.push(u[l + 1]);\n  }\n\n  return [p, d];\n}\n\nfunction basicLSTMCell_(e, t, r, n, o, a) {\n  var i = convertToTensor(e, \"forgetBias\", \"basicLSTMCell\"),\n      s = convertToTensor(t, \"lstmKernel\", \"basicLSTMCell\"),\n      u = convertToTensor(r, \"lstmBias\", \"basicLSTMCell\"),\n      l = convertToTensor(n, \"data\", \"basicLSTMCell\"),\n      c = convertToTensor(o, \"c\", \"basicLSTMCell\"),\n      p = convertToTensor(a, \"h\", \"basicLSTMCell\"),\n      d = l.concat(p, 1).matMul(s).add(u),\n      h = d.shape[0],\n      f = d.shape[1] / 4,\n      m = [h, f],\n      g = d.slice([0, 0], m),\n      v = d.slice([0, f], m),\n      y = d.slice([0, 2 * f], m),\n      x = d.slice([0, 3 * f], m),\n      T = g.sigmoid().mulStrict(v.tanh()).addStrict(c.mulStrict(i.add(y).sigmoid()));\n  return [T, T.tanh().mulStrict(x.sigmoid())];\n}\n\nvar basicLSTMCell = op({\n  basicLSTMCell_: basicLSTMCell_\n}),\n    multiRNNCell = op({\n  multiRNNCell_: multiRNNCell_\n});\n\nfunction movingAverage_(e, t, r, n, o) {\n  void 0 === o && (o = !0);\n  var a = convertToTensor(e, \"v\", \"movingAverage\"),\n      i = convertToTensor(t, \"x\", \"movingAverage\"),\n      s = convertToTensor(r, \"decay\", \"movingAverage\");\n  assertTypesMatch(a, i), assert(arraysEqual(a.shape, i.shape), \"Shape mismatch in v and x\");\n  var u = scalar(1),\n      l = u.sub(s),\n      c = i.sub(a).mul(l);\n\n  if (o) {\n    assert(null != n, \"When using zeroDebias: true, step is required.\");\n    var p = convertToTensor(n, \"step\", \"movingAverage\");\n    c = c.div(u.sub(pow(s, p)));\n  }\n\n  return a.add(c);\n}\n\nvar movingAverage = op({\n  movingAverage_: movingAverage_\n});\n\nfunction stridedSlice_(e, t, r, n, o, a, i, s, u) {\n  if (void 0 === o && (o = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === u && (u = 0), 0 !== i) throw new Error(\"ellipsis mask is not yet supported\");\n  if (0 !== s) throw new Error(\"new axis mask is not yet supported\");\n  var l = convertToTensor(e, \"x\", \"stridedSlice\");\n  return ENV.engine.runKernel(function (e) {\n    return e.stridedSlice(l, t, r, n, o, a, i, s, u);\n  }, {\n    $x: l\n  });\n}\n\nvar stridedSlice = op({\n  stridedSlice_: stridedSlice_\n});\n\nfunction topk_(e, t, r) {\n  void 0 === t && (t = 1), void 0 === r && (r = !0);\n  var n = convertToTensor(e, \"x\", \"topk\");\n  if (0 === n.rank) throw new Error(\"topk() expects the input to be of rank 1 or higher\");\n  var o = n.shape[n.shape.length - 1];\n  if (t > o) throw new Error(\"'k' passed to topk() must be <= the last dimension (\" + o + \") but got \" + t);\n  var a = ENV.engine.runKernel(function (e) {\n    return e.topk(n, t, r);\n  }, {\n    $x: n\n  });\n  return {\n    values: a[0],\n    indices: a[1]\n  };\n}\n\nvar topk = op({\n  topk_: topk_\n});\n\nfunction scatterND_(e, t, r) {\n  var n = convertToTensor(e, \"indices\", \"scatterND\", \"int32\"),\n      o = convertToTensor(t, \"updates\", \"scatterND\");\n  return validateInput(o, n, r), ENV.engine.runKernel(function (e) {\n    return e.scatterND(n, o, r);\n  }, {\n    $indices: n,\n    $updates: o\n  });\n}\n\nvar scatterND = op({\n  scatterND_: scatterND_\n});\n\nfunction fft_(e) {\n  assert(\"complex64\" === e.dtype, \"The dtype for tf.spectral.fft() must be complex64 but got \" + e.dtype + \".\");\n  var t = e.shape[e.shape.length - 1],\n      r = e.size / t,\n      n = e.as2D(r, t);\n  return ENV.engine.runKernel(function (e) {\n    return e.fft(n);\n  }, {\n    input: e\n  }).reshape(e.shape);\n}\n\nfunction ifft_(e) {\n  assert(\"complex64\" === e.dtype, \"The dtype for tf.spectral.ifft() must be complex64 but got \" + e.dtype + \".\");\n  var t = e.shape[e.shape.length - 1],\n      r = e.size / t,\n      n = e.as2D(r, t);\n  return ENV.engine.runKernel(function (e) {\n    return e.ifft(n);\n  }, {\n    input: e\n  }).reshape(e.shape);\n}\n\nfunction rfft_(e) {\n  assert(\"float32\" === e.dtype, \"The dtype for rfft() must be real value but\\n    got \" + e.dtype);\n  var t = e.shape[e.shape.length - 1],\n      r = e.size / t,\n      n = e.zerosLike(),\n      o = complex(e, n).as2D(r, t),\n      a = fft(o),\n      i = Math.floor(t / 2) + 1,\n      s = real(a),\n      u = imag(a),\n      l = s.split([i, t - i], s.shape.length - 1),\n      c = u.split([i, t - i], u.shape.length - 1),\n      p = e.shape.slice();\n  return p[e.shape.length - 1] = i, complex(l[0], c[0]).reshape(p);\n}\n\nfunction irfft_(e) {\n  var t = e.shape[e.shape.length - 1],\n      r = e.size / t;\n\n  if (t <= 2) {\n    var n = e.as2D(r, t),\n        o = ifft(n);\n    return real(o);\n  }\n\n  var a = [r, 2 * (t - 1)],\n      i = real(e).as2D(r, t),\n      s = imag(e).as2D(r, t),\n      u = i.slice([0, 1], [r, t - 2]).reverse(1),\n      l = s.slice([0, 1], [r, t - 2]).reverse(1).mul(scalar(-1)),\n      c = i.concat(u, 1),\n      p = s.concat(l, 1);\n  n = complex(c, p).as2D(a[0], a[1]), o = ifft(n);\n  return real(o);\n}\n\nvar fft = op({\n  fft_: fft_\n}),\n    ifft = op({\n  ifft_: ifft_\n}),\n    rfft = op({\n  rfft_: rfft_\n}),\n    irfft = op({\n  irfft_: irfft_\n}),\n    spectral_ops = Object.freeze({\n  fft: fft,\n  ifft: ifft,\n  rfft: rfft,\n  irfft: irfft\n});\n\nfunction validateInput$1(e, t, r, n) {\n  if (\"int32\" !== e.dtype) throw new Error(\"tf.sparseToDense() expects the indices to be int32 type, but the dtype was \" + e.dtype + \".\");\n  if (e.rank > 2) throw new Error(\"sparseIndices should be a scalar, vector, or matrix, but got shape \" + e.shape + \".\");\n  var o = e.rank > 0 ? e.shape[0] : 1,\n      a = e.rank > 1 ? e.shape[1] : 1;\n  if (r.length !== a) throw new Error(\"outputShape has incorrect number of elements:, \" + r.length + \", should be: \" + a + \".\");\n  var i = t.size;\n  if (0 !== t.rank && (1 !== t.rank || i !== o)) throw new Error(\"sparseValues has incorrect shape \" + t.shape + \", should be [] or [\" + o + \"]\");\n  if (t.dtype !== n.dtype) throw new Error(\"sparseValues.dtype must match defaultValues.dtype\");\n}\n\nfunction sparseToDense_(e, t, r, n) {\n  var o = convertToTensor(e, \"sparseIndices\", \"sparseToDense\", \"int32\"),\n      a = convertToTensor(t, \"sparseValues\", \"sparseToDense\"),\n      i = convertToTensor(n, \"defaultValue\", \"sparseToDense\", a.dtype);\n  return validateInput$1(o, a, r, i), ENV.engine.runKernel(function (e) {\n    return e.sparseToDense(o, a, r, i);\n  }, {\n    $sparseIndices: o,\n    $sparseValues: a,\n    $defaultValue: i\n  });\n}\n\nvar sparseToDense = op({\n  sparseToDense_: sparseToDense_\n});\n\nfunction gatherND_(e, t) {\n  var r = convertToTensor(t, \"indices\", \"gatherND\", \"int32\"),\n      n = convertToTensor(e, \"x\", \"gatherND\");\n  return ENV.engine.runKernel(function (e) {\n    return e.gatherND(n, r);\n  }, {\n    $x: n,\n    $indices: r\n  });\n}\n\nvar Reduction,\n    gatherND = op({\n  gatherND_: gatherND_\n});\n\nfunction computeWeightedLoss_(e, t, r) {\n  void 0 === r && (r = Reduction.SUM_BY_NONZERO_WEIGHTS);\n  var n = convertToTensor(e, \"losses\", \"computeWeightedLoss\"),\n      o = null;\n  null != t && (o = convertToTensor(t, \"weights\", \"computeWeightedLoss\"));\n  var a = null == o ? n : n.mul(o);\n  if (r === Reduction.NONE) return a;\n  if (r === Reduction.SUM) return a.sum();\n\n  if (r === Reduction.MEAN) {\n    if (null == o) return a.mean();\n    var i = sizeFromShape(n.shape) / sizeFromShape(o.shape),\n        s = a.sum().div(o.sum());\n    return i > 1 ? s.div(scalar(i)) : s;\n  }\n\n  if (r === Reduction.SUM_BY_NONZERO_WEIGHTS) {\n    if (null == o) return a.sum().div(scalar(n.size));\n    var u = o.mul(ones$1(n.shape)).notEqual(scalar(0)).sum().toFloat();\n    return a.sum().div(u);\n  }\n\n  throw Error(\"Unknown reduction: \" + r);\n}\n\nfunction absoluteDifference_(e, t, r, n) {\n  void 0 === n && (n = Reduction.SUM_BY_NONZERO_WEIGHTS);\n  var o = convertToTensor(e, \"labels\", \"absoluteDifference\"),\n      a = convertToTensor(t, \"predictions\", \"absoluteDifference\"),\n      i = null;\n  null != r && (i = convertToTensor(r, \"weights\", \"absoluteDifference\")), assertShapesMatch(o.shape, a.shape, \"Error in absoluteDifference: \");\n  var s = o.sub(a).abs();\n  return computeWeightedLoss(s, i, n);\n}\n\nfunction meanSquaredError_(e, t, r, n) {\n  void 0 === n && (n = Reduction.SUM_BY_NONZERO_WEIGHTS);\n  var o = convertToTensor(e, \"labels\", \"meanSquaredError\"),\n      a = convertToTensor(t, \"predictions\", \"meanSquaredError\"),\n      i = null;\n  null != r && (i = convertToTensor(r, \"weights\", \"meanSquaredError\")), assertShapesMatch(o.shape, a.shape, \"Error in meanSquaredError: \");\n  var s = o.squaredDifference(a);\n  return computeWeightedLoss(s, i, n);\n}\n\nfunction cosineDistance_(e, t, r, n, o) {\n  void 0 === o && (o = Reduction.SUM_BY_NONZERO_WEIGHTS);\n  var a = convertToTensor(e, \"labels\", \"cosineDistance\"),\n      i = convertToTensor(t, \"predictions\", \"cosineDistance\"),\n      s = null;\n  null != n && (s = convertToTensor(n, \"weights\", \"cosineDistance\")), assertShapesMatch(a.shape, i.shape, \"Error in cosineDistance: \");\n  var u = scalar(1).sub(a.mul(i).sum(r, !0));\n  return computeWeightedLoss(u, s, o);\n}\n\nfunction hingeLoss_(e, t, r, n) {\n  void 0 === n && (n = Reduction.SUM_BY_NONZERO_WEIGHTS);\n  var o = convertToTensor(e, \"labels\", \"hingeLoss\"),\n      a = convertToTensor(t, \"predictions\", \"hingeLoss\"),\n      i = null;\n  null != r && (i = convertToTensor(r, \"weights\", \"hingeLoss\")), assertShapesMatch(o.shape, a.shape, \"Error in hingeLoss: \");\n  var s = scalar(1);\n  o = scalar(2).mul(o).sub(s);\n  var u = s.sub(o.mul(a)).relu();\n  return computeWeightedLoss(u, i, n);\n}\n\nfunction logLoss_(e, t, r, n, o) {\n  void 0 === n && (n = 1e-7), void 0 === o && (o = Reduction.SUM_BY_NONZERO_WEIGHTS);\n  var a = convertToTensor(e, \"labels\", \"logLoss\"),\n      i = convertToTensor(t, \"predictions\", \"logLoss\"),\n      s = null;\n  null != r && (s = convertToTensor(r, \"weights\", \"logLoss\")), assertShapesMatch(a.shape, i.shape, \"Error in logLoss: \");\n  var u = scalar(1),\n      l = scalar(n),\n      c = a.mul(i.add(l).log()).neg().sub(u.sub(a).mul(u.sub(i).add(l).log()));\n  return computeWeightedLoss(c, s, o);\n}\n\nfunction sigmoidCrossEntropyWithLogits_(e, t) {\n  var r = convertToTensor(e, \"labels\", \"sigmoidCrossEntropyWithLogits\"),\n      n = convertToTensor(t, \"logits\", \"sigmoidCrossEntropyWithLogits\");\n  assertShapesMatch(r.shape, n.shape, \"Error in sigmoidCrossEntropyWithLogits: \");\n  var o = n.relu(),\n      a = n.mul(r),\n      i = n.abs().neg().exp().log1p();\n  return o.sub(a).add(i);\n}\n\nfunction sigmoidCrossEntropy_(e, t, r, n, o) {\n  void 0 === n && (n = 0), void 0 === o && (o = Reduction.SUM_BY_NONZERO_WEIGHTS);\n  var a = convertToTensor(e, \"multiClassLabels\", \"sigmoidCrossEntropy\"),\n      i = convertToTensor(t, \"logits\", \"sigmoidCrossEntropy\"),\n      s = null;\n\n  if (null != r && (s = convertToTensor(r, \"weights\", \"sigmoidCrossEntropy\")), assertShapesMatch(a.shape, i.shape, \"Error in sigmoidCrossEntropy: \"), n > 0) {\n    var u = scalar(n),\n        l = scalar(1),\n        c = scalar(.5);\n    a = a.mul(l.sub(u)).add(c.mul(u));\n  }\n\n  var p = sigmoidCrossEntropyWithLogits_(a, i);\n  return computeWeightedLoss(p, s, o);\n}\n\nfunction huberLoss_(e, t, r, n, o) {\n  void 0 === n && (n = 1), void 0 === o && (o = Reduction.SUM_BY_NONZERO_WEIGHTS);\n  var a = convertToTensor(e, \"labels\", \"huberLoss\"),\n      i = convertToTensor(t, \"predictions\", \"huberLoss\"),\n      s = null;\n  null != r && (s = convertToTensor(r, \"weights\", \"huberLoss\")), assertShapesMatch(a.shape, i.shape, \"Error in huberLoss: \");\n  var u = scalar(n),\n      l = i.sub(a).abs(),\n      c = minimum(l, u),\n      p = l.sub(c),\n      d = scalar(.5).mul(c.square()).add(u.mul(p));\n  return computeWeightedLoss(d, s, o);\n}\n\nfunction softmaxCrossEntropyWithLogits_(e, t, r) {\n  if (void 0 === r && (r = -1), -1 === r && (r = t.rank - 1), r !== t.rank - 1) throw Error(\"Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank \" + t.rank + \" and dim was \" + r);\n  return customGrad(function (e, t) {\n    var n = t.logSumExp([r], !0),\n        o = t.toFloat().sub(n);\n    return {\n      value: o.mul(e).neg().sum([r]),\n      gradFunc: function gradFunc(t) {\n        var n = expandShapeToKeepDim(t.shape, [r]);\n        return [t.reshape(n).mul(e.toFloat().sub(o.exp())), t.reshape(n).mul(o.exp().sub(e.toFloat()))];\n      }\n    };\n  })(e, t);\n}\n\nfunction softmaxCrossEntropy_(e, t, r, n, o) {\n  void 0 === n && (n = 0), void 0 === o && (o = Reduction.SUM_BY_NONZERO_WEIGHTS);\n  var a = convertToTensor(e, \"onehotLabels\", \"softmaxCrossEntropy\"),\n      i = convertToTensor(t, \"logits\", \"softmaxCrossEntropy\"),\n      s = null;\n\n  if (null != r && (s = convertToTensor(r, \"weights\", \"softmaxCrossEntropy\")), assertShapesMatch(a.shape, i.shape, \"Error in softmaxCrossEntropy: \"), n > 0) {\n    var u = scalar(n),\n        l = scalar(1),\n        c = scalar(a.shape[1]);\n    a = a.mul(l.sub(u)).add(u.div(c));\n  }\n\n  var p = softmaxCrossEntropyWithLogits_(a, i);\n  return computeWeightedLoss(p, s, o);\n}\n\n!function (e) {\n  e[e.NONE = 0] = \"NONE\", e[e.MEAN = 1] = \"MEAN\", e[e.SUM = 2] = \"SUM\", e[e.SUM_BY_NONZERO_WEIGHTS = 3] = \"SUM_BY_NONZERO_WEIGHTS\";\n}(Reduction || (Reduction = {}));\nvar absoluteDifference = op({\n  absoluteDifference_: absoluteDifference_\n}),\n    computeWeightedLoss = op({\n  computeWeightedLoss_: computeWeightedLoss_\n}),\n    cosineDistance = op({\n  cosineDistance_: cosineDistance_\n}),\n    hingeLoss = op({\n  hingeLoss_: hingeLoss_\n}),\n    huberLoss = op({\n  huberLoss_: huberLoss_\n}),\n    logLoss = op({\n  logLoss_: logLoss_\n}),\n    meanSquaredError = op({\n  meanSquaredError_: meanSquaredError_\n}),\n    sigmoidCrossEntropy = op({\n  sigmoidCrossEntropy_: sigmoidCrossEntropy_\n}),\n    softmaxCrossEntropy = op({\n  softmaxCrossEntropy_: softmaxCrossEntropy_\n}),\n    loss_ops = Object.freeze({\n  get Reduction() {\n    return Reduction;\n  },\n\n  absoluteDifference: absoluteDifference,\n  computeWeightedLoss: computeWeightedLoss,\n  cosineDistance: cosineDistance,\n  hingeLoss: hingeLoss,\n  huberLoss: huberLoss,\n  logLoss: logLoss,\n  meanSquaredError: meanSquaredError,\n  sigmoidCrossEntropy: sigmoidCrossEntropy,\n  softmaxCrossEntropy: softmaxCrossEntropy\n});\n\nfunction gramSchmidt_(e) {\n  var t;\n\n  if (Array.isArray(e)) {\n    t = !1, assert(null != e && e.length > 0, \"Gram-Schmidt process: input must not be null, undefined, or empty\");\n\n    for (var r = e[0].shape[0], n = 1; n < e.length; ++n) {\n      assert(e[n].shape[0] === r, \"Gram-Schmidt: Non-unique lengths found in the input vectors: (\" + e[n].shape[0] + \" vs. \" + r + \")\");\n    }\n  } else t = !0, e = split$1(e, e.shape[0], 0).map(function (e) {\n    return squeeze(e, [0]);\n  });\n\n  assert(e.length <= e[0].shape[0], \"Gram-Schmidt: Number of vectors (\" + e.length + \") exceeds number of dimensions (\" + e[0].shape[0] + \").\");\n\n  var o = [],\n      a = e,\n      i = function i(e) {\n    o.push(ENV.engine.tidy(function () {\n      var t = a[e];\n      if (e > 0) for (var r = 0; r < e; ++r) {\n        var n = sum$1(o[r].mulStrict(t)).mul(o[r]);\n        t = t.sub(n);\n      }\n      return t.div(norm(t, \"euclidean\"));\n    }));\n  };\n\n  for (n = 0; n < e.length; ++n) {\n    i(n);\n  }\n\n  return t ? stack(o, 0) : o;\n}\n\nfunction qr_(e, t) {\n  if (void 0 === t && (t = !1), e.rank < 2) throw new Error(\"qr() requires input tensor to have a rank >= 2, but got rank \" + e.rank);\n  if (2 === e.rank) return qr2d(e, t);\n  var r = e.shape.slice(0, e.shape.length - 2).reduce(function (e, t) {\n    return e * t;\n  }),\n      n = [],\n      o = [];\n  return unstack(e.reshape([r, e.shape[e.shape.length - 2], e.shape[e.shape.length - 1]]), 0).forEach(function (e) {\n    var r = qr2d(e, t),\n        a = r[0],\n        i = r[1];\n    n.push(a), o.push(i);\n  }), [stack(n, 0).reshape(e.shape), stack(o, 0).reshape(e.shape)];\n}\n\nfunction qr2d(e, t) {\n  return void 0 === t && (t = !1), ENV.engine.tidy(function () {\n    if (2 !== e.shape.length) throw new Error(\"qr2d() requires a 2D Tensor, but got a \" + e.shape.length + \"D Tensor.\");\n\n    for (var r = e.shape[0], n = e.shape[1], o = eye(r), a = e.clone(), i = tensor2d([[1]], [1, 1]), s = i.clone(), u = r >= n ? n : r, l = function l(e) {\n      var t,\n          u = a,\n          l = s,\n          c = o;\n      t = ENV.engine.tidy(function () {\n        var t = a.slice([e, e], [r - e, 1]),\n            u = t.norm(),\n            l = a.slice([e, e], [1, 1]),\n            c = l.sign().neg(),\n            p = l.sub(c.mul(u)),\n            d = t.div(p);\n        s = 1 === d.shape[0] ? i.clone() : i.concat(d.slice([1, 0], [d.shape[0] - 1, d.shape[1]]), 0);\n        var h = c.matMul(p).div(u).neg(),\n            f = a.slice([e, 0], [r - e, n]),\n            m = h.mul(s);\n        a = 0 === e ? f.sub(m.matMul(s.transpose().matMul(f))) : a.slice([0, 0], [e, n]).concat(f.sub(m.matMul(s.transpose().matMul(f))), 0);\n        var g = o.slice([0, e], [r, o.shape[1] - e]);\n        return o = 0 === e ? g.sub(g.matMul(s).matMul(m.transpose())) : o.slice([0, 0], [r, e]).concat(g.sub(g.matMul(s).matMul(m.transpose())), 1), [s, a, o];\n      }), s = t[0], a = t[1], o = t[2], dispose([u, l, c]);\n    }, c = 0; c < u; ++c) {\n      l(c);\n    }\n\n    return !t && r > n && (o = o.slice([0, 0], [r, n]), a = a.slice([0, 0], [n, n])), [o, a];\n  });\n}\n\nvar gramSchmidt = op({\n  gramSchmidt_: gramSchmidt_\n}),\n    qr = op({\n  qr_: qr_\n}),\n    linalg_ops = Object.freeze({\n  gramSchmidt: gramSchmidt,\n  qr: qr\n});\n\nfunction resizeBilinear_(e, t, r) {\n  void 0 === r && (r = !1);\n  var n = convertToTensor(e, \"images\", \"resizeBilinear\");\n  assert(3 === n.rank || 4 === n.rank, \"Error in resizeBilinear: x must be rank 3 or 4, but got rank \" + n.rank + \".\"), assert(2 === t.length, \"Error in resizeBilinear: new shape must 2D, but got shape \" + t + \".\");\n  var o = n,\n      a = !1;\n  3 === n.rank && (a = !0, o = n.as4D(1, n.shape[0], n.shape[1], n.shape[2]));\n  var i = t[0],\n      s = t[1],\n      u = ENV.engine.runKernel(function (e, t) {\n    return e.resizeBilinear(o, i, s, r);\n  }, {\n    batchImages: o\n  }, function (e, t) {\n    return {\n      batchImages: function batchImages() {\n        return ENV.engine.runKernel(function (t) {\n          return t.resizeBilinearBackprop(e, o, r);\n        }, {});\n      }\n    };\n  });\n  return a ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;\n}\n\nfunction resizeNearestNeighbor_(e, t, r) {\n  void 0 === r && (r = !1);\n  var n = convertToTensor(e, \"images\", \"resizeNearestNeighbor\");\n  assert(3 === n.rank || 4 === n.rank, \"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank \" + n.rank + \".\"), assert(2 === t.length, \"Error in resizeNearestNeighbor: new shape must 2D, but got shape \" + t + \".\"), assert(\"float32\" === n.dtype || \"int32\" === n.dtype, \"`images` must have `int32` or `float32` as dtype\");\n  var o = n,\n      a = !1;\n  3 === n.rank && (a = !0, o = n.as4D(1, n.shape[0], n.shape[1], n.shape[2]));\n  var i = t[0],\n      s = t[1],\n      u = ENV.engine.runKernel(function (e, t) {\n    return e.resizeNearestNeighbor(o, i, s, r);\n  }, {\n    batchImages: o\n  }, function (e, t) {\n    return {\n      batchImages: function batchImages() {\n        return ENV.engine.runKernel(function (t) {\n          return t.resizeNearestNeighborBackprop(e, o, r);\n        }, {});\n      }\n    };\n  });\n  return a ? u.as3D(u.shape[1], u.shape[2], u.shape[3]) : u;\n}\n\nfunction nonMaxSuppression_(e, t, r, n, o) {\n  void 0 === n && (n = .5), void 0 === o && (o = Number.NEGATIVE_INFINITY);\n  var a = convertToTensor(e, \"boxes\", \"nonMaxSuppression\"),\n      i = convertToTensor(t, \"scores\", \"nonMaxSuppression\"),\n      s = nonMaxSuppSanityCheck(a, i, r, n, o);\n  return r = s.maxOutputSize, n = s.iouThreshold, o = s.scoreThreshold, ENV.engine.runKernel(function (e) {\n    return e.nonMaxSuppression(a, i, r, n, o);\n  }, {\n    $boxes: a\n  });\n}\n\nfunction nonMaxSuppressionAsync_(e, t, r, n, o) {\n  return void 0 === n && (n = .5), void 0 === o && (o = Number.NEGATIVE_INFINITY), __awaiter(this, void 0, void 0, function () {\n    var a, i, s, u, l, c;\n    return __generator(this, function (p) {\n      switch (p.label) {\n        case 0:\n          return a = convertToTensor(e, \"boxes\", \"nonMaxSuppressionAsync\"), i = convertToTensor(t, \"scores\", \"nonMaxSuppressionAsync\"), s = nonMaxSuppSanityCheck(a, i, r, n, o), r = s.maxOutputSize, n = s.iouThreshold, o = s.scoreThreshold, [4, a.data()];\n\n        case 1:\n          return u = p.sent(), [4, i.data()];\n\n        case 2:\n          return l = p.sent(), c = nonMaxSuppressionImpl(u, l, r, n, o), a !== e && a.dispose(), i !== t && i.dispose(), [2, c];\n      }\n    });\n  });\n}\n\nfunction nonMaxSuppSanityCheck(e, t, r, n, o) {\n  null == n && (n = .5), null == o && (o = Number.NEGATIVE_INFINITY);\n  var a = e.shape[0];\n  return r = Math.min(r, a), assert(0 <= n && n <= 1, \"iouThreshold must be in [0, 1], but was '\" + n + \"'\"), assert(2 === e.rank, \"boxes must be a 2D tensor, but was of rank '\" + e.rank + \"'\"), assert(4 === e.shape[1], \"boxes must have 4 columns, but 2nd dimension was \" + e.shape[1]), assert(1 === t.rank, \"scores must be a 1D tensor\"), assert(t.shape[0] === a, \"scores has incompatible shape with boxes. Expected \" + a + \", but was \" + t.shape[0]), {\n    maxOutputSize: r,\n    iouThreshold: n,\n    scoreThreshold: o\n  };\n}\n\nfunction cropAndResize_(e, t, r, n, o, a) {\n  var i = convertToTensor(e, \"image\", \"cropAndResize\", \"float32\"),\n      s = convertToTensor(t, \"boxes\", \"cropAndResize\", \"float32\"),\n      u = convertToTensor(r, \"boxInd\", \"cropAndResize\", \"int32\");\n  o = o || \"bilinear\", a = a || 0;\n  var l = s.shape[0];\n  assert(4 === i.rank, \"Error in cropAndResize: image must be rank 4,but got rank \" + i.rank + \".\"), assert(2 === s.rank && 4 === s.shape[1], \"Error in cropAndResize: boxes must be have size [\" + l + \",4] but had shape \" + s.shape + \".\"), assert(1 === u.rank && u.shape[0] === l, \"Error in cropAndResize: boxInd must be have size [\" + l + \"] but had shape \" + s.shape + \".\"), assert(2 === n.length, \"Error in cropAndResize: cropSize must be of length 2, but got length \" + n.length + \".\"), assert(n[0] >= 1 && n[1] >= 1, \"cropSize must be atleast [1,1], but was \" + n), assert(\"bilinear\" === o || \"nearest\" === o, \"method must be bilinear or nearest, but was \" + o);\n  return ENV.engine.runKernel(function (e, t) {\n    return e.cropAndResize(i, s, u, n, o, a);\n  }, {\n    $image: i,\n    $boxes: s\n  });\n}\n\nvar resizeBilinear = op({\n  resizeBilinear_: resizeBilinear_\n}),\n    resizeNearestNeighbor = op({\n  resizeNearestNeighbor_: resizeNearestNeighbor_\n}),\n    nonMaxSuppression = op({\n  nonMaxSuppression_: nonMaxSuppression_\n}),\n    nonMaxSuppressionAsync = nonMaxSuppressionAsync_,\n    cropAndResize = cropAndResize_,\n    image_ops = Object.freeze({\n  resizeBilinear: resizeBilinear,\n  resizeNearestNeighbor: resizeNearestNeighbor,\n  nonMaxSuppression: nonMaxSuppression,\n  nonMaxSuppressionAsync: nonMaxSuppressionAsync,\n  cropAndResize: cropAndResize\n}),\n    ops = Object.freeze({\n  image: image_ops,\n  linalg: linalg_ops,\n  losses: loss_ops,\n  spectral: spectral_ops,\n  op: op,\n  batchNormalization2d: batchNormalization2d,\n  batchNormalization3d: batchNormalization3d,\n  batchNormalization4d: batchNormalization4d,\n  batchNormalization: batchNormalization,\n  complex: complex,\n  real: real,\n  imag: imag,\n  concat: concat,\n  concat1d: concat1d,\n  concat2d: concat2d,\n  concat3d: concat3d,\n  concat4d: concat4d,\n  split: split$1,\n  conv1d: conv1d,\n  conv2d: conv2d,\n  conv2dDerFilter: conv2dDerFilter,\n  depthwiseConv2d: depthwiseConv2d,\n  separableConv2d: separableConv2d,\n  conv2dTranspose: conv2dTranspose,\n  matMul: matMul,\n  dot: dot,\n  outerProduct: outerProduct,\n  reverse: reverse,\n  reverse1d: reverse1d,\n  reverse2d: reverse2d,\n  reverse3d: reverse3d,\n  reverse4d: reverse4d,\n  maxPool: maxPool,\n  avgPool: avgPool,\n  pool: pool,\n  slice: slice,\n  slice1d: slice1d,\n  slice2d: slice2d,\n  slice3d: slice3d,\n  slice4d: slice4d,\n  abs: abs,\n  acos: acos,\n  acosh: acosh,\n  asin: asin,\n  asinh: asinh,\n  atan: atan,\n  atanh: atanh,\n  ceil: ceil,\n  clipByValue: clipByValue,\n  cos: cos,\n  cosh: cosh,\n  erf: erf,\n  exp: exp,\n  expm1: expm1,\n  floor: floor,\n  log: log$1,\n  log1p: log1p,\n  logSigmoid: logSigmoid,\n  neg: neg,\n  reciprocal: reciprocal,\n  round: round,\n  rsqrt: rsqrt,\n  sigmoid: sigmoid,\n  sign: sign,\n  sin: sin,\n  sinh: sinh,\n  softplus: softplus,\n  sqrt: sqrt,\n  square: square,\n  step: step,\n  tan: tan,\n  tanh: tanh$1,\n  all: all,\n  any: any,\n  argMax: argMax,\n  argMin: argMin,\n  logSumExp: logSumExp,\n  max: max,\n  mean: mean,\n  min: min,\n  moments: moments,\n  sum: sum$1,\n  prod: prod,\n  equal: equal,\n  equalStrict: equalStrict,\n  greater: greater,\n  greaterEqual: greaterEqual,\n  greaterEqualStrict: greaterEqualStrict,\n  greaterStrict: greaterStrict,\n  less: less,\n  lessEqual: lessEqual,\n  lessEqualStrict: lessEqualStrict,\n  lessStrict: lessStrict,\n  notEqual: notEqual,\n  notEqualStrict: notEqualStrict,\n  add: add,\n  addN: addN,\n  addStrict: addStrict,\n  atan2: atan2,\n  div: div,\n  divStrict: divStrict,\n  floorDiv: floorDiv,\n  maximum: maximum,\n  maximumStrict: maximumStrict,\n  minimum: minimum,\n  minimumStrict: minimumStrict,\n  mod: mod,\n  modStrict: modStrict,\n  mul: mul,\n  mulStrict: mulStrict,\n  pow: pow,\n  powStrict: powStrict,\n  squaredDifference: squaredDifference,\n  squaredDifferenceStrict: squaredDifferenceStrict,\n  sub: sub,\n  subStrict: subStrict,\n  elu: elu,\n  leakyRelu: leakyRelu,\n  prelu: prelu,\n  relu: relu,\n  selu: selu,\n  logicalAnd: logicalAnd,\n  logicalNot: logicalNot,\n  logicalOr: logicalOr,\n  logicalXor: logicalXor,\n  where: where,\n  whereAsync: whereAsync,\n  buffer: buffer,\n  toPixels: toPixels,\n  print: print,\n  batchToSpaceND: batchToSpaceND,\n  cast: cast,\n  clone: clone,\n  cumsum: cumsum,\n  depthToSpace: depthToSpace,\n  expandDims: expandDims,\n  eye: eye,\n  fromPixels: fromPixels,\n  multinomial: multinomial,\n  oneHot: oneHot,\n  pad: pad,\n  pad1d: pad1d,\n  pad2d: pad2d,\n  pad3d: pad3d,\n  pad4d: pad4d,\n  rand: rand,\n  randomNormal: randomNormal,\n  randomUniform: randomUniform,\n  reshape: reshape,\n  spaceToBatchND: spaceToBatchND,\n  squeeze: squeeze,\n  stack: stack,\n  tile: tile,\n  truncatedNormal: truncatedNormal,\n  unstack: unstack,\n  setdiff1dAsync: setdiff1dAsync,\n  fill: fill,\n  linspace: linspace,\n  ones: ones$1,\n  range: range,\n  scalar: scalar,\n  tensor: tensor,\n  tensor1d: tensor1d,\n  tensor2d: tensor2d,\n  tensor3d: tensor3d,\n  tensor4d: tensor4d,\n  tensor5d: tensor5d,\n  tensor6d: tensor6d,\n  zeros: zeros,\n  onesLike: onesLike,\n  zerosLike: zerosLike,\n  transpose: transpose,\n  softmax: softmax,\n  logSoftmax: logSoftmax,\n  localResponseNormalization: localResponseNormalization,\n  norm: norm,\n  gather: gather,\n  unsortedSegmentSum: unsortedSegmentSum,\n  basicLSTMCell: basicLSTMCell,\n  multiRNNCell: multiRNNCell,\n  movingAverage: movingAverage,\n  stridedSlice: stridedSlice,\n  topk: topk,\n  scatterND: scatterND,\n  fft: fft,\n  ifft: ifft,\n  rfft: rfft,\n  irfft: irfft,\n  sparseToDense: sparseToDense,\n  gatherND: gatherND\n}),\n    MathBackendCPU = function () {\n  function e() {\n    this.blockSize = 48, this.firstUse = !0, ENV.get(\"IS_BROWSER\") && (this.fromPixels2DContext = document.createElement(\"canvas\").getContext(\"2d\"));\n  }\n\n  return e.prototype.setDataMover = function (e) {\n    this.data = new DataStorage(e);\n  }, e.prototype.register = function (e, t, r) {\n    if (this.firstUse && (this.firstUse = !1, ENV.get(\"IS_NODE\") && warn(\"\\n============================\\nHi there 👋. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\\n============================\\n\")), this.data.has(e)) throw new Error(\"Data buffer is already registered\");\n    this.data.set(e, {\n      dtype: r\n    });\n  }, e.prototype.write = function (e, t) {\n    if (null == t) throw new Error(\"MathBackendCPU.write(): values can not be null\");\n    this.data.get(e).values = t;\n  }, e.prototype.fromPixels = function (e, t) {\n    if (null == e) throw new Error(\"pixels passed to tf.fromPixels() can not be null\");\n    var r, n;\n    if (ENV.get(\"IS_NODE\") && null == e.getContext) throw new Error(\"When running in node, pixels must be an HTMLCanvasElement like the one returned by the `canvas` npm package\");\n    if (null != e.getContext) r = e.getContext(\"2d\").getImageData(0, 0, e.width, e.height).data;else if (e instanceof ImageData) r = e.data;else {\n      if (!(e instanceof HTMLImageElement || e instanceof HTMLVideoElement)) throw new Error(\"pixels passed to tf.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement or ImageData, but was \" + e.constructor.name);\n      if (null == this.fromPixels2DContext) throw new Error(\"Can't read pixels from HTMLImageElement outside the browser.\");\n      this.fromPixels2DContext.canvas.width = e.width, this.fromPixels2DContext.canvas.height = e.height, this.fromPixels2DContext.drawImage(e, 0, 0, e.width, e.height), r = this.fromPixels2DContext.getImageData(0, 0, e.width, e.height).data;\n    }\n    if (4 === t) n = new Int32Array(r);else {\n      var o = e.width * e.height;\n      n = new Int32Array(o * t);\n\n      for (var a = 0; a < o; a++) {\n        for (var i = 0; i < t; ++i) {\n          n[a * t + i] = r[4 * a + i];\n        }\n      }\n    }\n    return tensor3d(n, [e.height, e.width, t], \"int32\");\n  }, e.prototype.read = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (t) {\n        return [2, this.readSync(e)];\n      });\n    });\n  }, e.prototype.readSync = function (e) {\n    var t = this.data.get(e),\n        r = t.dtype,\n        n = t.complexTensors;\n    return \"complex64\" === r ? mergeRealAndImagArrays(n.real.dataSync(), n.imag.dataSync()) : this.data.get(e).values;\n  }, e.prototype.disposeData = function (e) {\n    if (this.data.has(e)) {\n      var t = this.data.get(e).complexTensors;\n      null != t && (t.real.dispose(), t.imag.dispose()), this.data.delete(e);\n    }\n  }, e.prototype.time = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t;\n      return __generator(this, function (r) {\n        return t = now(), e(), [2, {\n          kernelMs: now() - t\n        }];\n      });\n    });\n  }, e.prototype.memory = function () {\n    return {\n      unreliable: !0,\n      reasons: [\"The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less.\"]\n    };\n  }, e.prototype.complex = function (e, t) {\n    var r = Tensor.make(e.shape, {}, \"complex64\");\n    return this.data.get(r.dataId).complexTensors = {\n      real: ENV.engine.keep(e.clone()),\n      imag: ENV.engine.keep(t.clone())\n    }, r;\n  }, e.prototype.real = function (e) {\n    return this.data.get(e.dataId).complexTensors.real.clone();\n  }, e.prototype.imag = function (e) {\n    return this.data.get(e.dataId).complexTensors.imag.clone();\n  }, e.prototype.assertNotComplex = function (e, t) {\n    Array.isArray(e) || (e = [e]), e.forEach(function (e) {\n      null != e && assert(\"complex64\" !== e.dtype, t + \" does not support complex64 tensors.\");\n    });\n  }, e.prototype.slice = function (e, t, r) {\n    this.assertNotComplex(e, \"slice\");\n\n    for (var n = buffer(r, e.dtype), o = 0; o < n.size; ++o) {\n      var a = n.indexToLoc(o),\n          i = a.map(function (e, r) {\n        return e + t[r];\n      });\n      n.set.apply(n, [e.get.apply(e, i)].concat(a));\n    }\n\n    return n.toTensor();\n  }, e.prototype.stridedSlice = function (e, t, r, n, o, a, i, s, u) {\n    this.assertNotComplex(e, \"stridedSlice\");\n    var l = getStridedSlicedInfo(e.shape, t, r, n, o, a, i, s, u),\n        c = l[0],\n        p = l[1],\n        d = l[2],\n        h = p.filter(function (e, t) {\n      return -1 === d.indexOf(t);\n    });\n    if (h.some(function (e) {\n      return 0 === e;\n    })) return tensor([], h);\n\n    for (var f = buffer(p, e.dtype), m = 0; m < f.size; m++) {\n      for (var g = f.indexToLoc(m), v = new Array(g.length), y = 0; y < v.length; y++) {\n        v[y] = g[y] * n[y] + c[y];\n      }\n\n      f.set.apply(f, [e.get.apply(e, v)].concat(g));\n    }\n\n    return f.toTensor().reshape(h);\n  }, e.prototype.reverse = function (e, t) {\n    this.assertNotComplex(e, \"reverse\");\n\n    for (var r = buffer(e.shape, e.dtype), n = e.buffer(), o = function o(_o) {\n      var a = r.indexToLoc(_o),\n          i = a.slice();\n      t.forEach(function (t) {\n        return i[t] = e.shape[t] - 1 - i[t];\n      }), r.set.apply(r, [n.get.apply(n, i)].concat(a));\n    }, a = 0; a < r.size; a++) {\n      o(a);\n    }\n\n    return r.toTensor();\n  }, e.prototype.concat = function (e, t) {\n    this.assertNotComplex(e, \"concat\");\n    var r = e.map(function (e) {\n      var r = sizeFromShape(e.shape.slice(t));\n      return e.as2D(-1, r);\n    }),\n        n = computeOutShape(r.map(function (e) {\n      return e.shape;\n    }), 1),\n        o = buffer(n, e[0].dtype).values;\n\n    if (1 === r[0].shape[0]) {\n      var a = 0;\n      r.forEach(function (e) {\n        o.set(e.dataSync(), a), a += e.size;\n      });\n    } else {\n      var i = 0;\n      r.forEach(function (e) {\n        for (var t = e.dataSync(), r = 0, a = 0; a < e.shape[0]; ++a) {\n          for (var s = a * n[1] + i, u = 0; u < e.shape[1]; ++u) {\n            o[s + u] = t[r++];\n          }\n        }\n\n        i += e.shape[1];\n      });\n    }\n\n    var s = computeOutShape(e.map(function (e) {\n      return e.shape;\n    }), t);\n    return tensor(o, s, e[0].dtype);\n  }, e.prototype.neg = function (e) {\n    return this.assertNotComplex(e, \"neg\"), this.multiply(scalar(-1), e);\n  }, e.prototype.add = function (e, t) {\n    return \"complex64\" === e.dtype || \"complex64\" === t.dtype ? this.broadcastedBinaryComplexOp(e.cast(\"complex64\"), t.cast(\"complex64\"), function (e, t, r, n) {\n      return {\n        real: e + r,\n        imag: t + n\n      };\n    }) : this.broadcastedBinaryOp(e, t, upcastType(e.dtype, t.dtype), function (e, t) {\n      return e + t;\n    });\n  }, e.prototype.addN = function (e) {\n    this.assertNotComplex(e, \"addN\");\n\n    for (var t = e.map(function (e) {\n      return e.dataSync();\n    }), r = buffer(e[0].shape, e[0].dtype), n = r.values, o = 0; o < e.length; o++) {\n      for (var a = t[o], i = 0; i < n.length; i++) {\n        n[i] += a[i];\n      }\n    }\n\n    return r.toTensor();\n  }, e.prototype.subtract = function (e, t) {\n    return \"complex64\" === e.dtype || \"complex64\" === t.dtype ? this.broadcastedBinaryComplexOp(e.cast(\"complex64\"), t.cast(\"complex64\"), function (e, t, r, n) {\n      return {\n        real: e - r,\n        imag: t - n\n      };\n    }) : this.broadcastedBinaryOp(e, t, upcastType(e.dtype, t.dtype), function (e, t) {\n      return e - t;\n    });\n  }, e.prototype.pow = function (e, t) {\n    return this.assertNotComplex([e, t], \"pow\"), this.broadcastedBinaryOp(e, t, e.dtype, function (e, t) {\n      return Math.pow(e, t);\n    });\n  }, e.prototype.batchMatMul = function (e, t, r, n) {\n    this.assertNotComplex([e, t], \"matMul\");\n\n    for (var o = r ? e.shape[1] : e.shape[2], a = r ? e.shape[2] : e.shape[1], i = n ? t.shape[1] : t.shape[2], s = e.shape[0], u = e.dataSync(), l = t.dataSync(), c = r ? [e.strides[0], 1, e.strides[1]] : [e.strides[0], e.strides[1], 1], p = c[0], d = c[1], h = c[2], f = n ? [1, t.strides[1], t.strides[0]] : [t.strides[1], 1, t.strides[0]], m = f[0], g = f[1], v = f[2], y = a * i, x = new Float32Array(s * y), T = this.blockSize, E = 0; E < s; E++) {\n      for (var w = 0; w < a; w += T) {\n        for (var S = 0; S < i; S += T) {\n          for (var b = 0; b < o; b += T) {\n            for (var C = Math.min(w + T, a), A = Math.min(S + T, i), _ = Math.min(b + T, o), N = w; N < C; N++) {\n              for (var R = S; R < A; R++) {\n                for (var I = 0, k = b; k < _; k++) {\n                  I += u[E * p + N * d + k * h] * l[k * m + R * g + E * v];\n                }\n\n                x[E * y + (N * i + R)] += I;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return tensor3d(x, [s, a, i]);\n  }, e.prototype.multiply = function (e, t) {\n    return \"complex64\" === e.dtype || \"complex64\" === t.dtype ? this.broadcastedBinaryComplexOp(e.cast(\"complex64\"), t.cast(\"complex64\"), function (e, t, r, n) {\n      return {\n        real: e * r - t * n,\n        imag: e * n + t * r\n      };\n    }) : this.broadcastedBinaryOp(e, t, upcastType(e.dtype, t.dtype), function (e, t) {\n      return e * t;\n    });\n  }, e.prototype.realDivide = function (e, t) {\n    this.assertNotComplex([e, t], \"realDivide\");\n    return this.broadcastedBinaryOp(e, t, \"float32\", function (e, t) {\n      return e / t;\n    });\n  }, e.prototype.floorDiv = function (e, t) {\n    this.assertNotComplex([e, t], \"floorDiv\");\n    return this.broadcastedBinaryOp(e, t, \"int32\", function (e, t) {\n      return Math.floor(e / t);\n    });\n  }, e.prototype.sum = function (e, t) {\n    this.assertNotComplex(e, \"sum\"), assertAxesAreInnerMostDims(\"sum\", t, e.rank);\n\n    for (var r = computeOutAndReduceShapes(e.shape, t), n = r[0], o = r[1], a = zeros(n, upcastType(e.dtype, \"int32\")), i = sizeFromShape(o), s = a.dataSync(), u = e.dataSync(), l = 0; l < s.length; ++l) {\n      for (var c = l * i, p = 0, d = 0; d < i; ++d) {\n        p += u[c + d];\n      }\n\n      s[l] = p;\n    }\n\n    return a;\n  }, e.prototype.prod = function (e, t) {\n    this.assertNotComplex(e, \"sum\");\n\n    for (var r = computeOutAndReduceShapes(e.shape, t), n = r[0], o = r[1], a = zeros(n, upcastType(e.dtype, \"int32\")), i = sizeFromShape(o), s = a.dataSync(), u = e.dataSync(), l = 0; l < s.length; ++l) {\n      for (var c = l * i, p = 1, d = 0; d < i; ++d) {\n        p *= u[c + d];\n      }\n\n      s[l] = p;\n    }\n\n    return a;\n  }, e.prototype.unsortedSegmentSum = function (e, t, r) {\n    this.assertNotComplex(e, \"unsortedSegmentSum\");\n\n    for (var n = [], o = e.rank - t.rank, a = 0; a < o; ++a) {\n      t = t.expandDims(a + 1);\n    }\n\n    for (a = 0; a < r; ++a) {\n      var i = scalar(a, \"int32\"),\n          s = equal(i, t).asType(\"float32\").mul(e).sum(0);\n      n.push(s);\n    }\n\n    return stack(n);\n  }, e.prototype.argMin = function (e, t) {\n    this.assertNotComplex(e, \"argMin\");\n    var r = [t];\n    assertAxesAreInnerMostDims(\"argMin\", r, e.rank);\n\n    for (var n = computeOutAndReduceShapes(e.shape, r), o = n[0], a = n[1], i = zeros(o, \"int32\"), s = sizeFromShape(a), u = i.dataSync(), l = e.dataSync(), c = 0; c < u.length; ++c) {\n      for (var p = c * s, d = l[p], h = 0, f = 0; f < s; ++f) {\n        var m = l[p + f];\n        m < d && (d = m, h = f);\n      }\n\n      u[c] = h;\n    }\n\n    return i;\n  }, e.prototype.argMax = function (e, t) {\n    this.assertNotComplex(e, \"argMax\");\n    var r = [t];\n    assertAxesAreInnerMostDims(\"argMax\", r, e.rank);\n\n    for (var n = computeOutAndReduceShapes(e.shape, r), o = n[0], a = n[1], i = zeros(o, \"int32\"), s = sizeFromShape(a), u = i.dataSync(), l = e.dataSync(), c = 0; c < u.length; ++c) {\n      for (var p = c * s, d = l[p], h = 0, f = 0; f < s; ++f) {\n        var m = l[p + f];\n        m > d && (d = m, h = f);\n      }\n\n      u[c] = h;\n    }\n\n    return i;\n  }, e.prototype.cumsum = function (e, t, r, n) {\n    if (this.assertNotComplex(e, \"cumsum\"), t !== e.rank - 1) throw new Error(\"backend.cumsum in CPU expects an inner-most axis=\" + (e.rank - 1) + \" but got axis=\" + t);\n\n    for (var o = upcastType(e.dtype, \"int32\"), a = zeros(e.shape, o), i = a.dataSync(), s = e.dataSync(), u = e.shape[e.rank - 1], l = n ? function (e, t) {\n      return e + u - t - 1;\n    } : function (e, t) {\n      return e + t;\n    }, c = 0; c < s.length; c += u) {\n      for (var p = 0; p < u; p++) {\n        var d = l(c, p);\n        if (0 === p) i[d] = r ? 0 : s[d];else {\n          var h = l(c, p - 1);\n          i[d] = r ? s[h] + i[h] : s[d] + i[h];\n        }\n      }\n    }\n\n    return a;\n  }, e.prototype.equal = function (e, t) {\n    return this.assertNotComplex([e, t], \"equal\"), this.broadcastedBinaryOp(e, t, \"bool\", function (e, t) {\n      return e === t ? 1 : 0;\n    });\n  }, e.prototype.notEqual = function (e, t) {\n    return this.assertNotComplex([e, t], \"notEqual\"), this.broadcastedBinaryOp(e, t, \"bool\", function (e, t) {\n      return e !== t ? 1 : 0;\n    });\n  }, e.prototype.less = function (e, t) {\n    return this.assertNotComplex([e, t], \"less\"), this.broadcastedBinaryOp(e, t, \"bool\", function (e, t) {\n      return e < t ? 1 : 0;\n    });\n  }, e.prototype.lessEqual = function (e, t) {\n    return this.assertNotComplex([e, t], \"lessEqual\"), this.broadcastedBinaryOp(e, t, \"bool\", function (e, t) {\n      return e <= t ? 1 : 0;\n    });\n  }, e.prototype.greater = function (e, t) {\n    return this.assertNotComplex([e, t], \"greater\"), this.broadcastedBinaryOp(e, t, \"bool\", function (e, t) {\n      return e > t ? 1 : 0;\n    });\n  }, e.prototype.greaterEqual = function (e, t) {\n    return this.assertNotComplex([e, t], \"greaterEqual\"), this.broadcastedBinaryOp(e, t, \"bool\", function (e, t) {\n      return e >= t ? 1 : 0;\n    });\n  }, e.prototype.logicalNot = function (e) {\n    this.assertNotComplex(e, \"logicalNot\");\n\n    for (var t = e.dataSync(), r = new Uint8Array(t.length), n = 0; n < t.length; ++n) {\n      r[n] = t[n] ? 0 : 1;\n    }\n\n    return Tensor.make(e.shape, {\n      values: r\n    }, \"bool\");\n  }, e.prototype.logicalAnd = function (e, t) {\n    return this.assertNotComplex([e, t], \"logicalAnd\"), this.broadcastedBinaryOp(e, t, \"bool\", function (e, t) {\n      return e && t;\n    });\n  }, e.prototype.logicalOr = function (e, t) {\n    return this.assertNotComplex([e, t], \"logicalOr\"), this.broadcastedBinaryOp(e, t, \"bool\", function (e, t) {\n      return e || t;\n    });\n  }, e.prototype.select = function (e, t, r) {\n    this.assertNotComplex([e, t, r], \"select\");\n\n    for (var n = e.dataSync(), o = t.dataSync(), a = r.dataSync(), i = zeros(t.shape, upcastType(t.dtype, r.dtype)), s = i.dataSync(), u = 0, l = 0 === e.rank || e.rank > 1 || 1 === t.rank ? 1 : t.shape[1], c = 0; c < n.length; c++) {\n      for (var p = 0; p < l; p++) {\n        1 === n[c] ? s[u++] = o[c] : s[u++] = a[c];\n      }\n    }\n\n    return i;\n  }, e.prototype.where = function (e) {\n    this.assertNotComplex([e], \"where\");\n    var t = e.dataSync();\n    return whereImpl(e.shape, t);\n  }, e.prototype.topk = function (e, t, r) {\n    return this.assertNotComplex(e, \"topk\"), topkImpl(e.dataSync(), e.shape, e.dtype, t, r);\n  }, e.prototype.min = function (e, t) {\n    this.assertNotComplex(e, \"min\"), assertAxesAreInnerMostDims(\"min\", t, e.rank);\n\n    for (var r = computeOutAndReduceShapes(e.shape, t), n = r[0], o = r[1], a = zeros(n, e.dtype), i = sizeFromShape(o), s = a.dataSync(), u = e.dataSync(), l = 0; l < s.length; ++l) {\n      for (var c = l * i, p = u[c], d = 0; d < i; ++d) {\n        var h = u[c + d];\n        h < p && (p = h);\n      }\n\n      s[l] = p;\n    }\n\n    return a;\n  }, e.prototype.minimum = function (e, t) {\n    return this.assertNotComplex([e, t], \"minimum\"), this.broadcastedBinaryOp(e, t, e.dtype, function (e, t) {\n      return Math.min(e, t);\n    });\n  }, e.prototype.mod = function (e, t) {\n    return this.assertNotComplex([e, t], \"mod\"), this.broadcastedBinaryOp(e, t, e.dtype, function (e, t) {\n      var r = e % t;\n      return e < 0 && t < 0 || e >= 0 && t >= 0 ? r : (r + t) % t;\n    });\n  }, e.prototype.max = function (e, t) {\n    this.assertNotComplex(e, \"max\"), assertAxesAreInnerMostDims(\"max\", t, e.rank);\n\n    for (var r = computeOutAndReduceShapes(e.shape, t), n = r[0], o = r[1], a = zeros(n, e.dtype), i = sizeFromShape(o), s = a.dataSync(), u = e.dataSync(), l = 0; l < s.length; ++l) {\n      for (var c = l * i, p = u[c], d = 0; d < i; ++d) {\n        var h = u[c + d];\n        h > p && (p = h);\n      }\n\n      s[l] = p;\n    }\n\n    return a;\n  }, e.prototype.maximum = function (e, t) {\n    return this.assertNotComplex([e, t], \"maximum\"), this.broadcastedBinaryOp(e, t, e.dtype, function (e, t) {\n      return Math.max(e, t);\n    });\n  }, e.prototype.all = function (e, t) {\n    this.assertNotComplex(e, \"all\"), assertAxesAreInnerMostDims(\"all\", t, e.rank);\n\n    for (var r = computeOutAndReduceShapes(e.shape, t), n = r[0], o = r[1], a = zeros(n, e.dtype), i = sizeFromShape(o), s = a.dataSync(), u = e.dataSync(), l = 0; l < s.length; ++l) {\n      for (var c = l * i, p = u[c], d = 0; d < i; ++d) {\n        var h = u[c + d];\n        p = p && h;\n      }\n\n      s[l] = p;\n    }\n\n    return a;\n  }, e.prototype.any = function (e, t) {\n    this.assertNotComplex(e, \"any\"), assertAxesAreInnerMostDims(\"any\", t, e.rank);\n\n    for (var r = computeOutAndReduceShapes(e.shape, t), n = r[0], o = r[1], a = zeros(n, e.dtype), i = sizeFromShape(o), s = a.dataSync(), u = e.dataSync(), l = 0; l < s.length; ++l) {\n      for (var c = l * i, p = u[c], d = 0; d < i; ++d) {\n        var h = u[c + d];\n        p = p || h;\n      }\n\n      s[l] = p;\n    }\n\n    return a;\n  }, e.prototype.squaredDifference = function (e, t) {\n    return this.assertNotComplex([e, t], \"squaredDifference\"), this.broadcastedBinaryOp(e, t, e.dtype, function (e, t) {\n      var r = e - t;\n      return r * r;\n    });\n  }, e.prototype.ceil = function (e) {\n    this.assertNotComplex(e, \"ceil\");\n\n    for (var t = e.dataSync(), r = new Float32Array(t.length), n = 0; n < t.length; ++n) {\n      r[n] = Math.ceil(t[n]);\n    }\n\n    return Tensor.make(e.shape, {\n      values: r\n    });\n  }, e.prototype.floor = function (e) {\n    this.assertNotComplex(e, \"floor\");\n\n    for (var t = e.dataSync(), r = new Float32Array(t.length), n = 0; n < t.length; ++n) {\n      r[n] = Math.floor(t[n]);\n    }\n\n    return Tensor.make(e.shape, {\n      values: r\n    });\n  }, e.prototype.sign = function (e) {\n    this.assertNotComplex(e, \"x\");\n\n    for (var t = e.dataSync(), r = new Float32Array(t.length), n = 0; n < t.length; ++n) {\n      t[n] < 0 ? r[n] = -1 : t[n] > 0 ? r[n] = 1 : r[n] = 0;\n    }\n\n    return Tensor.make(e.shape, {\n      values: r\n    });\n  }, e.prototype.round = function (e) {\n    this.assertNotComplex(e, \"round\");\n\n    for (var t = e.dataSync(), r = new Float32Array(t.length), n = 0; n < t.length; ++n) {\n      var o = Math.floor(t[n]);\n      t[n] - o < .5 ? r[n] = Math.floor(t[n]) : t[n] - o > .5 ? r[n] = Math.ceil(t[n]) : r[n] = o % 2 == 0 ? o : o + 1;\n    }\n\n    return Tensor.make(e.shape, {\n      values: r\n    });\n  }, e.prototype.exp = function (e) {\n    this.assertNotComplex(e, \"exp\");\n\n    for (var t = e.dataSync(), r = new Float32Array(t.length), n = 0; n < t.length; ++n) {\n      r[n] = Math.exp(t[n]);\n    }\n\n    return Tensor.make(e.shape, {\n      values: r\n    });\n  }, e.prototype.expm1 = function (e) {\n    this.assertNotComplex(e, \"expm1\");\n\n    for (var t = e.dataSync(), r = new Float32Array(t.length), n = 0; n < t.length; ++n) {\n      r[n] = Math.expm1(t[n]);\n    }\n\n    return Tensor.make(e.shape, {\n      values: r\n    });\n  }, e.prototype.log = function (e) {\n    this.assertNotComplex(e, \"log\");\n\n    for (var t = e.dataSync(), r = new Float32Array(t.length), n = 0; n < t.length; ++n) {\n      var o = t[n];\n      r[n] = Math.log(o);\n    }\n\n    return Tensor.make(e.shape, {\n      values: r\n    });\n  }, e.prototype.log1p = function (e) {\n    this.assertNotComplex(e, \"log1p\");\n\n    for (var t = e.dataSync(), r = new Float32Array(t.length), n = 0; n < t.length; ++n) {\n      var o = t[n];\n      r[n] = Math.log1p(o);\n    }\n\n    return Tensor.make(e.shape, {\n      values: r\n    });\n  }, e.prototype.sqrt = function (e) {\n    this.assertNotComplex(e, \"sqrt\");\n\n    for (var t = e.dataSync(), r = new Float32Array(t.length), n = 0; n < t.length; ++n) {\n      var o = t[n];\n      r[n] = Math.sqrt(o);\n    }\n\n    return Tensor.make(e.shape, {\n      values: r\n    });\n  }, e.prototype.rsqrt = function (e) {\n    this.assertNotComplex(e, \"rsqrt\");\n\n    for (var t = e.dataSync(), r = new Float32Array(t.length), n = 0; n < t.length; ++n) {\n      var o = t[n];\n      r[n] = 1 / Math.sqrt(o);\n    }\n\n    return Tensor.make(e.shape, {\n      values: r\n    });\n  }, e.prototype.square = function (e) {\n    this.assertNotComplex(e, \"square\");\n\n    for (var t = e.dataSync(), r = new Float32Array(t.length), n = 0; n < t.length; ++n) {\n      var o = t[n];\n      r[n] = o * o;\n    }\n\n    return Tensor.make(e.shape, {\n      values: r\n    });\n  }, e.prototype.reciprocal = function (e) {\n    this.assertNotComplex(e, \"reciprocal\");\n\n    for (var t = e.dataSync(), r = new Float32Array(t.length), n = 0; n < t.length; ++n) {\n      r[n] = 1 / t[n];\n    }\n\n    return Tensor.make(e.shape, {\n      values: r\n    });\n  }, e.prototype.relu = function (e) {\n    this.assertNotComplex(e, \"relu\");\n\n    for (var t = zeros(e.shape, e.dtype), r = t.dataSync(), n = e.dataSync(), o = 0; o < n.length; ++o) {\n      r[o] = Math.max(0, n[o]);\n    }\n\n    return t;\n  }, e.prototype.elu = function (e) {\n    this.assertNotComplex(e, \"elu\");\n\n    for (var t = new Float32Array(e.size), r = e.dataSync(), n = 0; n < r.length; ++n) {\n      var o = r[n];\n      t[n] = o >= 0 ? o : Math.exp(o) - 1;\n    }\n\n    return Tensor.make(e.shape, {\n      values: t\n    });\n  }, e.prototype.eluDer = function (e, t) {\n    this.assertNotComplex([e, t], \"eluDer\");\n\n    for (var r = new Float32Array(t.size), n = t.dataSync(), o = e.dataSync(), a = 0; a < n.length; ++a) {\n      var i = n[a];\n      r[a] = i >= 1 ? o[a] : o[a] * (i + 1);\n    }\n\n    return Tensor.make(t.shape, {\n      values: r\n    });\n  }, e.prototype.selu = function (e) {\n    this.assertNotComplex(e, \"selu\");\n\n    for (var t = SELU_SCALEALPHA, r = SELU_SCALE, n = new Float32Array(e.size), o = e.dataSync(), a = 0; a < o.length; ++a) {\n      var i = o[a];\n      n[a] = i >= 0 ? r * i : t * (Math.exp(i) - 1);\n    }\n\n    return Tensor.make(e.shape, {\n      values: n\n    });\n  }, e.prototype.clip = function (e, t, r) {\n    this.assertNotComplex(e, \"clip\");\n\n    for (var n = new Float32Array(e.size), o = e.dataSync(), a = 0; a < o.length; ++a) {\n      var i = o[a];\n      n[a] = i > r ? r : i < t ? t : i;\n    }\n\n    return Tensor.make(e.shape, {\n      values: n\n    });\n  }, e.prototype.abs = function (e) {\n    for (var t = new Float32Array(e.size), r = e.dataSync(), n = 0; n < r.length; ++n) {\n      t[n] = Math.abs(r[n]);\n    }\n\n    return Tensor.make(e.shape, {\n      values: t\n    });\n  }, e.prototype.complexAbs = function (e) {\n    for (var t = new Float32Array(e.size), r = e.dataSync(), n = 0; n < e.size; ++n) {\n      var o = r[2 * n],\n          a = r[2 * n + 1];\n      t[n] = Math.hypot(o, a);\n    }\n\n    return Tensor.make(e.shape, {\n      values: t\n    });\n  }, e.prototype.int = function (e) {\n    this.assertNotComplex(e, \"int\");\n\n    for (var t = new Int32Array(e.size), r = e.dataSync(), n = 0; n < r.length; ++n) {\n      t[n] = r[n];\n    }\n\n    return Tensor.make(e.shape, {\n      values: t\n    }, \"int32\");\n  }, e.prototype.sigmoid = function (e) {\n    this.assertNotComplex(e, \"sigmoid\");\n\n    for (var t = new Float32Array(e.size), r = e.dataSync(), n = 0; n < r.length; ++n) {\n      t[n] = 1 / (1 + Math.exp(-r[n]));\n    }\n\n    return Tensor.make(e.shape, {\n      values: t\n    });\n  }, e.prototype.softplus = function (e) {\n    this.assertNotComplex(e, \"softplus\");\n\n    for (var t = Math.log(1.1920928955078125e-7) + 2, r = new Float32Array(e.size), n = e.dataSync(), o = 0; o < n.length; ++o) {\n      var a = n[o] > -t,\n          i = n[o] < t,\n          s = Math.exp(n[o]),\n          u = void 0;\n      u = i ? s : a ? n[o] : Math.log(1 + s), r[o] = u;\n    }\n\n    return Tensor.make(e.shape, {\n      values: r\n    });\n  }, e.prototype.sin = function (e) {\n    this.assertNotComplex(e, \"sin\");\n\n    for (var t = new Float32Array(e.size), r = e.dataSync(), n = 0; n < r.length; ++n) {\n      t[n] = Math.sin(r[n]);\n    }\n\n    return Tensor.make(e.shape, {\n      values: t\n    });\n  }, e.prototype.cos = function (e) {\n    this.assertNotComplex(e, \"cos\");\n\n    for (var t = new Float32Array(e.size), r = e.dataSync(), n = 0; n < r.length; ++n) {\n      t[n] = Math.cos(r[n]);\n    }\n\n    return Tensor.make(e.shape, {\n      values: t\n    });\n  }, e.prototype.tan = function (e) {\n    this.assertNotComplex(e, \"tan\");\n\n    for (var t = new Float32Array(e.size), r = e.dataSync(), n = 0; n < r.length; ++n) {\n      t[n] = Math.tan(r[n]);\n    }\n\n    return Tensor.make(e.shape, {\n      values: t\n    });\n  }, e.prototype.asin = function (e) {\n    this.assertNotComplex(e, \"asin\");\n\n    for (var t = new Float32Array(e.size), r = e.dataSync(), n = 0; n < r.length; ++n) {\n      t[n] = Math.asin(r[n]);\n    }\n\n    return Tensor.make(e.shape, {\n      values: t\n    });\n  }, e.prototype.acos = function (e) {\n    this.assertNotComplex(e, \"acos\");\n\n    for (var t = new Float32Array(e.size), r = e.dataSync(), n = 0; n < r.length; ++n) {\n      t[n] = Math.acos(r[n]);\n    }\n\n    return Tensor.make(e.shape, {\n      values: t\n    });\n  }, e.prototype.atan = function (e) {\n    this.assertNotComplex(e, \"atan\");\n\n    for (var t = new Float32Array(e.size), r = e.dataSync(), n = 0; n < r.length; ++n) {\n      t[n] = Math.atan(r[n]);\n    }\n\n    return Tensor.make(e.shape, {\n      values: t\n    });\n  }, e.prototype.atan2 = function (e, t) {\n    return this.assertNotComplex([e, t], \"atan2\"), this.broadcastedBinaryOp(e, t, e.dtype, function (e, t) {\n      return Math.atan2(e, t);\n    });\n  }, e.prototype.sinh = function (e) {\n    this.assertNotComplex(e, \"sinh\");\n\n    for (var t = new Float32Array(e.size), r = e.dataSync(), n = 0; n < r.length; ++n) {\n      t[n] = Math.sinh(r[n]);\n    }\n\n    return Tensor.make(e.shape, {\n      values: t\n    });\n  }, e.prototype.cosh = function (e) {\n    this.assertNotComplex(e, \"cosh\");\n\n    for (var t = new Float32Array(e.size), r = e.dataSync(), n = 0; n < r.length; ++n) {\n      t[n] = Math.cosh(r[n]);\n    }\n\n    return Tensor.make(e.shape, {\n      values: t\n    });\n  }, e.prototype.tanh = function (e) {\n    this.assertNotComplex(e, \"tanh\");\n\n    for (var t = new Float32Array(e.size), r = e.dataSync(), n = 0; n < r.length; ++n) {\n      t[n] = tanh(r[n]);\n    }\n\n    return Tensor.make(e.shape, {\n      values: t\n    });\n  }, e.prototype.asinh = function (e) {\n    this.assertNotComplex(e, \"asinh\");\n\n    for (var t = new Float32Array(e.size), r = e.dataSync(), n = 0; n < r.length; ++n) {\n      t[n] = Math.asinh(r[n]);\n    }\n\n    return Tensor.make(e.shape, {\n      values: t\n    });\n  }, e.prototype.acosh = function (e) {\n    this.assertNotComplex(e, \"acosh\");\n\n    for (var t = new Float32Array(e.size), r = e.dataSync(), n = 0; n < r.length; ++n) {\n      t[n] = Math.acosh(r[n]);\n    }\n\n    return Tensor.make(e.shape, {\n      values: t\n    });\n  }, e.prototype.atanh = function (e) {\n    this.assertNotComplex(e, \"atanh\");\n\n    for (var t = new Float32Array(e.size), r = e.dataSync(), n = 0; n < r.length; ++n) {\n      t[n] = Math.atanh(r[n]);\n    }\n\n    return Tensor.make(e.shape, {\n      values: t\n    });\n  }, e.prototype.erf = function (e) {\n    this.assertNotComplex(e, \"erf\");\n\n    for (var t = new Float32Array(e.size), r = e.dataSync(), n = ERF_P, o = ERF_A1, a = ERF_A2, i = ERF_A3, s = ERF_A4, u = ERF_A5, l = 0; l < r.length; ++l) {\n      var c = r[l],\n          p = 1 / (1 + n * c);\n      t[l] = 1 - ((((u * p + s) * p + i) * p + a) * p + o) * p * Math.exp(-c * c);\n    }\n\n    return Tensor.make(e.shape, {\n      values: t\n    });\n  }, e.prototype.step = function (e, t) {\n    void 0 === t && (t = 0), this.assertNotComplex(e, \"step\");\n\n    for (var r = new Float32Array(e.size), n = e.dataSync(), o = 0; o < n.length; ++o) {\n      var a = n[o];\n      isNaN(a) ? r[o] = NaN : r[o] = a > 0 ? 1 : t;\n    }\n\n    return Tensor.make(e.shape, {\n      values: r\n    });\n  }, e.prototype.conv2d = function (e, t, r) {\n    this.assertNotComplex([e, t], \"conv2d\");\n\n    for (var n = r.filterHeight, o = r.filterWidth, a = r.dilationHeight, i = r.dilationWidth, s = r.padInfo.left, u = r.padInfo.top, l = buffer(r.outShape, e.dtype), c = e.dataSync(), p = t.dataSync(), d = l.values, h = 0; h < r.batchSize; ++h) {\n      for (var f = h * e.strides[0], m = h * l.strides[0], g = 0; g < r.outHeight; ++g) {\n        for (var v = m + g * l.strides[1], y = g * r.strideHeight - s, x = 0; x < n; x++) {\n          var T = y + x * a;\n          if (!(T < 0 || T >= r.inHeight)) for (var E = x * t.strides[0], w = f + T * e.strides[1], S = 0; S < r.outWidth; ++S) {\n            for (var b = v + S * r.outChannels, C = S * r.strideWidth - u, A = 0; A < o; A++) {\n              var _ = C + A * i;\n\n              if (!(_ < 0 || _ >= r.inWidth)) for (var N = E + A * t.strides[1], R = w + _ * r.inChannels, I = N, k = 0; k < r.inChannels; ++k) {\n                for (var D = c[R + k], M = 0; M < r.outChannels; ++M) {\n                  d[b + M] += D * p[I + M];\n                }\n\n                I += r.outChannels;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return l.toTensor();\n  }, e.prototype.conv2dDerInput = function (e, t, r) {\n    this.assertNotComplex([e, t], \"conv2dDerInput\");\n\n    for (var n = buffer(r.inShape, \"float32\"), o = n.values, a = n.strides, i = a[0], s = a[1], u = a[2], l = e.dataSync(), c = e.strides, p = c[0], d = c[1], h = c[2], f = t.dataSync(), m = t.strides, g = m[0], v = m[1], y = m[2], x = r.batchSize, T = r.filterHeight, E = r.filterWidth, w = r.inChannels, S = r.inHeight, b = r.inWidth, C = r.outChannels, A = r.outHeight, _ = r.outWidth, N = r.strideHeight, R = r.strideWidth, I = T - 1 - r.padInfo.top, k = E - 1 - r.padInfo.left, D = 0; D < x; ++D) {\n      for (var M = 0; M < w; ++M) {\n        for (var O = 0; O < S; ++O) {\n          for (var P = O - I, F = Math.max(0, Math.ceil(P / N)), L = Math.min(A, (T + P) / N), B = 0; B < b; ++B) {\n            for (var U = B - k, z = Math.max(0, Math.ceil(U / R)), V = Math.min(_, (E + U) / R), H = 0, G = F; G < L; ++G) {\n              for (var W = G * N - P, q = z; q < V; ++q) {\n                for (var $ = p * D + d * G + h * q, X = g * (T - 1 - W) + v * (E - 1 - (q * R - U)) + y * M, K = 0; K < C; ++K) {\n                  H += l[$ + K] * f[X + K];\n                }\n              }\n            }\n\n            o[i * D + s * O + u * B + M] = H;\n          }\n        }\n      }\n    }\n\n    return n.toTensor();\n  }, e.prototype.conv2dDerFilter = function (e, t, r) {\n    this.assertNotComplex([e, t], \"conv2dDerFilter\");\n\n    for (var n = r.strideHeight, o = r.strideWidth, a = r.filterHeight, i = r.filterWidth, s = buffer(r.filterShape, \"float32\"), u = r.padInfo.left, l = r.padInfo.top, c = 0; c < a; ++c) {\n      for (var p = Math.max(0, Math.ceil((l - c) / n)), d = Math.min(r.outHeight, (r.inHeight + l - c) / n), h = 0; h < i; ++h) {\n        for (var f = Math.max(0, Math.ceil((u - h) / o)), m = Math.min(r.outWidth, (r.inWidth + u - h) / o), g = 0; g < r.inChannels; ++g) {\n          for (var v = 0; v < r.outChannels; ++v) {\n            for (var y = 0, x = 0; x < r.batchSize; ++x) {\n              for (var T = p; T < d; ++T) {\n                for (var E = c + T * n - l, w = f; w < m; ++w) {\n                  var S = h + w * o - u;\n                  y += e.get(x, E, S, g) * t.get(x, T, w, v);\n                }\n              }\n            }\n\n            s.set(y, c, h, g, v);\n          }\n        }\n      }\n    }\n\n    return s.toTensor();\n  }, e.prototype.depthwiseConv2D = function (e, t, r) {\n    this.assertNotComplex([e, t], \"depthwiseConv2D\");\n\n    for (var n = r.filterHeight, o = r.filterWidth, a = r.dilationHeight, i = r.dilationWidth, s = r.padInfo.left, u = r.padInfo.top, l = r.outChannels / r.inChannels, c = buffer(r.outShape, e.dtype), p = e.dataSync(), d = t.dataSync(), h = c.values, f = 0; f < r.batchSize; ++f) {\n      for (var m = f * e.strides[0], g = f * c.strides[0], v = 0; v < r.outHeight; ++v) {\n        for (var y = g + v * c.strides[1], x = v * r.strideHeight - s, T = 0; T < n; ++T) {\n          var E = x + T * a;\n          if (!(E < 0 || E >= r.inHeight)) for (var w = T * t.strides[0], S = m + E * e.strides[1], b = 0; b < r.outWidth; ++b) {\n            for (var C = y + b * c.strides[2], A = b * r.strideWidth - u, _ = 0; _ < o; ++_) {\n              var N = A + _ * i;\n              if (!(N < 0 || N >= r.inWidth)) for (var R = w + _ * t.strides[1], I = S + N * r.inChannels, k = C, D = R, M = 0; M < r.inChannels; ++M) {\n                for (var O = p[I + M], P = 0; P < l; ++P) {\n                  h[k + P] += O * d[D + P];\n                }\n\n                k += l, D += l;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return c.toTensor();\n  }, e.prototype.depthwiseConv2DDerInput = function (e, t, r) {\n    this.assertNotComplex([e, t], \"depthwiseConv2DDerInput\");\n\n    for (var n = buffer(r.inShape, \"float32\"), o = n.values, a = n.strides, i = a[0], s = a[1], u = a[2], l = e.dataSync(), c = e.strides, p = c[0], d = c[1], h = c[2], f = t.dataSync(), m = t.strides, g = m[0], v = m[1], y = m[2], x = r.batchSize, T = r.filterHeight, E = r.filterWidth, w = r.inChannels, S = r.inHeight, b = r.inWidth, C = r.outChannels, A = r.outHeight, _ = r.outWidth, N = r.strideHeight, R = r.strideWidth, I = T - 1 - r.padInfo.top, k = E - 1 - r.padInfo.left, D = C / w, M = 0; M < x; ++M) {\n      for (var O = 0; O < w; ++O) {\n        for (var P = 0; P < S; ++P) {\n          for (var F = P - I, L = Math.max(0, Math.ceil(F / N)), B = Math.min(A, (T + F) / N), U = 0; U < b; ++U) {\n            for (var z = U - k, V = Math.max(0, Math.ceil(z / R)), H = Math.min(_, (E + z) / R), G = 0, W = L; W < B; ++W) {\n              for (var q = W * N - F, $ = V; $ < H; ++$) {\n                for (var X = p * M + d * W + h * $, K = g * (T - 1 - q) + v * (E - 1 - ($ * R - z)) + y * O, j = 0; j < D; ++j) {\n                  G += l[X + (O * D + j)] * f[K + j];\n                }\n              }\n            }\n\n            o[i * M + s * P + u * U + O] = G;\n          }\n        }\n      }\n    }\n\n    return n.toTensor();\n  }, e.prototype.depthwiseConv2DDerFilter = function (e, t, r) {\n    this.assertNotComplex([e, t], \"depthwiseConv2DDerFilter\");\n\n    for (var n = r.strideHeight, o = r.strideWidth, a = r.filterHeight, i = r.filterWidth, s = buffer(r.filterShape, \"float32\"), u = r.padInfo.left, l = r.padInfo.top, c = r.outChannels / r.inChannels, p = 0; p < a; ++p) {\n      for (var d = Math.max(0, Math.ceil((l - p) / n)), h = Math.min(r.outHeight, (r.inHeight + l - p) / n), f = 0; f < i; ++f) {\n        for (var m = Math.max(0, Math.ceil((u - f) / o)), g = Math.min(r.outWidth, (r.inWidth + u - f) / o), v = 0; v < r.outChannels; ++v) {\n          for (var y = Math.trunc(v / c), x = v % c, T = 0, E = 0; E < r.batchSize; ++E) {\n            for (var w = d; w < h; ++w) {\n              for (var S = p + w * n - l, b = m; b < g; ++b) {\n                var C = f + b * o - u;\n                T += e.get(E, S, C, y) * t.get(E, w, b, v);\n              }\n            }\n          }\n\n          s.set(T, p, f, y, x);\n        }\n      }\n    }\n\n    return s.toTensor();\n  }, e.prototype.tile = function (e, t) {\n    this.assertNotComplex(e, \"tile\");\n\n    for (var r = new Array(e.rank), n = 0; n < r.length; n++) {\n      r[n] = e.shape[n] * t[n];\n    }\n\n    var o = buffer(r, e.dtype),\n        a = e.buffer();\n\n    for (n = 0; n < o.values.length; ++n) {\n      for (var i = o.indexToLoc(n), s = new Array(e.rank), u = 0; u < s.length; u++) {\n        s[u] = i[u] % e.shape[u];\n      }\n\n      var l = a.locToIndex(s);\n      o.values[n] = a.values[l];\n    }\n\n    return o.toTensor();\n  }, e.prototype.pad = function (e, t, r) {\n    this.assertNotComplex(e, \"pad\");\n    var n = t.map(function (t, r) {\n      return t[0] + e.shape[r] + t[1];\n    }),\n        o = t.map(function (e) {\n      return e[0];\n    }),\n        a = e.buffer(),\n        i = buffer(n, e.dtype);\n    0 !== r && i.values.fill(r);\n\n    for (var s = 0; s < e.size; s++) {\n      var u = a.indexToLoc(s),\n          l = u.map(function (e, t) {\n        return e + o[t];\n      });\n      i.set.apply(i, [e.get.apply(e, u)].concat(l));\n    }\n\n    return i.toTensor();\n  }, e.prototype.transpose = function (e, t) {\n    this.assertNotComplex(e, \"transpose\");\n\n    for (var r = new Array(e.rank), n = 0; n < r.length; n++) {\n      r[n] = e.shape[t[n]];\n    }\n\n    var o = e.dataSync(),\n        a = buffer(r, e.dtype),\n        i = e.buffer();\n\n    for (n = 0; n < e.size; ++n) {\n      for (var s = i.indexToLoc(n), u = new Array(s.length), l = 0; l < u.length; l++) {\n        u[l] = s[t[l]];\n      }\n\n      var c = a.locToIndex(u);\n      a.values[c] = o[n];\n    }\n\n    return a.toTensor();\n  }, e.prototype.gather = function (e, t, r) {\n    this.assertNotComplex([e, t], \"gather\");\n    var n = e.shape.slice(),\n        o = t.dataSync();\n    n[r] = o.length;\n\n    for (var a = buffer(n, e.dtype), i = e.buffer(), s = 0; s < a.size; ++s) {\n      var u = a.indexToLoc(s),\n          l = u.slice();\n      l[r] = o[u[r]];\n      var c = i.locToIndex(l);\n      a.values[s] = i.values[c];\n    }\n\n    return a.toTensor();\n  }, e.prototype.batchToSpaceND = function (e, t, r) {\n    this.assertNotComplex([e], \"batchToSpaceND\");\n    var n = t.reduce(function (e, t) {\n      return e * t;\n    }),\n        o = getReshaped(e.shape, t, n),\n        a = getPermuted(o.length, t.length),\n        i = getReshapedPermuted(e.shape, t, n),\n        s = getSliceBeginCoords(r, t.length),\n        u = getSliceSize(i, r, t.length);\n    return e.reshape(o).transpose(a).reshape(i).slice(s, u);\n  }, e.prototype.spaceToBatchND = function (e, t, r) {\n    this.assertNotComplex([e], \"spaceToBatchND\");\n    var n = t.reduce(function (e, t) {\n      return e * t;\n    }),\n        o = [[0, 0]];\n    o.push.apply(o, r);\n\n    for (var a = 1 + t.length; a < e.shape.length; ++a) {\n      o.push([0, 0]);\n    }\n\n    var i = e.pad(o),\n        s = getReshaped(i.shape, t, n, !1),\n        u = getPermuted(s.length, t.length, !1),\n        l = getReshapedPermuted(i.shape, t, n, !1);\n    return i.reshape(s).transpose(u).reshape(l);\n  }, e.prototype.pool = function (e, t, r) {\n    this.assertNotComplex(e, \"pool\");\n\n    for (var n = t.strideHeight, o = t.strideWidth, a = t.dilationHeight, i = t.dilationWidth, s = t.effectiveFilterHeight, u = t.effectiveFilterWidth, l = t.padInfo.top, c = t.padInfo.left, p = \"max\" === r ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, d = e.dataSync(), h = buffer(t.outShape, e.dtype), f = h.values, m = t.outShape[1] * t.outShape[2] * t.outShape[3], g = t.outShape[2] * t.outShape[3], v = t.outShape[3], y = 0; y < t.batchSize; ++y) {\n      for (var x = y * m, T = y * e.strides[0], E = 0; E < t.inChannels; ++E) {\n        for (var w = 0; w < t.outHeight; ++w) {\n          for (var S = w * n - l, b = Math.max(0, S), C = Math.min(t.inHeight, s + S), A = x + w * g, _ = 0; _ < t.outWidth; ++_) {\n            for (var N = _ * o - c, R = Math.max(0, N), I = Math.min(t.inWidth, u + N), k = p, D = 0, M = 0, O = b; O < C; O += a) {\n              for (var P = T + O * e.strides[1], F = R; F < I; F += i) {\n                var L = d[P + F * e.strides[2] + E];\n                \"max\" === r && L > k ? k = L : \"avg\" === r && (D += L, M++);\n              }\n\n              if (isNaN(k)) break;\n            }\n\n            f[A + _ * v + E] = \"avg\" === r ? D / M : k;\n          }\n        }\n      }\n    }\n\n    return h.toTensor();\n  }, e.prototype.maxPool = function (e, t) {\n    return this.pool(e, t, \"max\");\n  }, e.prototype.maxPoolPositions = function (e, t) {\n    for (var r = buffer(t.outShape, \"int32\"), n = t.strideHeight, o = t.strideWidth, a = t.dilationHeight, i = t.dilationWidth, s = t.effectiveFilterHeight, u = t.effectiveFilterWidth, l = t.padInfo.top, c = t.padInfo.left, p = 0; p < t.batchSize; ++p) {\n      for (var d = 0; d < t.inChannels; ++d) {\n        for (var h = 0; h < t.outHeight; ++h) {\n          for (var f = h * n - l, m = f; m < 0;) {\n            m += a;\n          }\n\n          for (var g = Math.min(t.inHeight, s + f), v = 0; v < t.outWidth; ++v) {\n            for (var y = v * o - c, x = y; x < 0;) {\n              x += i;\n            }\n\n            for (var T = Math.min(t.inWidth, u + y), E = Number.NEGATIVE_INFINITY, w = -1, S = m; S < g; S += a) {\n              for (var b = S - f, C = x; C < T; C += i) {\n                var A = C - y,\n                    _ = e.get(p, S, C, d);\n\n                _ > E && (E = _, w = b * u + A);\n              }\n            }\n\n            r.set(w, p, h, v, d);\n          }\n        }\n      }\n    }\n\n    return r.toTensor();\n  }, e.prototype.maxPoolBackprop = function (e, t, r, n) {\n    this.assertNotComplex([t, r], \"maxPoolBackprop\");\n\n    for (var o = this.maxPoolPositions(t, n), a = n.strideHeight, i = n.strideWidth, s = n.dilationHeight, u = n.dilationWidth, l = n.effectiveFilterHeight, c = n.effectiveFilterWidth, p = c - 1 - n.padInfo.left, d = l - 1 - n.padInfo.top, h = buffer(t.shape, \"float32\"), f = 0; f < n.batchSize; ++f) {\n      for (var m = 0; m < n.inChannels; ++m) {\n        for (var g = 0; g < n.inHeight; ++g) {\n          for (var v = 0; v < n.inWidth; ++v) {\n            for (var y = g - d, x = v - p, T = 0, E = 0; E < l; E += s) {\n              var w = (y + E) / a;\n              if (!(w < 0 || w >= n.outHeight || Math.floor(w) !== w)) for (var S = 0; S < c; S += u) {\n                var b = (x + S) / i;\n\n                if (!(b < 0 || b >= n.outWidth || Math.floor(b) !== b)) {\n                  var C = l * c - 1 - o.get(f, w, b, m) === E * c + S ? 1 : 0;\n                  if (0 !== C) T += e.get(f, w, b, m) * C;\n                }\n              }\n            }\n\n            h.set(T, f, g, v, m);\n          }\n        }\n      }\n    }\n\n    return h.toTensor();\n  }, e.prototype.avgPoolBackprop = function (e, t, r) {\n    this.assertNotComplex([e, t], \"avgPoolBackprop\");\n\n    for (var n = r.strideHeight, o = r.strideWidth, a = r.filterHeight, i = r.filterWidth, s = r.dilationHeight, u = r.dilationWidth, l = r.effectiveFilterHeight, c = r.effectiveFilterWidth, p = c - 1 - r.padInfo.left, d = l - 1 - r.padInfo.top, h = buffer(t.shape, \"float32\"), f = 1 / (a * i), m = 0; m < r.batchSize; ++m) {\n      for (var g = 0; g < r.inChannels; ++g) {\n        for (var v = 0; v < r.inHeight; ++v) {\n          for (var y = 0; y < r.inWidth; ++y) {\n            for (var x = v - d, T = y - p, E = 0, w = 0; w < l; w += s) {\n              var S = (x + w) / n;\n              if (!(S < 0 || S >= r.outHeight || Math.floor(S) !== S)) for (var b = 0; b < c; b += u) {\n                var C = (T + b) / o;\n                if (!(C < 0 || C >= r.outWidth || Math.floor(C) !== C)) E += e.get(m, S, C, g);\n              }\n            }\n\n            h.set(E * f, m, v, y, g);\n          }\n        }\n      }\n    }\n\n    return h.toTensor();\n  }, e.prototype.cast = function (e, t) {\n    return castTensor(e, t, this);\n  }, e.prototype.reshape = function (e, t) {\n    return reshapeTensor(e, t);\n  }, e.prototype.avgPool = function (e, t) {\n    return this.assertNotComplex(e, \"avgPool\"), this.pool(e, t, \"avg\").toFloat();\n  }, e.prototype.resizeBilinear = function (e, t, r, n) {\n    this.assertNotComplex(e, \"resizeBilinear\");\n\n    for (var o = e.shape, a = o[0], i = o[1], s = o[2], u = o[3], l = e.dataSync(), c = new Float32Array(sizeFromShape([a, t, r, u])), p = [n && t > 1 ? i - 1 : i, n && r > 1 ? s - 1 : s], d = [n && t > 1 ? t - 1 : t, n && r > 1 ? r - 1 : r], h = 0, f = p[0] / d[0], m = p[1] / d[1], g = 0; g < a; g++) {\n      for (var v = 0; v < t; v++) {\n        for (var y = f * v, x = Math.floor(y), T = y - x, E = Math.min(i - 1, Math.ceil(y)), w = g * e.strides[0] + x * e.strides[1], S = g * e.strides[0] + E * e.strides[1], b = 0; b < r; b++) {\n          for (var C = m * b, A = Math.floor(C), _ = C - A, N = Math.min(s - 1, Math.ceil(C)), R = w + A * e.strides[2], I = S + A * e.strides[2], k = w + +N * e.strides[2], D = S + N * e.strides[2], M = 0; M < u; M++) {\n            var O = l[R + M],\n                P = l[I + M],\n                F = O + (l[k + M] - O) * _,\n                L = F + (P + (l[D + M] - P) * _ - F) * T;\n            c[h++] = L;\n          }\n        }\n      }\n    }\n\n    return tensor(c, [a, t, r, u]);\n  }, e.prototype.resizeBilinearBackprop = function (e, t, r) {\n    this.assertNotComplex([e, t], \"resizeBilinearBackprop\");\n\n    for (var n = t.shape, o = n[0], a = n[1], i = n[2], s = n[3], u = e.shape, l = u[1], c = u[2], p = new Float32Array(o * a * i * s), d = [r && l > 1 ? a - 1 : a, r && c > 1 ? i - 1 : i], h = [r && l > 1 ? l - 1 : l, r && c > 1 ? c - 1 : c], f = d[0] / h[0], m = d[1] / h[1], g = e.dataSync(), v = 0, y = 0; y < o; y++) {\n      for (var x = y * t.strides[0], T = 0; T < l; T++) {\n        for (var E = T * f, w = Math.floor(E), S = Math.min(Math.ceil(E), a - 1), b = x + w * t.strides[1], C = x + S * t.strides[1], A = E - w, _ = 1 - A, N = 0; N < c; N++) {\n          for (var R = N * m, I = Math.floor(R), k = Math.min(Math.ceil(R), i - 1), D = R - I, M = 1 - D, O = b + I * t.strides[2], P = b + k * t.strides[2], F = C + I * t.strides[2], L = C + k * t.strides[2], B = _ * M, U = _ * D, z = A * M, V = A * D, H = 0; H < s; H++) {\n            var G = g[v++];\n            p[O + H] += G * B, p[P + H] += G * U, p[F + H] += G * z, p[L + H] += G * V;\n          }\n        }\n      }\n    }\n\n    return tensor4d(p, [o, i, a, s], t.dtype);\n  }, e.prototype.resizeNearestNeighbor = function (e, t, r, n) {\n    this.assertNotComplex(e, \"resizeNearestNeighbor\");\n\n    for (var o = e.shape, a = o[0], i = o[1], s = o[2], u = o[3], l = e.dataSync(), c = new Float32Array(a * t * r * u), p = [n && t > 1 ? i - 1 : i, n && r > 1 ? s - 1 : s], d = [n && t > 1 ? t - 1 : t, n && r > 1 ? r - 1 : r], h = p[0] / d[0], f = p[1] / d[1], m = 0, g = 0; g < a; g++) {\n      for (var v = g * e.strides[0], y = 0; y < t; y++) {\n        for (var x = h * y, T = v + Math.min(i - 1, n ? Math.round(x) : Math.floor(x)) * e.strides[1], E = 0; E < r; E++) {\n          for (var w = f * E, S = T + Math.min(s - 1, n ? Math.round(w) : Math.floor(w)) * e.strides[2], b = 0; b < u; b++) {\n            var C = l[S + b];\n            c[m++] = C;\n          }\n        }\n      }\n    }\n\n    return tensor(c, [a, t, r, u], e.dtype);\n  }, e.prototype.resizeNearestNeighborBackprop = function (e, t, r) {\n    this.assertNotComplex([e, t], \"resizeNearestNeighborBackprop\");\n\n    for (var n = t.shape, o = n[0], a = n[1], i = n[2], s = n[3], u = e.shape, l = u[1], c = u[2], p = new Float32Array(o * a * i * s), d = e.dataSync(), h = [r && l > 1 ? a - 1 : a, r && c > 1 ? i - 1 : i], f = [r && l > 1 ? l - 1 : l, r && c > 1 ? c - 1 : c], m = h[0] / f[0], g = h[1] / f[1], v = 1 / m, y = 1 / g, x = 2 * Math.ceil(v) + 2, T = 2 * Math.ceil(y) + 2, E = 0; E < o; E++) {\n      for (var w = E * t.strides[0], S = 0; S < a; S++) {\n        for (var b = w + S * t.strides[1], C = Math.floor(S * v), A = Math.floor(C - x / 2), _ = 0; _ < i; _++) {\n          for (var N = b + _ * t.strides[2], R = Math.floor(_ * y), I = Math.floor(R - T / 2), k = 0; k < s; k++) {\n            for (var D = 0, M = 0; M < x; M++) {\n              var O = M + A;\n\n              if (!(O < 0 || O >= l)) {\n                var P = w + O * e.strides[1],\n                    F = O * m;\n                if (S === Math.min(a - 1, r ? Math.round(F) : Math.floor(F))) for (var L = 0; L < T; L++) {\n                  var B = L + I;\n\n                  if (!(B < 0 || B >= c)) {\n                    var U = P + B * e.strides[2],\n                        z = B * g;\n                    _ === Math.min(i - 1, r ? Math.round(z) : Math.floor(z)) && (D += d[U + k]);\n                  }\n                }\n              }\n            }\n\n            p[N + k] = D;\n          }\n        }\n      }\n    }\n\n    return tensor4d(p, t.shape, t.dtype);\n  }, e.prototype.batchNormalization = function (e, t, r, n, o, a) {\n    this.assertNotComplex([e, t, r, o, a], \"batchNormalization\");\n\n    for (var i = e.dataSync(), s = t.dataSync(), u = r.dataSync(), l = o ? o.dataSync() : new Float32Array([1]), c = a ? a.dataSync() : new Float32Array([0]), p = new Float32Array(i.length), d = c.length, h = l.length, f = u.length, m = s.length, g = 0, v = 0, y = 0, x = 0, T = 0; T < i.length; ++T) {\n      p[T] = c[g++] + (i[T] - s[v++]) * l[y++] / Math.sqrt(u[x++] + n), g >= d && (g = 0), v >= m && (v = 0), y >= h && (y = 0), x >= f && (x = 0);\n    }\n\n    return tensor4d(p, e.shape);\n  }, e.prototype.localResponseNormalization4D = function (e, t, r, n, o) {\n    this.assertNotComplex(e, \"localResponseNormalization4D\");\n    var a = e.shape[3],\n        i = a - 1,\n        s = e.dataSync(),\n        u = sizeFromShape(e.shape),\n        l = new Float32Array(u);\n\n    function c(e) {\n      for (var r = e % a, n = e - r + Math.max(0, r - t), o = e - r + Math.min(r + t, i), u = 0; n <= o; n++) {\n        var l = s[n];\n        u += l * l;\n      }\n\n      return u;\n    }\n\n    for (var p = 0; p < u; p++) {\n      var d = c(p),\n          h = s[p] * Math.pow(r + n * d, -o);\n      l[p] = h;\n    }\n\n    return tensor4d(l, e.shape);\n  }, e.prototype.LRNGrad = function (e, t, r, n, o, a, i) {\n    this.assertNotComplex(e, \"LRNGrad\");\n\n    for (var s = e.shape[3], u = e.dataSync(), l = t.dataSync(), c = r.dataSync(), p = new Float32Array(sizeFromShape(e.shape)), d = sizeFromShape(e.shape), h = 0; h < d; h++) {\n      for (var f = h % s, m = h - f + Math.max(0, f - n), g = h - f + Math.min(s, f + n + 1), v = 0, y = m; y < g; y++) {\n        v += Math.pow(l[y], 2);\n      }\n\n      v = a * v + o;\n\n      for (y = m; y < g; y++) {\n        var x = -2 * a * i * l[y] * c[h] / v;\n        h === y && (x += Math.pow(v, -i)), x *= u[h], p[y] += x;\n      }\n    }\n\n    return tensor4d(p, e.shape);\n  }, e.prototype.multinomial = function (e, t, r, n) {\n    this.assertNotComplex(e, \"multinomial\");\n\n    for (var o = t ? e : softmax(e), a = o.shape[0], i = o.shape[1], s = zeros([a, r], \"int32\"), u = s.dataSync(), l = o.dataSync(), c = 0; c < a; ++c) {\n      var p = c * i,\n          d = new Float32Array(i - 1);\n      d[0] = l[p];\n\n      for (var h = 1; h < d.length; ++h) {\n        d[h] = d[h - 1] + l[p + h];\n      }\n\n      for (var f = seedrandom_1(n.toString()), m = c * r, g = 0; g < r; ++g) {\n        var v = f();\n        u[m + g] = d.length;\n\n        for (var y = 0; y < d.length; y++) {\n          if (v < d[y]) {\n            u[m + g] = y;\n            break;\n          }\n        }\n      }\n    }\n\n    return s;\n  }, e.prototype.oneHot = function (e, t, r, n) {\n    this.assertNotComplex(e, \"oneHot\");\n    var o = new Float32Array(e.size * t);\n    o.fill(n);\n\n    for (var a = 0; a < e.size; ++a) {\n      e.get(a) >= 0 && e.get(a) < t && (o[a * t + e.get(a)] = r);\n    }\n\n    return tensor2d(o, [e.size, t], \"int32\");\n  }, e.prototype.nonMaxSuppression = function (e, t, r, n, o) {\n    return this.assertNotComplex(e, \"nonMaxSuppression\"), nonMaxSuppressionImpl(e.dataSync(), t.dataSync(), r, n, o);\n  }, e.prototype.fft = function (e) {\n    return this.fftBatch(e, !1);\n  }, e.prototype.ifft = function (e) {\n    return this.fftBatch(e, !0);\n  }, e.prototype.fftBatch = function (e, t) {\n    for (var r = e.shape[0], n = e.shape[1], o = buffer(e.shape, \"float32\"), a = buffer(e.shape, \"float32\"), i = real(e).as2D(r, n), s = imag(e).as2D(r, n), u = 0; u < r; u++) {\n      for (var l = i.slice([u, 0], [1, n]), c = s.slice([u, 0], [1, n]), p = complex(l, c), d = this.fftImpl(p, t).dataSync(), h = 0; h < n; h++) {\n        var f = getComplexWithIndex(d, h);\n        o.values[u * n + h] = f.real, a.values[u * n + h] = f.imag;\n      }\n    }\n\n    return complex(o.toTensor(), a.toTensor()).as2D(r, n);\n  }, e.prototype.fftImpl = function (e, t) {\n    var r = e.as1D(),\n        n = r.size;\n\n    if (this.isExponentOf2(n)) {\n      var o = this.fftRadix2(r, n, t).as2D(e.shape[0], e.shape[1]);\n      return t && (o = complex(real(o).div(scalar(n)), imag(o).div(scalar(n)))), o;\n    }\n\n    var a = e.dataSync(),\n        i = splitRealAndImagArrays(this.fourierTransformByMatmul(a, n, t));\n    return complex(i.real, i.imag).as2D(e.shape[0], e.shape[1]);\n  }, e.prototype.isExponentOf2 = function (e) {\n    return 0 == (e & e - 1);\n  }, e.prototype.fftRadix2 = function (e, t, r) {\n    if (1 === t) return e;\n    var n = e.dataSync(),\n        o = t / 2,\n        a = complexWithEvenIndex(n),\n        i = complex(a.real, a.imag).as1D(),\n        s = complexWithOddIndex(n),\n        u = complex(s.real, s.imag).as1D();\n    i = this.fftRadix2(i, o, r), u = this.fftRadix2(u, o, r);\n    var l = exponents(t, r),\n        c = complex(l.real, l.imag).mul(u),\n        p = i.add(c),\n        d = i.sub(c),\n        h = real(p).concat(real(d)),\n        f = imag(p).concat(imag(d));\n    return complex(h, f).as1D();\n  }, e.prototype.fourierTransformByMatmul = function (e, t, r) {\n    for (var n = new Float32Array(2 * t), o = 0; o < t; o++) {\n      for (var a = 0, i = 0, s = 0; s < t; s++) {\n        var u = exponent(o * s, t, r),\n            l = getComplexWithIndex(e, s);\n        a += l.real * u.real - l.imag * u.imag, i += l.real * u.imag + l.imag * u.real;\n      }\n\n      r && (a /= t, i /= t), assignToTypedArray(n, a, i, o);\n    }\n\n    return n;\n  }, e.prototype.depthToSpace = function (e, t, r) {\n    assert(\"NHWC\" === r, \"Only NHWC dataFormat supported on CPU for depthToSpace. Got \" + r), assert(t > 1, \"blockSize should be > 1 for depthToSpace, but was: \" + t);\n\n    for (var n = e.shape[0], o = e.shape[1], a = e.shape[2], i = e.shape[3], s = o * t, u = a * t, l = i / (t * t), c = e.dataSync(), p = new Float32Array(n * s * u * l), d = 0, h = 0; h < n; ++h) {\n      for (var f = 0; f < s; ++f) {\n        for (var m = Math.floor(f / t), g = f % t, v = 0; v < u; ++v) {\n          for (var y = Math.floor(v / t), x = (g * t + v % t) * l, T = 0; T < l; ++T) {\n            var E = T + x + i * (y + a * (m + o * h));\n            p[d++] = c[E];\n          }\n        }\n      }\n    }\n\n    return tensor4d(p, [n, s, u, l]);\n  }, e.prototype.broadcastedBinaryOp = function (e, t, r, n) {\n    var o = assertAndGetBroadcastShape(e.shape, t.shape),\n        a = buffer(o, r),\n        i = e.dataSync(),\n        s = t.dataSync(),\n        u = getBroadcastDims(e.shape, o),\n        l = getBroadcastDims(t.shape, o),\n        c = a.values;\n    if (u.length + l.length === 0) for (var p = 0; p < c.length; ++p) {\n      c[p] = n(i[p % i.length], s[p % s.length]);\n    } else {\n      var d = e.buffer(),\n          h = t.buffer(),\n          f = function f(r) {\n        var o = a.indexToLoc(r),\n            p = o.slice(-e.rank);\n        u.forEach(function (e) {\n          return p[e] = 0;\n        });\n        var f = d.locToIndex(p),\n            m = o.slice(-t.rank);\n        l.forEach(function (e) {\n          return m[e] = 0;\n        });\n        var g = h.locToIndex(m);\n        c[r] = n(i[f], s[g]);\n      };\n\n      for (p = 0; p < c.length; ++p) {\n        f(p);\n      }\n    }\n    return a.toTensor();\n  }, e.prototype.broadcastedBinaryComplexOp = function (e, t, r) {\n    var n = assertAndGetBroadcastShape(e.shape, t.shape),\n        o = buffer(n, \"float32\"),\n        a = buffer(n, \"float32\"),\n        i = e.dataSync(),\n        s = t.dataSync(),\n        u = getBroadcastDims(e.shape, n),\n        l = getBroadcastDims(t.shape, n),\n        c = o.values,\n        p = a.values;\n    if (u.length + l.length === 0) for (var d = 0; d < c.length; d++) {\n      var h = d % i.length,\n          f = d % s.length,\n          m = r(i[2 * h], i[2 * h + 1], s[2 * f], s[2 * f + 1]);\n      c[d] = m.real, p[d] = m.imag;\n    } else {\n      var g = this.data.get(e.dataId).complexTensors.real.buffer(),\n          v = this.data.get(t.dataId).complexTensors.real.buffer(),\n          y = function y(n) {\n        var a = o.indexToLoc(n),\n            d = a.slice(-e.rank);\n        u.forEach(function (e) {\n          return d[e] = 0;\n        });\n        var h = g.locToIndex(d),\n            f = a.slice(-t.rank);\n        l.forEach(function (e) {\n          return f[e] = 0;\n        });\n        var m = v.locToIndex(f),\n            y = r(i[2 * h], i[2 * h + 1], s[2 * m], s[2 * m + 1]);\n        c[n] = y.real, p[n] = y.imag;\n      };\n\n      for (d = 0; d < c.length; d++) {\n        y(d);\n      }\n    }\n    return this.complex(o.toTensor(), a.toTensor());\n  }, e.prototype.split = function (e, t, r) {\n    return split(e, t, r);\n  }, e.prototype.dispose = function () {}, e.prototype.floatPrecision = function () {\n    return 32;\n  }, e.prototype.cropAndResize = function (e, t, r, n, o, a) {\n    for (var i = e.shape, s = i[0], u = i[1], l = i[2], c = i[3], p = t.shape[0], d = n[0], h = n[1], f = buffer([p, d, h, c], e.dtype), m = t.dataSync(), g = r.dataSync(), v = e.dataSync(), y = e.strides, x = f.strides, T = 0; T < p; T++) {\n      var E = 4 * T,\n          w = m[E],\n          S = m[E + 1],\n          b = m[E + 2],\n          C = m[E + 3],\n          A = g[T];\n      if (!(A >= s)) for (var _ = d > 1 ? (b - w) * (u - 1) / (d - 1) : 0, N = h > 1 ? (C - S) * (l - 1) / (h - 1) : 0, R = 0; R < d; R++) {\n        var I = d > 1 ? w * (u - 1) + R * _ : .5 * (w + b) * (u - 1);\n        if (I < 0 || I > u - 1) for (var k = 0; k < h; k++) {\n          for (var D = 0; D < c; D++) {\n            var M = D + k * x[2] + R * x[1] + T * x[0];\n            f.values[M] = a;\n          }\n        } else if (\"bilinear\" === o) {\n          var O = Math.floor(I),\n              P = Math.ceil(I),\n              F = I - O;\n\n          for (k = 0; k < h; k++) {\n            if ((q = h > 1 ? S * (l - 1) + k * N : .5 * (S + C) * (l - 1)) < 0 || q > l - 1) for (D = 0; D < c; D++) {\n              M = D + k * x[2] + R * x[1] + T * x[0];\n              f.values[M] = a;\n            } else {\n              var L = Math.floor(q),\n                  B = Math.ceil(q),\n                  U = q - L;\n\n              for (D = 0; D < c; D++) {\n                var z = v[M = D + L * y[2] + O * y[1] + A * y[0]],\n                    V = v[M = D + B * y[2] + O * y[1] + A * y[0]],\n                    H = v[M = D + L * y[2] + P * y[1] + A * y[0]],\n                    G = z + (V - z) * U,\n                    W = H + (v[M = D + B * y[2] + P * y[1] + A * y[0]] - H) * U;\n                M = D + k * x[2] + R * x[1] + T * x[0], f.values[M] = G + (W - G) * F;\n              }\n            }\n          }\n        } else for (k = 0; k < h; ++k) {\n          var q;\n          if ((q = h > 1 ? S * (l - 1) + k * N : .5 * (S + C) * (l - 1)) < 0 || q > l - 1) for (D = 0; D < c; D++) {\n            M = D + k * x[2] + R * x[1] + T * x[0];\n            f.values[M] = a;\n          } else {\n            var $ = Math.round(q),\n                X = Math.round(I);\n\n            for (D = 0; D < c; D++) {\n              var K = D + $ * y[2] + X * y[1] + A * y[0],\n                  j = D + k * x[2] + R * x[1] + T * x[0];\n              f.values[j] = v[K];\n            }\n          }\n        }\n      }\n    }\n\n    return f.toTensor();\n  }, e.prototype.sparseToDense = function (e, t, r, n) {\n    var o = calculateShapes(t, e, r),\n        a = o.sliceRank,\n        i = o.numUpdates,\n        s = o.sliceSize,\n        u = o.strides,\n        l = o.outputSize;\n    return this.scatter(e, t, r, l, s, i, a, u, n, !1);\n  }, e.prototype.gatherND = function (e, t) {\n    var r = t.shape,\n        n = r[r.length - 1],\n        o = prepareAndValidate(e, t),\n        a = o[0],\n        i = o[1],\n        s = o[2],\n        u = o[3];\n    if (0 === i) return tensor([], a, e.dtype);\n\n    for (var l = new TensorBuffer([i, s], e.dtype), c = t.dataSync(), p = e.dataSync(), d = 0; d < i; d++) {\n      for (var h = [], f = 0, m = 0; m < n; m++) {\n        var g = c[d * n + m];\n        f += g * u[m], h.push(g);\n      }\n\n      if (f < 0 || f >= e.size / s) throw new Error(\"Invalid indices: \" + h + \" does not index into \" + e.shape);\n\n      for (var v = 0; v < s; v++) {\n        l.values[d * s + v] = p[f * s + v];\n      }\n    }\n\n    return l.toTensor().reshape(a);\n  }, e.prototype.scatterND = function (e, t, r) {\n    var n = calculateShapes(t, e, r),\n        o = n.sliceRank,\n        a = n.numUpdates,\n        i = n.sliceSize,\n        s = n.strides,\n        u = n.outputSize,\n        l = scalar(0);\n    return this.scatter(e, t, r, u, i, a, o, s, l, !0);\n  }, e.prototype.scatter = function (e, t, r, n, o, a, i, s, u, l) {\n    var c = [n / o, o],\n        p = e.dataSync(),\n        d = t.dataSync();\n    if (0 === n) return tensor([], r, t.dtype);\n    var h = new TensorBuffer(c, t.dtype);\n    h.values.fill(u.dataSync()[0]);\n\n    for (var f = 0; f < a; f++) {\n      for (var m = [], g = 0, v = 0; v < i; v++) {\n        var y = p[f * i + v];\n        m.push(y), g += y * s[v];\n      }\n\n      if (g < 0 || g >= n / o) throw new Error(\"Invalid indices: \" + m + \" does not index into \" + r);\n\n      for (var x = 0; x < o; x++) {\n        l ? h.values[g * o + x] += d[f * o + x] : h.values[g * o + x] = 0 === t.rank ? d[0] : d[f * o + x];\n      }\n    }\n\n    return h.toTensor().reshape(r);\n  }, e;\n}();\n\nENV.registerBackend(\"cpu\", function () {\n  return new MathBackendCPU();\n}, 1, setTensorTracker);\nvar delayCallback = \"undefined\" != typeof requestAnimationFrame ? requestAnimationFrame : setImmediate;\n\nfunction nextFrame() {\n  return new Promise(function (e) {\n    return delayCallback(function () {\n      return e();\n    });\n  });\n}\n\nvar DTYPE_VALUE_SIZE_MAP = {\n  float32: 4,\n  int32: 4,\n  uint16: 2,\n  uint8: 1,\n  bool: 1\n};\n\nfunction encodeWeights(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    var t, r, n, o;\n    return __generator(this, function (a) {\n      switch (a.label) {\n        case 0:\n          for (n in t = [], r = [], e) {\n            if (\"float32\" !== (o = e[n]).dtype && \"int32\" !== o.dtype && \"bool\" !== o.dtype) throw new Error(\"Unsupported dtype in weight '\" + n + \"': \" + o.dtype);\n            t.push({\n              name: n,\n              shape: o.shape,\n              dtype: o.dtype\n            }), r.push(o.data());\n          }\n\n          return [4, Promise.all(r)];\n\n        case 1:\n          return [2, {\n            data: concatenateTypedArrays(a.sent()),\n            specs: t\n          }];\n      }\n    });\n  });\n}\n\nfunction decodeWeights(e, t) {\n  for (var r = {}, n = 0, o = function o(t) {\n    var o = t.name,\n        a = t.dtype,\n        i = t.shape,\n        s = sizeFromShape(i),\n        u = void 0;\n\n    if ((\"quantization\" in t)) {\n      var l = t.quantization;\n      if (\"uint8\" !== l.dtype && \"uint16\" !== l.dtype) throw new Error(\"Weight \" + t.name + \" has unknown quantization dtype \" + l.dtype + \". Supported quantization dtypes are: 'uint8' and 'uint16'.\");\n      var c = DTYPE_VALUE_SIZE_MAP[l.dtype],\n          p = e.slice(n, n + s * c),\n          d = \"uint8\" === l.dtype ? new Uint8Array(p) : new Uint16Array(p);\n      if (\"float32\" === a) u = Float32Array.from(d, function (e) {\n        return e * l.scale + l.min;\n      });else {\n        if (\"int32\" !== a) throw new Error(\"Unsupported dtype in weight '\" + o + \"': \" + a);\n        u = Int32Array.from(d, function (e) {\n          return Math.round(e * l.scale + l.min);\n        });\n      }\n      n += s * c;\n    } else {\n      var h = DTYPE_VALUE_SIZE_MAP[a];\n      p = e.slice(n, n + s * h);\n      if (\"float32\" === a) u = new Float32Array(p);else if (\"int32\" === a) u = new Int32Array(p);else {\n        if (\"bool\" !== a) throw new Error(\"Unsupported dtype in weight '\" + o + \"': \" + a);\n        u = new Uint8Array(p);\n      }\n      n += s * h;\n    }\n\n    var f = void 0;\n    if (\"float32\" === a) f = tensor(u, i, \"float32\");else if (\"int32\" === a) f = tensor(u, i, \"int32\");else {\n      if (\"bool\" !== a) throw new Error(\"Unsupported dtype in weight '\" + o + \"': \" + a);\n      f = tensor(u, i, \"bool\");\n    }\n    r[o] = f;\n  }, a = 0, i = t; a < i.length; a++) {\n    o(i[a]);\n  }\n\n  return r;\n}\n\nfunction concatenateTypedArrays(e) {\n  if (null === e) throw new Error(\"Invalid input value: \" + JSON.stringify(e));\n  var t = 0,\n      r = [];\n  e.forEach(function (e) {\n    if (t += e.byteLength, r.push(e.byteLength === e.buffer.byteLength ? e : new e.constructor(e)), !(e instanceof Float32Array || e instanceof Int32Array || e instanceof Uint8Array)) throw new Error(\"Unsupported TypedArray subtype: \" + e.constructor.name);\n  });\n  var n = new Uint8Array(t),\n      o = 0;\n  return r.forEach(function (e) {\n    n.set(new Uint8Array(e.buffer), o), o += e.byteLength;\n  }), n.buffer;\n}\n\nvar useNodeBuffer = \"undefined\" != typeof Buffer && (\"undefined\" == typeof Blob || \"undefined\" == typeof atob || \"undefined\" == typeof btoa);\n\nfunction stringByteLength(e) {\n  return useNodeBuffer ? Buffer.byteLength(e) : new Blob([e]).size;\n}\n\nfunction arrayBufferToBase64String(e) {\n  return useNodeBuffer ? Buffer.from(e).toString(\"base64\") : btoa(String.fromCharCode.apply(null, new Uint8Array(e)));\n}\n\nfunction base64StringToArrayBuffer(e) {\n  if (useNodeBuffer) {\n    var t = Buffer.from(e, \"base64\");\n    return t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength);\n  }\n\n  for (var r = atob(e), n = new Uint8Array(r.length), o = 0; o < r.length; ++o) {\n    n.set([r.charCodeAt(o)], o);\n  }\n\n  return n.buffer;\n}\n\nfunction concatenateArrayBuffers(e) {\n  var t = 0;\n  e.forEach(function (e) {\n    t += e.byteLength;\n  });\n  var r = new Uint8Array(t),\n      n = 0;\n  return e.forEach(function (e) {\n    r.set(new Uint8Array(e), n), n += e.byteLength;\n  }), r.buffer;\n}\n\nfunction basename(e) {\n  for (e = e.trim(); e.endsWith(\"/\");) {\n    e = e.slice(0, e.length - 1);\n  }\n\n  var t = e.split(\"/\");\n  return t[t.length - 1];\n}\n\nfunction getModelArtifactsInfoForJSON(e) {\n  if (e.modelTopology instanceof ArrayBuffer) throw new Error(\"Expected JSON model topology, received ArrayBuffer.\");\n  return {\n    dateSaved: new Date(),\n    modelTopologyType: \"JSON\",\n    modelTopologyBytes: null == e.modelTopology ? 0 : stringByteLength(JSON.stringify(e.modelTopology)),\n    weightSpecsBytes: null == e.weightSpecs ? 0 : stringByteLength(JSON.stringify(e.weightSpecs)),\n    weightDataBytes: null == e.weightData ? 0 : e.weightData.byteLength\n  };\n}\n\nvar IORouterRegistry = function () {\n  function e() {\n    this.saveRouters = [], this.loadRouters = [];\n  }\n\n  return e.getInstance = function () {\n    return null == e.instance && (e.instance = new e()), e.instance;\n  }, e.registerSaveRouter = function (t) {\n    e.getInstance().saveRouters.push(t);\n  }, e.registerLoadRouter = function (t) {\n    e.getInstance().loadRouters.push(t);\n  }, e.getSaveHandlers = function (t) {\n    return e.getHandlers(t, \"save\");\n  }, e.getLoadHandlers = function (t) {\n    return e.getHandlers(t, \"load\");\n  }, e.getHandlers = function (e, t) {\n    var r = [];\n    return (\"load\" === t ? this.getInstance().loadRouters : this.getInstance().saveRouters).forEach(function (t) {\n      var n = t(e);\n      null !== n && r.push(n);\n    }), r;\n  }, e;\n}(),\n    URL_SCHEME_SUFFIX = \"://\",\n    ModelStoreManagerRegistry = function () {\n  function e() {\n    this.managers = {};\n  }\n\n  return e.getInstance = function () {\n    return null == e.instance && (e.instance = new e()), e.instance;\n  }, e.registerManager = function (t, r) {\n    assert(null != t, \"scheme must not be undefined or null.\"), t.endsWith(URL_SCHEME_SUFFIX) && (t = t.slice(0, t.indexOf(URL_SCHEME_SUFFIX))), assert(t.length > 0, \"scheme must not be an empty string.\");\n    var n = e.getInstance();\n    assert(null == n.managers[t], \"A model store manager is already registered for scheme '\" + t + \"'.\"), n.managers[t] = r;\n  }, e.getManager = function (e) {\n    var t = this.getInstance().managers[e];\n    if (null == t) throw new Error(\"Cannot find model manager for scheme '\" + e + \"'\");\n    return t;\n  }, e.getSchemes = function () {\n    return Object.keys(this.getInstance().managers);\n  }, e;\n}();\n\nfunction parseURL(e) {\n  if (-1 === e.indexOf(URL_SCHEME_SUFFIX)) throw new Error(\"The url string provided does not contain a scheme. Supported schemes are: \" + ModelStoreManagerRegistry.getSchemes().join(\",\"));\n  return {\n    scheme: e.split(URL_SCHEME_SUFFIX)[0],\n    path: e.split(URL_SCHEME_SUFFIX)[1]\n  };\n}\n\nfunction cloneModelInternal(e, t, r) {\n  return void 0 === r && (r = !1), __awaiter(this, void 0, void 0, function () {\n    var n, o, a, i, s, u, l, c, p;\n    return __generator(this, function (d) {\n      switch (d.label) {\n        case 0:\n          return assert(e !== t, \"Old path and new path are the same: '\" + e + \"'\"), assert((n = IORouterRegistry.getLoadHandlers(e)).length > 0, \"Copying failed because no load handler is found for source URL \" + e + \".\"), assert(n.length < 2, \"Copying failed because more than one (\" + n.length + \") load handlers for source URL \" + e + \".\"), o = n[0], assert((a = IORouterRegistry.getSaveHandlers(t)).length > 0, \"Copying failed because no save handler is found for destination URL \" + t + \".\"), assert(a.length < 2, \"Copying failed because more than one (\" + n.length + \") save handlers for destination URL \" + t + \".\"), i = a[0], s = parseURL(e).scheme, u = parseURL(e).path, l = s === parseURL(e).scheme, [4, o.load()];\n\n        case 1:\n          return c = d.sent(), r && l ? [4, ModelStoreManagerRegistry.getManager(s).removeModel(u)] : [3, 3];\n\n        case 2:\n          d.sent(), d.label = 3;\n\n        case 3:\n          return [4, i.save(c)];\n\n        case 4:\n          return p = d.sent(), !r || l ? [3, 6] : [4, ModelStoreManagerRegistry.getManager(s).removeModel(u)];\n\n        case 5:\n          d.sent(), d.label = 6;\n\n        case 6:\n          return [2, p.modelArtifactsInfo];\n      }\n    });\n  });\n}\n\nfunction listModels() {\n  return __awaiter(this, void 0, void 0, function () {\n    var e, t, r, n, o, a, i;\n    return __generator(this, function (s) {\n      switch (s.label) {\n        case 0:\n          e = ModelStoreManagerRegistry.getSchemes(), t = {}, r = 0, n = e, s.label = 1;\n\n        case 1:\n          return r < n.length ? (o = n[r], [4, ModelStoreManagerRegistry.getManager(o).listModels()]) : [3, 4];\n\n        case 2:\n          for (i in a = s.sent()) {\n            t[o + URL_SCHEME_SUFFIX + i] = a[i];\n          }\n\n          s.label = 3;\n\n        case 3:\n          return r++, [3, 1];\n\n        case 4:\n          return [2, t];\n      }\n    });\n  });\n}\n\nfunction removeModel(e) {\n  return __awaiter(this, void 0, void 0, function () {\n    var t;\n    return __generator(this, function (r) {\n      switch (r.label) {\n        case 0:\n          return t = parseURL(e), [4, ModelStoreManagerRegistry.getManager(t.scheme).removeModel(t.path)];\n\n        case 1:\n          return [2, r.sent()];\n      }\n    });\n  });\n}\n\nfunction copyModel(e, t) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (r) {\n      switch (r.label) {\n        case 0:\n          return [4, cloneModelInternal(e, t, !1)];\n\n        case 1:\n          return [2, r.sent()];\n      }\n    });\n  });\n}\n\nfunction moveModel(e, t) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (r) {\n      switch (r.label) {\n        case 0:\n          return [4, cloneModelInternal(e, t, !0)];\n\n        case 1:\n          return [2, r.sent()];\n      }\n    });\n  });\n}\n\nvar DATABASE_NAME = \"tensorflowjs\",\n    DATABASE_VERSION = 1,\n    MODEL_STORE_NAME = \"models_store\",\n    INFO_STORE_NAME = \"model_info_store\";\n\nfunction getIndexedDBFactory() {\n  if (!ENV.get(\"IS_BROWSER\")) throw new Error(\"Failed to obtain IndexedDB factory because the current environmentis not a web browser.\");\n  var e = window,\n      t = e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB || e.shimIndexedDB;\n  if (null == t) throw new Error(\"The current browser does not appear to support IndexedDB.\");\n  return t;\n}\n\nfunction setUpDatabase(e) {\n  var t = e.result;\n  t.createObjectStore(MODEL_STORE_NAME, {\n    keyPath: \"modelPath\"\n  }), t.createObjectStore(INFO_STORE_NAME, {\n    keyPath: \"modelPath\"\n  });\n}\n\nvar BrowserIndexedDB = function () {\n  function e(e) {\n    if (this.indexedDB = getIndexedDBFactory(), null == e || !e) throw new Error(\"For IndexedDB, modelPath must not be null, undefined or empty.\");\n    this.modelPath = e;\n  }\n\n  return e.prototype.save = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (t) {\n        if (e.modelTopology instanceof ArrayBuffer) throw new Error(\"BrowserLocalStorage.save() does not support saving model topology in binary formats yet.\");\n        return [2, this.databaseAction(this.modelPath, e)];\n      });\n    });\n  }, e.prototype.load = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (e) {\n        return [2, this.databaseAction(this.modelPath)];\n      });\n    });\n  }, e.prototype.databaseAction = function (e, t) {\n    var r = this;\n    return new Promise(function (e, n) {\n      var o = r.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n      o.onupgradeneeded = function () {\n        return setUpDatabase(o);\n      }, o.onsuccess = function () {\n        var a = o.result;\n\n        if (null == t) {\n          var i = a.transaction(MODEL_STORE_NAME, \"readonly\"),\n              s = i.objectStore(MODEL_STORE_NAME).get(r.modelPath);\n          s.onsuccess = function () {\n            if (null == s.result) return a.close(), n(new Error(\"Cannot find model with path '\" + r.modelPath + \"' in IndexedDB.\"));\n            e(s.result.modelArtifacts);\n          }, s.onerror = function (e) {\n            return a.close(), n(s.error);\n          }, i.oncomplete = function () {\n            return a.close();\n          };\n        } else {\n          var u,\n              l = getModelArtifactsInfoForJSON(t),\n              c = a.transaction(INFO_STORE_NAME, \"readwrite\"),\n              p = c.objectStore(INFO_STORE_NAME),\n              d = p.put({\n            modelPath: r.modelPath,\n            modelArtifactsInfo: l\n          });\n          d.onsuccess = function () {\n            var o = (u = a.transaction(MODEL_STORE_NAME, \"readwrite\")).objectStore(MODEL_STORE_NAME).put({\n              modelPath: r.modelPath,\n              modelArtifacts: t,\n              modelArtifactsInfo: l\n            });\n            o.onsuccess = function () {\n              return e({\n                modelArtifactsInfo: l\n              });\n            }, o.onerror = function (e) {\n              var t = (p = c.objectStore(INFO_STORE_NAME)).delete(r.modelPath);\n              t.onsuccess = function () {\n                return a.close(), n(o.error);\n              }, t.onerror = function (e) {\n                return a.close(), n(o.error);\n              };\n            };\n          }, d.onerror = function (e) {\n            return a.close(), n(d.error);\n          }, c.oncomplete = function () {\n            null == u ? a.close() : u.oncomplete = function () {\n              return a.close();\n            };\n          };\n        }\n      }, o.onerror = function (e) {\n        return n(o.error);\n      };\n    });\n  }, e.URL_SCHEME = \"indexeddb://\", e;\n}(),\n    indexedDBRouter = function indexedDBRouter(e) {\n  return ENV.get(\"IS_BROWSER\") && !Array.isArray(e) && e.startsWith(BrowserIndexedDB.URL_SCHEME) ? browserIndexedDB(e.slice(BrowserIndexedDB.URL_SCHEME.length)) : null;\n};\n\nfunction browserIndexedDB(e) {\n  return new BrowserIndexedDB(e);\n}\n\nfunction maybeStripScheme(e) {\n  return e.startsWith(BrowserIndexedDB.URL_SCHEME) ? e.slice(BrowserIndexedDB.URL_SCHEME.length) : e;\n}\n\nIORouterRegistry.registerSaveRouter(indexedDBRouter), IORouterRegistry.registerLoadRouter(indexedDBRouter);\n\nvar BrowserIndexedDBManager = function () {\n  function e() {\n    this.indexedDB = getIndexedDBFactory();\n  }\n\n  return e.prototype.listModels = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e = this;\n      return __generator(this, function (t) {\n        return [2, new Promise(function (t, r) {\n          var n = e.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n          n.onupgradeneeded = function () {\n            return setUpDatabase(n);\n          }, n.onsuccess = function () {\n            var e = n.result,\n                o = e.transaction(INFO_STORE_NAME, \"readonly\"),\n                a = o.objectStore(INFO_STORE_NAME).getAll();\n            a.onsuccess = function () {\n              for (var e = {}, r = 0, n = a.result; r < n.length; r++) {\n                var o = n[r];\n                e[o.modelPath] = o.modelArtifactsInfo;\n              }\n\n              t(e);\n            }, a.onerror = function (t) {\n              return e.close(), r(a.error);\n            }, o.oncomplete = function () {\n              return e.close();\n            };\n          }, n.onerror = function (e) {\n            return r(n.error);\n          };\n        })];\n      });\n    });\n  }, e.prototype.removeModel = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t = this;\n      return __generator(this, function (r) {\n        return e = maybeStripScheme(e), [2, new Promise(function (r, n) {\n          var o = t.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n          o.onupgradeneeded = function () {\n            return setUpDatabase(o);\n          }, o.onsuccess = function () {\n            var t,\n                a = o.result,\n                i = a.transaction(INFO_STORE_NAME, \"readwrite\"),\n                s = i.objectStore(INFO_STORE_NAME),\n                u = s.get(e);\n            u.onsuccess = function () {\n              if (null == u.result) return a.close(), n(new Error(\"Cannot find model with path '\" + e + \"' in IndexedDB.\"));\n\n              var o = s.delete(e),\n                  i = function i() {\n                var o = (t = a.transaction(MODEL_STORE_NAME, \"readwrite\")).objectStore(MODEL_STORE_NAME).delete(e);\n                o.onsuccess = function () {\n                  return r(u.result.modelArtifactsInfo);\n                }, o.onerror = function (e) {\n                  return n(u.error);\n                };\n              };\n\n              o.onsuccess = i, o.onerror = function (e) {\n                return i(), a.close(), n(u.error);\n              };\n            }, u.onerror = function (e) {\n              return a.close(), n(u.error);\n            }, i.oncomplete = function () {\n              null == t ? a.close() : t.oncomplete = function () {\n                return a.close();\n              };\n            };\n          }, o.onerror = function (e) {\n            return n(o.error);\n          };\n        })];\n      });\n    });\n  }, e;\n}();\n\nif (ENV.get(\"IS_BROWSER\")) try {\n  ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME, new BrowserIndexedDBManager());\n} catch (e) {}\nvar PATH_SEPARATOR = \"/\",\n    PATH_PREFIX = \"tensorflowjs_models\",\n    INFO_SUFFIX = \"info\",\n    MODEL_TOPOLOGY_SUFFIX = \"model_topology\",\n    WEIGHT_SPECS_SUFFIX = \"weight_specs\",\n    WEIGHT_DATA_SUFFIX = \"weight_data\";\n\nfunction getModelKeys(e) {\n  return {\n    info: [PATH_PREFIX, e, INFO_SUFFIX].join(PATH_SEPARATOR),\n    topology: [PATH_PREFIX, e, MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),\n    weightSpecs: [PATH_PREFIX, e, WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),\n    weightData: [PATH_PREFIX, e, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR)\n  };\n}\n\nfunction getModelPathFromKey(e) {\n  var t = e.split(PATH_SEPARATOR);\n  if (t.length < 3) throw new Error(\"Invalid key format: \" + e);\n  return t.slice(1, t.length - 1).join(PATH_SEPARATOR);\n}\n\nfunction maybeStripScheme$1(e) {\n  return e.startsWith(BrowserLocalStorage.URL_SCHEME) ? e.slice(BrowserLocalStorage.URL_SCHEME.length) : e;\n}\n\nvar BrowserLocalStorage = function () {\n  function e(e) {\n    if (!ENV.get(\"IS_BROWSER\") || void 0 === window.localStorage) throw new Error(\"The current environment does not support local storage.\");\n    if (this.LS = window.localStorage, null == e || !e) throw new Error(\"For local storage, modelPath must not be null, undefined or empty.\");\n    this.modelPath = e, this.keys = getModelKeys(this.modelPath);\n  }\n\n  return e.prototype.save = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t, r, n, o;\n      return __generator(this, function (a) {\n        if (e.modelTopology instanceof ArrayBuffer) throw new Error(\"BrowserLocalStorage.save() does not support saving model topology in binary formats yet.\");\n        t = JSON.stringify(e.modelTopology), r = JSON.stringify(e.weightSpecs), n = getModelArtifactsInfoForJSON(e);\n\n        try {\n          return this.LS.setItem(this.keys.info, JSON.stringify(n)), this.LS.setItem(this.keys.topology, t), this.LS.setItem(this.keys.weightSpecs, r), this.LS.setItem(this.keys.weightData, arrayBufferToBase64String(e.weightData)), [2, {\n            modelArtifactsInfo: n\n          }];\n        } catch (e) {\n          for (o in this.keys) {\n            this.LS.removeItem(this.keys[o]);\n          }\n\n          throw new Error(\"Failed to save model '\" + this.modelPath + \"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=\" + n.modelTopologyBytes + \", weightSpecsBytes=\" + n.weightSpecsBytes + \", weightDataBytes=\" + n.weightDataBytes + \".\");\n        }\n\n        return [2];\n      });\n    });\n  }, e.prototype.load = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e, t, r, n, o;\n      return __generator(this, function (a) {\n        if (null == (e = JSON.parse(this.LS.getItem(this.keys.info)))) throw new Error(\"In local storage, there is no model with name '\" + this.modelPath + \"'\");\n        if (\"JSON\" !== e.modelTopologyType) throw new Error(\"BrowserLocalStorage does not support loading non-JSON model topology yet.\");\n        if (t = {}, null == (r = JSON.parse(this.LS.getItem(this.keys.topology)))) throw new Error(\"In local storage, the topology of model '\" + this.modelPath + \"' is missing.\");\n        if (t.modelTopology = r, null == (n = JSON.parse(this.LS.getItem(this.keys.weightSpecs)))) throw new Error(\"In local storage, the weight specs of model '\" + this.modelPath + \"' are missing.\");\n        if (t.weightSpecs = n, null == (o = this.LS.getItem(this.keys.weightData))) throw new Error(\"In local storage, the binary weight values of model '\" + this.modelPath + \"' are missing.\");\n        return t.weightData = base64StringToArrayBuffer(o), [2, t];\n      });\n    });\n  }, e.URL_SCHEME = \"localstorage://\", e;\n}(),\n    localStorageRouter = function localStorageRouter(e) {\n  return ENV.get(\"IS_BROWSER\") && !Array.isArray(e) && e.startsWith(BrowserLocalStorage.URL_SCHEME) ? browserLocalStorage(e.slice(BrowserLocalStorage.URL_SCHEME.length)) : null;\n};\n\nfunction browserLocalStorage(e) {\n  return new BrowserLocalStorage(e);\n}\n\nIORouterRegistry.registerSaveRouter(localStorageRouter), IORouterRegistry.registerLoadRouter(localStorageRouter);\n\nvar BrowserLocalStorageManager = function () {\n  function e() {\n    assert(ENV.get(\"IS_BROWSER\"), \"Current environment is not a web browser\"), assert(void 0 !== window.localStorage, \"Current browser does not appear to support localStorage\"), this.LS = window.localStorage;\n  }\n\n  return e.prototype.listModels = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e, t, r, n, o, a;\n      return __generator(this, function (i) {\n        for (e = {}, t = PATH_PREFIX + PATH_SEPARATOR, r = PATH_SEPARATOR + INFO_SUFFIX, n = 0; n < this.LS.length; ++n) {\n          (o = this.LS.key(n)).startsWith(t) && o.endsWith(r) && (a = getModelPathFromKey(o), e[a] = JSON.parse(this.LS.getItem(o)));\n        }\n\n        return [2, e];\n      });\n    });\n  }, e.prototype.removeModel = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t, r;\n      return __generator(this, function (n) {\n        if (e = maybeStripScheme$1(e), t = getModelKeys(e), null == this.LS.getItem(t.info)) throw new Error(\"Cannot find model at path '\" + e + \"'\");\n        return r = JSON.parse(this.LS.getItem(t.info)), this.LS.removeItem(t.info), this.LS.removeItem(t.topology), this.LS.removeItem(t.weightSpecs), this.LS.removeItem(t.weightData), [2, r];\n      });\n    });\n  }, e;\n}();\n\nif (ENV.get(\"IS_BROWSER\")) try {\n  ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME, new BrowserLocalStorageManager());\n} catch (e) {}\n\nvar DEFAULT_FILE_NAME_PREFIX = \"model\",\n    DEFAULT_JSON_EXTENSION_NAME = \".json\",\n    DEFAULT_WEIGHT_DATA_EXTENSION_NAME = \".weights.bin\",\n    BrowserDownloads = function () {\n  function e(t) {\n    if (!ENV.get(\"IS_BROWSER\")) throw new Error(\"browserDownloads() cannot proceed because the current environment is not a browser.\");\n    t.startsWith(e.URL_SCHEME) && (t = t.slice(e.URL_SCHEME.length)), null != t && 0 !== t.length || (t = DEFAULT_FILE_NAME_PREFIX), this.modelTopologyFileName = t + DEFAULT_JSON_EXTENSION_NAME, this.weightDataFileName = t + DEFAULT_WEIGHT_DATA_EXTENSION_NAME;\n  }\n\n  return e.prototype.save = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t, r, n, o, a, i;\n      return __generator(this, function (s) {\n        if (t = window.URL.createObjectURL(new Blob([e.weightData], {\n          type: \"application/octet-stream\"\n        })), e.modelTopology instanceof ArrayBuffer) throw new Error(\"BrowserDownloads.save() does not support saving model topology in binary formats yet.\");\n        return r = [{\n          paths: [\"./\" + this.weightDataFileName],\n          weights: e.weightSpecs\n        }], n = {\n          modelTopology: e.modelTopology,\n          weightsManifest: r\n        }, o = window.URL.createObjectURL(new Blob([JSON.stringify(n)], {\n          type: \"application/json\"\n        })), (a = null == this.jsonAnchor ? document.createElement(\"a\") : this.jsonAnchor).download = this.modelTopologyFileName, a.href = o, a.click(), null != e.weightData && ((i = null == this.weightDataAnchor ? document.createElement(\"a\") : this.weightDataAnchor).download = this.weightDataFileName, i.href = t, i.click()), [2, {\n          modelArtifactsInfo: getModelArtifactsInfoForJSON(e)\n        }];\n      });\n    });\n  }, e.URL_SCHEME = \"downloads://\", e;\n}(),\n    BrowserFiles = function () {\n  function e(e) {\n    if (null == e || e.length < 1) throw new Error(\"When calling browserFiles, at least 1 file is required, but received \" + e);\n    this.files = e;\n  }\n\n  return e.prototype.load = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e,\n          t,\n          r = this;\n      return __generator(this, function (n) {\n        return e = this.files[0], t = this.files.slice(1), [2, new Promise(function (n, o) {\n          var a = new FileReader();\n          a.onload = function (a) {\n            var i = JSON.parse(a.target.result),\n                s = i.modelTopology;\n\n            if (null != s) {\n              0 === t.length && n({\n                modelTopology: s\n              });\n              var u = i.weightsManifest;\n\n              if (null != u) {\n                var l;\n\n                try {\n                  l = r.checkManifestAndWeightFiles(u, t);\n                } catch (e) {\n                  return void o(e);\n                }\n\n                var c = [],\n                    p = [],\n                    d = [];\n                u.forEach(function (e) {\n                  e.paths.forEach(function (e) {\n                    p.push(e), d.push(null);\n                  }), c.push.apply(c, e.weights);\n                }), u.forEach(function (e) {\n                  e.paths.forEach(function (e) {\n                    var t = new FileReader();\n                    t.onload = function (t) {\n                      var r = t.target.result,\n                          o = p.indexOf(e);\n                      d[o] = r, -1 === d.indexOf(null) && n({\n                        modelTopology: s,\n                        weightSpecs: c,\n                        weightData: concatenateArrayBuffers(d)\n                      });\n                    }, t.onerror = function (t) {\n                      return o(\"Failed to weights data from file of path '\" + e + \"'.\");\n                    }, t.readAsArrayBuffer(l[e]);\n                  });\n                });\n              } else o(new Error(\"weightManifest field is missing from file \" + e.name));\n            } else o(new Error(\"modelTopology field is missing from file \" + e.name));\n          }, a.onerror = function (t) {\n            return o(\"Failed to read model topology and weights manifest JSON from file '\" + e.name + \"'. BrowserFiles supports loading Keras-style tf.Model artifacts only.\");\n          }, a.readAsText(e);\n        })];\n      });\n    });\n  }, e.prototype.checkManifestAndWeightFiles = function (e, t) {\n    for (var r = [], n = t.map(function (e) {\n      return basename(e.name);\n    }), o = {}, a = 0, i = e; a < i.length; a++) {\n      i[a].paths.forEach(function (e) {\n        var a = basename(e);\n        if (-1 !== r.indexOf(a)) throw new Error(\"Duplicate file basename found in weights manifest: '\" + a + \"'\");\n        if (r.push(a), -1 === n.indexOf(a)) throw new Error(\"Weight file with basename '\" + a + \"' is not provided.\");\n        o[e] = t[n.indexOf(a)];\n      });\n    }\n\n    if (r.length !== t.length) throw new Error(\"Mismatch in the number of files in weights manifest (\" + r.length + \") and the number of weight files provided (\" + t.length + \").\");\n    return o;\n  }, e;\n}(),\n    browserDownloadsRouter = function browserDownloadsRouter(e) {\n  return ENV.get(\"IS_BROWSER\") && !Array.isArray(e) && e.startsWith(BrowserDownloads.URL_SCHEME) ? browserDownloads(e.slice(BrowserDownloads.URL_SCHEME.length)) : null;\n};\n\nfunction browserDownloads(e) {\n  return void 0 === e && (e = \"model\"), new BrowserDownloads(e);\n}\n\nfunction browserFiles(e) {\n  return new BrowserFiles(e);\n}\n\nfunction loadWeightsAsArrayBuffer(e, t) {\n  return __awaiter(this, void 0, void 0, function () {\n    var r, n;\n    return __generator(this, function (o) {\n      switch (o.label) {\n        case 0:\n          return r = e.map(function (e) {\n            return fetch(e, t);\n          }), [4, Promise.all(r)];\n\n        case 1:\n          return n = o.sent(), [4, Promise.all(n.map(function (e) {\n            return e.arrayBuffer();\n          }))];\n\n        case 2:\n          return [2, o.sent()];\n      }\n    });\n  });\n}\n\nfunction loadWeights(e, t, r, n) {\n  return void 0 === t && (t = \"\"), __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (o) {\n      return [2, weightsLoaderFactory(function (e) {\n        return loadWeightsAsArrayBuffer(e, n);\n      })(e, t, r)];\n    });\n  });\n}\n\nfunction weightsLoaderFactory(e) {\n  var t = this;\n  return function (r, n, o) {\n    return void 0 === n && (n = \"\"), __awaiter(t, void 0, void 0, function () {\n      var t, a, i, s, u, l, c, p, d, h;\n      return __generator(this, function (f) {\n        switch (f.label) {\n          case 0:\n            if (t = r.map(function () {\n              return !1;\n            }), a = {}, i = null != o ? o.map(function () {\n              return !1;\n            }) : [], s = [], r.forEach(function (e, r) {\n              var n = 0;\n              e.weights.forEach(function (e) {\n                var u = \"quantization\" in e ? e.quantization.dtype : e.dtype,\n                    l = DTYPE_VALUE_SIZE_MAP[u] * sizeFromShape(e.shape),\n                    c = function c() {\n                  t[r] = !0, null == a[r] && (a[r] = []), a[r].push({\n                    manifestEntry: e,\n                    groupOffset: n,\n                    sizeBytes: l\n                  });\n                };\n\n                null != o ? o.forEach(function (t, r) {\n                  t === e.name && (c(), i[r] = !0);\n                }) : c(), s.push(e.name), n += l;\n              });\n            }), !i.every(function (e) {\n              return e;\n            })) throw u = o.filter(function (e, t) {\n              return !i[t];\n            }), new Error(\"Could not find weights in manifest with names: \" + u.join(\", \") + \". \\nManifest JSON has weights with names: \" + s.join(\", \") + \".\");\n            return l = t.reduce(function (e, t, r) {\n              return t && e.push(r), e;\n            }, []), c = [], l.forEach(function (e) {\n              r[e].paths.forEach(function (e) {\n                var t = n + (n.endsWith(\"/\") ? \"\" : \"/\") + e;\n                c.push(t);\n              });\n            }), [4, e(c)];\n\n          case 1:\n            return p = f.sent(), d = {}, h = 0, l.forEach(function (e) {\n              for (var t = r[e].paths.length, n = 0, o = 0; o < t; o++) {\n                n += p[h + o].byteLength;\n              }\n\n              for (var i = new ArrayBuffer(n), s = new Uint8Array(i), u = 0, l = 0; l < t; l++) {\n                var c = new Uint8Array(p[h + l]);\n                s.set(c, u), u += c.byteLength;\n              }\n\n              a[e].forEach(function (e) {\n                var t = decodeWeights(i.slice(e.groupOffset, e.groupOffset + e.sizeBytes), [e.manifestEntry]);\n\n                for (var r in t) {\n                  d[r] = t[r];\n                }\n              }), h += t;\n            }), [2, d];\n        }\n      });\n    });\n  };\n}\n\nIORouterRegistry.registerSaveRouter(browserDownloadsRouter);\n\nvar BrowserHTTPRequest = function () {\n  function e(e, t, r) {\n    if (this.weightPathPrefix = r, this.DEFAULT_METHOD = \"POST\", \"undefined\" == typeof fetch) throw new Error(\"browserHTTPRequest is not supported outside the web browser without a fetch polyfill.\");\n    if (assert(null != e && e.length > 0, \"URL path for browserHTTPRequest must not be null, undefined or empty.\"), Array.isArray(e) && assert(2 === e.length, \"URL paths for browserHTTPRequest must have a length of 2, (actual length is \" + e.length + \").\"), this.path = e, null != t && null != t.body) throw new Error(\"requestInit is expected to have no pre-existing body, but has one.\");\n    this.requestInit = t || {};\n  }\n\n  return e.prototype.save = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t, r, n, o;\n      return __generator(this, function (a) {\n        switch (a.label) {\n          case 0:\n            if (e.modelTopology instanceof ArrayBuffer) throw new Error(\"BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.\");\n            return (t = Object.assign({\n              method: this.DEFAULT_METHOD\n            }, this.requestInit)).body = new FormData(), r = [{\n              paths: [\"./model.weights.bin\"],\n              weights: e.weightSpecs\n            }], n = {\n              modelTopology: e.modelTopology,\n              weightsManifest: r\n            }, t.body.append(\"model.json\", new Blob([JSON.stringify(n)], {\n              type: \"application/json\"\n            }), \"model.json\"), null != e.weightData && t.body.append(\"model.weights.bin\", new Blob([e.weightData], {\n              type: \"application/octet-stream\"\n            }), \"model.weights.bin\"), [4, fetch(this.path, t)];\n\n          case 1:\n            if ((o = a.sent()).ok) return [2, {\n              modelArtifactsInfo: getModelArtifactsInfoForJSON(e),\n              responses: [o]\n            }];\n            throw new Error(\"BrowserHTTPRequest.save() failed due to HTTP response status \" + o.status + \".\");\n        }\n      });\n    });\n  }, e.prototype.load = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (e) {\n        return [2, Array.isArray(this.path) ? this.loadBinaryModel() : this.loadJSONModel()];\n      });\n    });\n  }, e.prototype.loadBinaryTopology = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e, t;\n      return __generator(this, function (r) {\n        switch (r.label) {\n          case 0:\n            return r.trys.push([0, 3,, 4]), [4, fetch(this.path[0], this.requestInit)];\n\n          case 1:\n            if (!(e = r.sent()).ok) throw new Error(\"BrowserHTTPRequest.load() failed due to HTTP response: \" + e.statusText);\n            return [4, e.arrayBuffer()];\n\n          case 2:\n            return [2, r.sent()];\n\n          case 3:\n            throw t = r.sent(), new Error(this.path[0] + \" not found. \" + t);\n\n          case 4:\n            return [2];\n        }\n      });\n    });\n  }, e.prototype.loadBinaryModel = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e, t, r, n, o, a, i, s;\n      return __generator(this, function (u) {\n        switch (u.label) {\n          case 0:\n            return e = this.loadBinaryTopology(), [4, fetch(this.path[1], this.requestInit)];\n\n          case 1:\n            if (!(t = u.sent()).ok) throw new Error(\"BrowserHTTPRequest.load() failed due to HTTP response: \" + t.statusText);\n            return [4, Promise.all([e, t])];\n\n          case 2:\n            return r = u.sent(), n = r[0], [4, r[1].json()];\n\n          case 3:\n            return null == (o = u.sent()) ? [3, 5] : [4, this.loadWeights(o)];\n\n          case 4:\n            s = u.sent(), a = s[0], i = s[1], u.label = 5;\n\n          case 5:\n            return [2, {\n              modelTopology: n,\n              weightSpecs: a,\n              weightData: i\n            }];\n        }\n      });\n    });\n  }, e.prototype.loadJSONModel = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e, t, r, n, o, a, i, s;\n      return __generator(this, function (u) {\n        switch (u.label) {\n          case 0:\n            return [4, fetch(this.path, this.requestInit)];\n\n          case 1:\n            if (!(e = u.sent()).ok) throw new Error(\"BrowserHTTPRequest.load() failed due to HTTP response: \" + e.statusText);\n            return [4, e.json()];\n\n          case 2:\n            if (t = u.sent(), r = t.modelTopology, n = t.weightsManifest, null == r && null == n) throw new Error(\"The JSON from HTTP path \" + this.path + \" contains neither model topology or manifest for weights.\");\n            return null == n ? [3, 4] : (i = t.weightsManifest, [4, this.loadWeights(i)]);\n\n          case 3:\n            s = u.sent(), o = s[0], a = s[1], u.label = 4;\n\n          case 4:\n            return [2, {\n              modelTopology: r,\n              weightSpecs: o,\n              weightData: a\n            }];\n        }\n      });\n    });\n  }, e.prototype.loadWeights = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      var t, r, n, o, a, i, s, u, l, c, p, d;\n      return __generator(this, function (h) {\n        switch (h.label) {\n          case 0:\n            for (t = Array.isArray(this.path) ? this.path[1] : this.path, r = parseUrl(t), n = r[0], o = r[1], a = this.weightPathPrefix || n, i = [], s = 0, u = e; s < u.length; s++) {\n              l = u[s], i.push.apply(i, l.weights);\n            }\n\n            return c = [], e.forEach(function (e) {\n              e.paths.forEach(function (e) {\n                c.push(a + e + o);\n              });\n            }), p = [i], d = concatenateArrayBuffers, [4, loadWeightsAsArrayBuffer(c, this.requestInit)];\n\n          case 1:\n            return [2, p.concat([d.apply(void 0, [h.sent()])])];\n        }\n      });\n    });\n  }, e.URL_SCHEME_REGEX = /^https?:\\/\\//, e;\n}();\n\nfunction parseUrl(e) {\n  var t = e.lastIndexOf(\"/\"),\n      r = e.lastIndexOf(\"?\");\n  return [e.substring(0, t) + \"/\", r > t ? e.substring(r) : \"\"];\n}\n\nfunction isHTTPScheme(e) {\n  return null != e.match(BrowserHTTPRequest.URL_SCHEME_REGEX);\n}\n\nvar httpRequestRouter = function httpRequestRouter(e) {\n  if (\"undefined\" == typeof fetch) return null;\n  return (Array.isArray(e) ? e.every(function (e) {\n    return isHTTPScheme(e);\n  }) : isHTTPScheme(e)) ? browserHTTPRequest(e) : null;\n};\n\nfunction browserHTTPRequest(e, t, r) {\n  return new BrowserHTTPRequest(e, t, r);\n}\n\nIORouterRegistry.registerSaveRouter(httpRequestRouter), IORouterRegistry.registerLoadRouter(httpRequestRouter);\n\nvar PassthroughLoader = function () {\n  function e(e, t, r) {\n    this.modelTopology = e, this.weightSpecs = t, this.weightData = r;\n  }\n\n  return e.prototype.load = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e;\n      return __generator(this, function (t) {\n        return e = {}, null != this.modelTopology && (e = __assign({\n          modelTopology: this.modelTopology\n        }, e)), null != this.weightSpecs && this.weightSpecs.length > 0 && (e = __assign({\n          weightSpecs: this.weightSpecs\n        }, e)), null != this.weightData && this.weightData.byteLength > 0 && (e = __assign({\n          weightData: this.weightData\n        }, e)), [2, e];\n      });\n    });\n  }, e;\n}(),\n    PassthroughSaver = function () {\n  function e(e) {\n    this.saveHandler = e;\n  }\n\n  return e.prototype.save = function (e) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (t) {\n        return [2, this.saveHandler(e)];\n      });\n    });\n  }, e;\n}();\n\nfunction fromMemory(e, t, r) {\n  return new PassthroughLoader(e, t, r);\n}\n\nfunction withSaveHandler(e) {\n  return new PassthroughSaver(e);\n}\n\nvar registerSaveRouter = IORouterRegistry.registerSaveRouter,\n    registerLoadRouter = IORouterRegistry.registerLoadRouter,\n    getSaveHandlers = IORouterRegistry.getSaveHandlers,\n    getLoadHandlers = IORouterRegistry.getLoadHandlers,\n    io = Object.freeze({\n  browserFiles: browserFiles,\n  browserHTTPRequest: browserHTTPRequest,\n  concatenateArrayBuffers: concatenateArrayBuffers,\n  decodeWeights: decodeWeights,\n  encodeWeights: encodeWeights,\n  fromMemory: fromMemory,\n  getLoadHandlers: getLoadHandlers,\n  getModelArtifactsInfoForJSON: getModelArtifactsInfoForJSON,\n  getSaveHandlers: getSaveHandlers,\n  loadWeights: loadWeights,\n  registerLoadRouter: registerLoadRouter,\n  registerSaveRouter: registerSaveRouter,\n  weightsLoaderFactory: weightsLoaderFactory,\n  withSaveHandler: withSaveHandler,\n  copyModel: copyModel,\n  listModels: listModels,\n  moveModel: moveModel,\n  removeModel: removeModel\n});\n\nfunction confusionMatrix_(e, t, r) {\n  var n = convertToTensor(e, \"labels\", \"confusionMatrix\"),\n      o = convertToTensor(t, \"predictions\", \"confusionMatrix\");\n  assert(null == r || r > 0 && Number.isInteger(r), \"If provided, numClasses must be a positive integer, but got \" + r), assert(1 === n.rank, \"Expected the rank of labels to be 1, but got \" + n.rank), assert(1 === o.rank, \"Expected the rank of predictions to be 1, but got \" + o.rank), assert(n.shape[0] === o.shape[0], \"Mismatch in the number of examples: \" + n.shape[0] + \" vs. \" + o.shape[0] + \". Labels and predictions should have the same number of elements.\"), assert(r > 0 && Number.isInteger(r), \"numClasses is required to be a positive integer, but got \" + r);\n  var a = oneHot(n.asType(\"int32\"), r),\n      i = oneHot(o.asType(\"int32\"), r);\n  return a.transpose().matMul(i).asType(\"int32\");\n}\n\nvar confusionMatrix = op({\n  confusionMatrix_: confusionMatrix_\n}),\n    math = Object.freeze({\n  confusionMatrix: confusionMatrix\n}),\n    Serializable = function () {\n  function e() {}\n\n  return e.prototype.getClassName = function () {\n    return this.constructor.className;\n  }, e.fromConfig = function (e, t) {\n    return new e(t);\n  }, e;\n}(),\n    SerializationMap = function () {\n  function e() {\n    this.classNameMap = {};\n  }\n\n  return e.getMap = function () {\n    return null == e.instance && (e.instance = new e()), e.instance;\n  }, e.register = function (t) {\n    e.getMap().classNameMap[t.className] = [t, t.fromConfig];\n  }, e;\n}();\n\nfunction registerClass(e) {\n  assert(null != e.className, \"Class being registered does not have the static className property defined.\"), assert(\"string\" == typeof e.className, \"className is required to be a string, but got type \" + typeof e.className), assert(e.className.length > 0, \"Class being registered has an empty-string as its className, which is disallowed.\"), SerializationMap.register(e);\n}\n\nvar serialization = Object.freeze({\n  Serializable: Serializable,\n  SerializationMap: SerializationMap,\n  registerClass: registerClass\n}),\n    WEBGL_ENVS = {\n  HAS_WEBGL: !0\n},\n    NODE_ENVS = {\n  IS_NODE: !0\n},\n    CHROME_ENVS = {\n  IS_CHROME: !0\n},\n    BROWSER_ENVS = {\n  IS_BROWSER: !0\n},\n    CPU_ENVS = {\n  HAS_WEBGL: !1\n},\n    ALL_ENVS = {};\n\nfunction expectArraysClose(e, t, r) {\n  return null == r && (r = ENV.get(\"TEST_EPSILON\")), expectArraysPredicate(e, t, function (e, t) {\n    return areClose(e, Number(t), r);\n  });\n}\n\nfunction expectArraysPredicate(e, t, r) {\n  if (e instanceof Tensor || t instanceof Tensor) {\n    if (e instanceof Tensor && t instanceof Tensor) {\n      if (e.dtype !== t.dtype) throw new Error(\"Arrays are of different type actual: \" + e.dtype + \" vs expected: \" + t.dtype + \".\");\n      if (!arraysEqual(e.shape, t.shape)) throw new Error(\"Arrays are of different shape actual: \" + e.shape + \" vs expected: \" + t.shape + \".\");\n    }\n  } else {\n    var n = e.constructor.name,\n        o = t.constructor.name;\n    if (n !== o) throw new Error(\"Arrays are of different type actual: \" + n + \" vs expected: \" + o);\n  }\n\n  var a, i;\n  if (a = e instanceof Tensor ? e.dataSync() : e, i = t instanceof Tensor ? t.dataSync() : t, a.length !== i.length) throw new Error(\"Arrays have different lengths actual: \" + a.length + \" vs expected: \" + i.length + \".\\nActual:   \" + a + \".\\nExpected: \" + i + \".\");\n\n  for (var s = 0; s < i.length; ++s) {\n    var u = a[s],\n        l = i[s];\n    if (!r(u, l)) throw new Error(\"Arrays differ: actual[\" + s + \"] = \" + u + \", expected[\" + s + \"] = \" + l + \".\\nActual:   \" + a + \".\\nExpected: \" + i + \".\");\n  }\n}\n\nfunction expectPromiseToFail(e, t) {\n  e().then(function () {\n    return t.fail();\n  }, function () {\n    return t();\n  });\n}\n\nfunction expectArraysEqual(e, t) {\n  return e instanceof Tensor && \"string\" === e.dtype || t instanceof Tensor && \"string\" === t.dtype || e instanceof Array && isString(e[0]) || t instanceof Array && isString(t[0]) ? expectArraysPredicate(e, t, function (e, t) {\n    return e == t;\n  }) : expectArraysClose(e, t, 0);\n}\n\nfunction expectNumbersClose(e, t, r) {\n  if (null == r && (r = ENV.get(\"TEST_EPSILON\")), !areClose(e, t, r)) throw new Error(\"Numbers differ: actual === \" + e + \", expected === \" + t);\n}\n\nfunction areClose(e, t, r) {\n  return !(!isNaN(e) || !isNaN(t)) || !(isNaN(e) || isNaN(t) || Math.abs(e - t) > r);\n}\n\nfunction expectValuesInRange(e, t, r) {\n  var n;\n  n = e instanceof Tensor ? e.dataSync() : e;\n\n  for (var o = 0; o < n.length; o++) {\n    if (n[o] < t || n[o] > r) throw new Error(\"Value out of range:\" + n[o] + \" low: \" + t + \", high: \" + r);\n  }\n}\n\nfunction expectArrayBuffersEqual(e, t) {\n  expect(new Float32Array(e)).toEqual(new Float32Array(t));\n}\n\nvar test_util = Object.freeze({\n  WEBGL_ENVS: WEBGL_ENVS,\n  NODE_ENVS: NODE_ENVS,\n  CHROME_ENVS: CHROME_ENVS,\n  BROWSER_ENVS: BROWSER_ENVS,\n  CPU_ENVS: CPU_ENVS,\n  ALL_ENVS: ALL_ENVS,\n  expectArraysClose: expectArraysClose,\n  expectPromiseToFail: expectPromiseToFail,\n  expectArraysEqual: expectArraysEqual,\n  expectNumbersClose: expectNumbersClose,\n  expectValuesInRange: expectValuesInRange,\n  expectArrayBuffersEqual: expectArrayBuffersEqual\n}),\n    version = \"0.14.0\",\n    webgl = Object.freeze({\n  gpgpu_util: gpgpu_util,\n  webgl_util: webgl_util,\n  MathBackendWebGL: MathBackendWebGL,\n  GPGPUContext: GPGPUContext\n}),\n    Optimizer = function (e) {\n  function t() {\n    return null !== e && e.apply(this, arguments) || this;\n  }\n\n  return __extends(t, e), t.prototype.minimize = function (e, t, r) {\n    void 0 === t && (t = !1);\n    var n = this.computeGradients(e, r),\n        o = n.value,\n        a = n.grads;\n    return this.applyGradients(a), Object.keys(a).forEach(function (e) {\n      return a[e].dispose();\n    }), t ? o : (o.dispose(), null);\n  }, t.prototype.computeGradients = function (e, t) {\n    return variableGrads(e, t);\n  }, t;\n}(Serializable),\n    AdadeltaOptimizer = function (e) {\n  function t(t, r, n) {\n    void 0 === n && (n = null);\n    var o = e.call(this) || this;\n    return o.learningRate = t, o.rho = r, o.epsilon = n, o.accumulatedGrads = {}, o.accumulatedUpdates = {}, o.c = keep(scalar(-t)), o.rhoScalar = keep(scalar(r)), o.oneMinusRho = keep(scalar(1 - r)), null === n && (n = ENV.get(\"EPSILON\")), o.epsilonScalar = keep(scalar(n)), o;\n  }\n\n  return __extends(t, e), t.prototype.applyGradients = function (e) {\n    var t = this,\n        r = function r(_r2) {\n      var o = ENV.engine.registeredVariables[_r2];\n\n      if (null == n.accumulatedGrads[_r2]) {\n        tidy(function () {\n          t.accumulatedGrads[_r2] = zerosLike(o).variable(!1);\n        });\n      }\n\n      if (null == n.accumulatedUpdates[_r2]) {\n        tidy(function () {\n          t.accumulatedUpdates[_r2] = zerosLike(o).variable(!1);\n        });\n      }\n\n      var a = e[_r2],\n          i = n.accumulatedGrads[_r2],\n          s = n.accumulatedUpdates[_r2];\n      tidy(function () {\n        var e = t.rhoScalar.mul(i).add(t.oneMinusRho.mul(a.square())),\n            n = s.add(t.epsilonScalar).sqrt().div(i.add(t.epsilonScalar).sqrt()).mul(a),\n            u = t.rhoScalar.mul(s).add(t.oneMinusRho.mul(n.square()));\n        t.accumulatedGrads[_r2].assign(e), t.accumulatedUpdates[_r2].assign(u);\n        var l = t.c.mul(n).add(o);\n        o.assign(l);\n      });\n    },\n        n = this;\n\n    for (var o in e) {\n      r(o);\n    }\n  }, t.prototype.dispose = function () {\n    var e = this;\n    this.c.dispose(), this.epsilonScalar.dispose(), this.rhoScalar.dispose(), this.oneMinusRho.dispose(), null != this.accumulatedUpdates && (Object.keys(this.accumulatedUpdates).forEach(function (t) {\n      return e.accumulatedUpdates[t].dispose();\n    }), Object.keys(this.accumulatedGrads).forEach(function (t) {\n      return e.accumulatedGrads[t].dispose();\n    }));\n  }, t.prototype.getConfig = function () {\n    return {\n      learningRate: this.learningRate,\n      rho: this.rho,\n      epsilon: this.epsilon\n    };\n  }, t.fromConfig = function (e, t) {\n    return new e(t.learningRate, t.rho, t.epsilon);\n  }, t.className = \"AdadeltaOptimizer\", t;\n}(Optimizer);\n\nregisterClass(AdadeltaOptimizer);\n\nvar AdagradOptimizer = function (e) {\n  function t(t, r) {\n    void 0 === r && (r = .1);\n    var n = e.call(this) || this;\n    return n.learningRate = t, n.initialAccumulatorValue = r, n.accumulatedGrads = {}, n.c = keep(scalar(-t)), n.epsilon = keep(scalar(ENV.get(\"EPSILON\"))), n;\n  }\n\n  return __extends(t, e), t.prototype.applyGradients = function (e) {\n    var t = this,\n        r = function r(_r3) {\n      var o = ENV.engine.registeredVariables[_r3];\n\n      if (null == n.accumulatedGrads[_r3]) {\n        tidy(function () {\n          t.accumulatedGrads[_r3] = fill(o.shape, t.initialAccumulatorValue).variable(!1);\n        });\n      }\n\n      var a = e[_r3],\n          i = n.accumulatedGrads[_r3];\n      tidy(function () {\n        var e = i.add(a.square());\n\n        t.accumulatedGrads[_r3].assign(e);\n\n        var n = t.c.mul(a.div(e.add(t.epsilon).sqrt())).add(o);\n        o.assign(n);\n      });\n    },\n        n = this;\n\n    for (var o in e) {\n      r(o);\n    }\n  }, t.prototype.dispose = function () {\n    var e = this;\n    this.epsilon.dispose(), this.c.dispose(), null != this.accumulatedGrads && Object.keys(this.accumulatedGrads).forEach(function (t) {\n      return e.accumulatedGrads[t].dispose();\n    });\n  }, t.prototype.getConfig = function () {\n    return {\n      learningRate: this.learningRate,\n      initialAccumulatorValue: this.initialAccumulatorValue\n    };\n  }, t.fromConfig = function (e, t) {\n    return new e(t.learningRate, t.initialAccumulatorValue);\n  }, t.className = \"AdagradOptimizer\", t;\n}(Optimizer);\n\nregisterClass(AdagradOptimizer);\n\nvar AdamOptimizer = function (e) {\n  function t(t, r, n, o) {\n    void 0 === o && (o = null);\n    var a = e.call(this) || this;\n    return a.learningRate = t, a.beta1 = r, a.beta2 = n, a.epsilon = o, a.accumulatedFirstMoment = {}, a.accumulatedSecondMoment = {}, a.c = keep(scalar(-t)), a.beta1Scalar = keep(scalar(r)), a.beta2Scalar = keep(scalar(n)), tidy(function () {\n      a.accBeta1 = scalar(r).variable(), a.accBeta2 = scalar(n).variable();\n    }), a.oneMinusBeta1 = keep(scalar(1 - r)), a.oneMinusBeta2 = keep(scalar(1 - n)), a.one = keep(scalar(1)), null === o && (o = ENV.get(\"EPSILON\")), a.epsScalar = keep(scalar(o)), a;\n  }\n\n  return __extends(t, e), t.prototype.applyGradients = function (e) {\n    var t = this;\n    tidy(function () {\n      var r = t.one.sub(t.accBeta1),\n          n = t.one.sub(t.accBeta2);\n\n      for (var o in e) {\n        var a = ENV.engine.registeredVariables[o];\n\n        if (null == t.accumulatedFirstMoment[o]) {\n          var i = !1;\n          t.accumulatedFirstMoment[o] = zerosLike(a).variable(i);\n        }\n\n        if (null == t.accumulatedSecondMoment[o]) {\n          i = !1;\n          t.accumulatedSecondMoment[o] = zerosLike(a).variable(i);\n        }\n\n        var s = e[o],\n            u = t.accumulatedFirstMoment[o],\n            l = t.accumulatedSecondMoment[o],\n            c = t.beta1Scalar.mul(u).add(t.oneMinusBeta1.mul(s)),\n            p = t.beta2Scalar.mul(l).add(t.oneMinusBeta2.mul(s.square())),\n            d = c.div(r),\n            h = p.div(n);\n        t.accumulatedFirstMoment[o].assign(c), t.accumulatedSecondMoment[o].assign(p);\n        var f = t.c.mul(d.div(t.epsScalar.add(h.sqrt()))).add(a);\n        a.assign(f);\n      }\n\n      t.accBeta1.assign(t.accBeta1.mul(t.beta1Scalar)), t.accBeta2.assign(t.accBeta2.mul(t.beta2Scalar));\n    });\n  }, t.prototype.dispose = function () {\n    var e = this;\n    this.c.dispose(), this.epsScalar.dispose(), this.beta1Scalar.dispose(), this.beta2Scalar.dispose(), this.accBeta1.dispose(), this.accBeta2.dispose(), this.oneMinusBeta1.dispose(), this.oneMinusBeta2.dispose(), this.one.dispose(), null != this.accumulatedFirstMoment && Object.keys(this.accumulatedFirstMoment).forEach(function (t) {\n      return e.accumulatedFirstMoment[t].dispose();\n    }), null != this.accumulatedSecondMoment && Object.keys(this.accumulatedSecondMoment).forEach(function (t) {\n      return e.accumulatedSecondMoment[t].dispose();\n    });\n  }, t.prototype.getConfig = function () {\n    return {\n      learningRate: this.learningRate,\n      beta1: this.beta1,\n      beta2: this.beta2,\n      epsilon: this.epsilon\n    };\n  }, t.fromConfig = function (e, t) {\n    return new e(t.learningRate, t.beta1, t.beta2, t.epsilon);\n  }, t.className = \"AdamOptimizer\", t;\n}(Optimizer);\n\nregisterClass(AdamOptimizer);\n\nvar AdamaxOptimizer = function (e) {\n  function t(t, r, n, o, a) {\n    void 0 === o && (o = null), void 0 === a && (a = 0);\n    var i = e.call(this) || this;\n    return i.learningRate = t, i.beta1 = r, i.beta2 = n, i.epsilon = o, i.decay = a, i.accumulatedFirstMoment = {}, i.accumulatedWeightedInfNorm = {}, i.c = keep(scalar(-t)), i.beta1Scalar = keep(scalar(r)), i.beta2Scalar = keep(scalar(n)), i.decayScalar = keep(scalar(a)), tidy(function () {\n      i.iteration = scalar(0).variable(), i.accBeta1 = scalar(r).variable();\n    }), i.oneMinusBeta1 = keep(scalar(1 - r)), i.one = keep(scalar(1)), null === o && (o = ENV.get(\"EPSILON\")), i.epsScalar = keep(scalar(o)), i;\n  }\n\n  return __extends(t, e), t.prototype.applyGradients = function (e) {\n    var t = this;\n    tidy(function () {\n      var r = t.one.sub(t.accBeta1),\n          n = t.c.div(t.one.add(t.decayScalar.mul(t.iteration)));\n\n      for (var o in e) {\n        var a = ENV.engine.registeredVariables[o];\n\n        if (null == t.accumulatedFirstMoment[o]) {\n          var i = !1;\n          t.accumulatedFirstMoment[o] = zerosLike(a).variable(i);\n        }\n\n        if (null == t.accumulatedWeightedInfNorm[o]) {\n          i = !1;\n          t.accumulatedWeightedInfNorm[o] = zerosLike(a).variable(i);\n        }\n\n        var s = e[o],\n            u = t.accumulatedFirstMoment[o],\n            l = t.accumulatedWeightedInfNorm[o],\n            c = t.beta1Scalar.mul(u).add(t.oneMinusBeta1.mul(s)),\n            p = t.beta2Scalar.mul(l),\n            d = s.abs(),\n            h = p.maximum(d);\n        t.accumulatedFirstMoment[o].assign(c), t.accumulatedWeightedInfNorm[o].assign(h);\n        var f = n.div(r).mul(c.div(t.epsScalar.add(h))).add(a);\n        a.assign(f);\n      }\n\n      t.iteration.assign(t.iteration.add(t.one)), t.accBeta1.assign(t.accBeta1.mul(t.beta1Scalar));\n    });\n  }, t.prototype.dispose = function () {\n    var e = this;\n    this.c.dispose(), this.epsScalar.dispose(), this.accBeta1.dispose(), this.beta1Scalar.dispose(), this.beta2Scalar.dispose(), this.oneMinusBeta1.dispose(), this.decayScalar.dispose(), this.iteration.dispose(), this.one.dispose(), null != this.accumulatedFirstMoment && Object.keys(this.accumulatedFirstMoment).forEach(function (t) {\n      return e.accumulatedFirstMoment[t].dispose();\n    }), null != this.accumulatedWeightedInfNorm && Object.keys(this.accumulatedWeightedInfNorm).forEach(function (t) {\n      return e.accumulatedWeightedInfNorm[t].dispose();\n    });\n  }, t.prototype.getConfig = function () {\n    return {\n      learningRate: this.learningRate,\n      beta1: this.beta1,\n      beta2: this.beta2,\n      epsilon: this.epsilon,\n      decay: this.decay\n    };\n  }, t.fromConfig = function (e, t) {\n    return new e(t.learningRate, t.beta1, t.beta2, t.epsilon, t.decay);\n  }, t.className = \"AdamaxOptimizer\", t;\n}(Optimizer);\n\nregisterClass(AdamaxOptimizer);\n\nvar SGDOptimizer = function (e) {\n  function t(t) {\n    var r = e.call(this) || this;\n    return r.learningRate = t, r.setLearningRate(t), r;\n  }\n\n  return __extends(t, e), t.prototype.applyGradients = function (e) {\n    var t = this;\n    Object.keys(e).forEach(function (r) {\n      var n = e[r],\n          o = ENV.engine.registeredVariables[r];\n      tidy(function () {\n        var e = t.c.mul(n).add(o);\n        o.assign(e);\n      });\n    });\n  }, t.prototype.setLearningRate = function (e) {\n    this.learningRate = e, null != this.c && this.c.dispose(), this.c = keep(scalar(-e));\n  }, t.prototype.dispose = function () {\n    this.c.dispose();\n  }, t.prototype.getConfig = function () {\n    return {\n      learningRate: this.learningRate\n    };\n  }, t.fromConfig = function (e, t) {\n    return new e(t.learningRate);\n  }, t.className = \"SGDOptimizer\", t;\n}(Optimizer);\n\nregisterClass(SGDOptimizer);\n\nvar MomentumOptimizer = function (e) {\n  function t(t, r, n) {\n    void 0 === n && (n = !1);\n    var o = e.call(this, t) || this;\n    return o.learningRate = t, o.momentum = r, o.useNesterov = n, o.m = scalar(o.momentum), o.accumulations = {}, o;\n  }\n\n  return __extends(t, e), t.prototype.applyGradients = function (e) {\n    var t = this,\n        r = function r(_r4) {\n      var o = ENV.engine.registeredVariables[_r4];\n\n      if (null == n.accumulations[_r4]) {\n        tidy(function () {\n          t.accumulations[_r4] = zerosLike(o).variable(!1);\n        });\n      }\n\n      var a = n.accumulations[_r4],\n          i = e[_r4];\n      tidy(function () {\n        var e,\n            n = t.m.mul(a).add(i);\n        e = t.useNesterov ? t.c.mul(i.add(n.mul(t.m))).add(o) : t.c.mul(n).add(o), t.accumulations[_r4].assign(n), o.assign(e);\n      });\n    },\n        n = this;\n\n    for (var o in e) {\n      r(o);\n    }\n  }, t.prototype.dispose = function () {\n    if (e.prototype.dispose.call(this), this.m.dispose(), null != this.accumulations) for (var t in this.accumulations) {\n      this.accumulations[t].dispose();\n    }\n  }, t.prototype.setMomentum = function (e) {\n    this.momentum = e;\n  }, t.prototype.getConfig = function () {\n    return {\n      learningRate: this.learningRate,\n      momentum: this.momentum,\n      useNesterov: this.useNesterov\n    };\n  }, t.fromConfig = function (e, t) {\n    return new e(t.learningRate, t.momentum, t.useNesterov);\n  }, t.className = \"MomentumOptimizer\", t;\n}(SGDOptimizer);\n\nregisterClass(MomentumOptimizer);\n\nvar RMSPropOptimizer = function (e) {\n  function t(t, r, n, o, a) {\n    void 0 === r && (r = .9), void 0 === n && (n = 0), void 0 === o && (o = null), void 0 === a && (a = !1);\n    var i = e.call(this) || this;\n    return i.learningRate = t, i.decay = r, i.momentum = n, i.epsilon = o, i.accumulatedMeanSquares = {}, i.accumulatedMeanGrads = {}, i.accumulatedMoments = {}, i.c = keep(scalar(t)), i.decayScalar = keep(scalar(r)), i.momentumScalar = keep(scalar(n)), i.oneMinusDecay = keep(scalar(1 - r)), i.centered = a, null === o && (o = ENV.get(\"EPSILON\")), i.epsilonScalar = keep(scalar(o)), i;\n  }\n\n  return __extends(t, e), t.prototype.applyGradients = function (e) {\n    var t = this,\n        r = function r(_r5) {\n      var o = ENV.engine.registeredVariables[_r5];\n\n      if (null == n.accumulatedMeanSquares[_r5]) {\n        tidy(function () {\n          t.accumulatedMeanSquares[_r5] = zerosLike(o).variable(!1);\n        });\n      }\n\n      if (null == n.accumulatedMeanGrads[_r5] && n.centered) {\n        tidy(function () {\n          t.accumulatedMeanGrads[_r5] = zerosLike(o).variable(!1);\n        });\n      }\n\n      if (null == n.accumulatedMoments[_r5]) {\n        tidy(function () {\n          t.accumulatedMoments[_r5] = zerosLike(o).variable(!1);\n        });\n      }\n\n      var a = n.accumulatedMeanSquares[_r5],\n          i = n.accumulatedMeanGrads[_r5],\n          s = n.accumulatedMoments[_r5],\n          u = e[_r5];\n      tidy(function () {\n        var e = t.decayScalar.mul(a).add(t.oneMinusDecay.mul(u.square()));\n\n        if (t.centered) {\n          var n = t.decayScalar.mul(i).add(t.oneMinusDecay.mul(u)),\n              l = t.momentumScalar.mul(s).add(t.c.mul(u).div(e.sub(n.square().add(t.epsilonScalar)).sqrt()));\n          t.accumulatedMeanSquares[_r5].assign(e), t.accumulatedMeanGrads[_r5].assign(n), t.accumulatedMoments[_r5].assign(l);\n          var c = o.sub(l);\n          o.assign(c);\n        } else {\n          var p = t.decayScalar.mul(a).add(t.oneMinusDecay.mul(u.square()));\n          l = t.momentumScalar.mul(s).add(t.c.mul(u).div(p.add(t.epsilonScalar).sqrt()));\n          t.accumulatedMeanSquares[_r5].assign(p), t.accumulatedMoments[_r5].assign(l);\n          c = o.sub(l);\n          o.assign(c);\n        }\n      });\n    },\n        n = this;\n\n    for (var o in e) {\n      r(o);\n    }\n  }, t.prototype.dispose = function () {\n    var e = this;\n    this.c.dispose(), this.epsilonScalar.dispose(), this.decayScalar.dispose(), this.momentumScalar.dispose(), this.oneMinusDecay.dispose(), null != this.accumulatedMeanSquares && Object.keys(this.accumulatedMeanSquares).forEach(function (t) {\n      return e.accumulatedMeanSquares[t].dispose();\n    }), null != this.accumulatedMeanGrads && this.centered && Object.keys(this.accumulatedMeanGrads).forEach(function (t) {\n      return e.accumulatedMeanGrads[t].dispose();\n    }), null != this.accumulatedMoments && Object.keys(this.accumulatedMoments).forEach(function (t) {\n      return e.accumulatedMoments[t].dispose();\n    });\n  }, t.prototype.getConfig = function () {\n    return {\n      learningRate: this.learningRate,\n      decay: this.decay,\n      momentum: this.momentum,\n      epsilon: this.epsilon,\n      centered: this.centered\n    };\n  }, t.fromConfig = function (e, t) {\n    return new e(t.learningRate, t.decay, t.momentum, t.epsilon, t.centered);\n  }, t.className = \"RMSPropOptimizer\", t;\n}(Optimizer);\n\nregisterClass(RMSPropOptimizer);\n\nvar OptimizerConstructors = function () {\n  function e() {}\n\n  return e.sgd = function (e) {\n    return new SGDOptimizer(e);\n  }, e.momentum = function (e, t, r) {\n    return void 0 === r && (r = !1), new MomentumOptimizer(e, t, r);\n  }, e.rmsprop = function (e, t, r, n, o) {\n    return void 0 === t && (t = .9), void 0 === r && (r = 0), void 0 === n && (n = null), void 0 === o && (o = !1), new RMSPropOptimizer(e, t, r, n, o);\n  }, e.adam = function (e, t, r, n) {\n    return void 0 === e && (e = .001), void 0 === t && (t = .9), void 0 === r && (r = .999), void 0 === n && (n = null), new AdamOptimizer(e, t, r, n);\n  }, e.adadelta = function (e, t, r) {\n    return void 0 === e && (e = .001), void 0 === t && (t = .95), void 0 === r && (r = null), new AdadeltaOptimizer(e, t, r);\n  }, e.adamax = function (e, t, r, n, o) {\n    return void 0 === e && (e = .002), void 0 === t && (t = .9), void 0 === r && (r = .999), void 0 === n && (n = null), void 0 === o && (o = 0), new AdamaxOptimizer(e, t, r, n, o);\n  }, e.adagrad = function (e, t) {\n    return void 0 === t && (t = .1), new AdagradOptimizer(e, t);\n  }, e;\n}(),\n    train = {\n  sgd: OptimizerConstructors.sgd,\n  momentum: OptimizerConstructors.momentum,\n  adadelta: OptimizerConstructors.adadelta,\n  adagrad: OptimizerConstructors.adagrad,\n  rmsprop: OptimizerConstructors.rmsprop,\n  adamax: OptimizerConstructors.adamax,\n  adam: OptimizerConstructors.adam\n},\n    setBackend = Environment.setBackend,\n    getBackend = Environment.getBackend,\n    disposeVariables = Environment.disposeVariables,\n    memory = Environment.memory;\n\nsetOpHandler(ops);\nexport { setBackend, getBackend, disposeVariables, memory, version as version_core, nextFrame, environment, io, math, serialization, test_util, util, webgl, AdadeltaOptimizer, AdagradOptimizer, AdamOptimizer, AdamaxOptimizer, MomentumOptimizer, Optimizer, RMSPropOptimizer, SGDOptimizer, Tensor, TensorBuffer, variable, Variable, Rank, Reduction, ENV, Environment, KernelBackend, DataStorage, image_ops as image, linalg_ops as linalg, loss_ops as losses, spectral_ops as spectral, op, batchNormalization2d, batchNormalization3d, batchNormalization4d, batchNormalization, complex, real, imag, concat, concat1d, concat2d, concat3d, concat4d, split$1 as split, conv1d, conv2d, conv2dDerFilter, depthwiseConv2d, separableConv2d, conv2dTranspose, matMul, dot, outerProduct, reverse, reverse1d, reverse2d, reverse3d, reverse4d, maxPool, avgPool, pool, slice, slice1d, slice2d, slice3d, slice4d, abs, acos, acosh, asin, asinh, atan, atanh, ceil, clipByValue, cos, cosh, erf, exp, expm1, floor, log$1 as log, log1p, logSigmoid, neg, reciprocal, round, rsqrt, sigmoid, sign, sin, sinh, softplus, sqrt, square, step, tan, tanh$1 as tanh, all, any, argMax, argMin, logSumExp, max, mean, min, moments, sum$1 as sum, prod, equal, equalStrict, greater, greaterEqual, greaterEqualStrict, greaterStrict, less, lessEqual, lessEqualStrict, lessStrict, notEqual, notEqualStrict, add, addN, addStrict, atan2, div, divStrict, floorDiv, maximum, maximumStrict, minimum, minimumStrict, mod, modStrict, mul, mulStrict, pow, powStrict, squaredDifference, squaredDifferenceStrict, sub, subStrict, elu, leakyRelu, prelu, relu, selu, logicalAnd, logicalNot, logicalOr, logicalXor, where, whereAsync, buffer, toPixels, print, batchToSpaceND, cast, clone, cumsum, depthToSpace, expandDims, eye, fromPixels, multinomial, oneHot, pad, pad1d, pad2d, pad3d, pad4d, rand, randomNormal, randomUniform, reshape, spaceToBatchND, squeeze, stack, tile, truncatedNormal, unstack, setdiff1dAsync, fill, linspace, ones$1 as ones, range, scalar, tensor, tensor1d, tensor2d, tensor3d, tensor4d, tensor5d, tensor6d, zeros, onesLike, zerosLike, transpose, softmax, logSoftmax, localResponseNormalization, norm, gather, unsortedSegmentSum, basicLSTMCell, multiRNNCell, movingAverage, stridedSlice, topk, scatterND, fft, ifft, rfft, irfft, sparseToDense, gatherND, train, tidy, keep, dispose, time, profile, customGrad, grad, grads, valueAndGrad, valueAndGrads, variableGrads };","map":null,"metadata":{},"sourceType":"module"}